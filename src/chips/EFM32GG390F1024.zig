const micro = @import("microzig");
const mmio = micro.mmio;

pub const devices = struct {
    ///  Silicon Labs EFM32GG390F1024 Cortex-M MCU
    pub const EFM32GG390F1024 = struct {
        pub const properties = struct {
            pub const @"cpu.endian" = "little";
            pub const @"cpu.mpuPresent" = "true";
            pub const license =
                \\
                \\    *******************************************************************************\n
                \\    * # License                                                                    \n
                \\    * Copyright 2022 Silicon Laboratories Inc. www.silabs.com                      \n
                \\    *******************************************************************************\n
                \\    *                                                                              \n
                \\    * SPDX-License-Identifier: Zlib                                                \n
                \\    *                                                                              \n
                \\    * The licensor of this software is Silicon Laboratories Inc.                   \n
                \\    *                                                                              \n
                \\    * This software is provided 'as-is', without any express or implied            \n
                \\    * warranty. In no event will the authors be held liable for any damages        \n
                \\    * arising from the use of this software.                                       \n
                \\    *                                                                              \n
                \\    * Permission is granted to anyone to use this software for any purpose,        \n
                \\    * including commercial applications, and to alter it and redistribute it       \n
                \\    * freely, subject to the following restrictions:                               \n
                \\    *                                                                              \n
                \\    * 1. The origin of this software must not be misrepresented; you must not      \n
                \\    *    claim that you wrote the original software. If you use this software      \n
                \\    *    in a product, an acknowledgment in the product documentation would be     \n
                \\    *    appreciated but is not required.                                          \n
                \\    * 2. Altered source versions must be plainly marked as such, and must not be   \n
                \\    *    misrepresented as being the original software.                            \n
                \\    * 3. This notice may not be removed or altered from any source distribution.   \n
                \\    *                                                                              \n
                \\    *******************************************************************************
                \\  
            ;
            pub const @"cpu.name" = "CM3";
            pub const @"cpu.revision" = "r2p1";
            pub const @"cpu.nvicPrioBits" = "3";
            pub const @"cpu.vendorSystickConfig" = "false";
            pub const @"cpu.fpuPresent" = "false";
        };

        pub const VectorTable = extern struct {
            const Handler = micro.interrupt.Handler;
            const unhandled = micro.interrupt.unhandled;

            initial_stack_pointer: u32,
            Reset: Handler = unhandled,
            NMI: Handler = unhandled,
            HardFault: Handler = unhandled,
            MemManageFault: Handler = unhandled,
            BusFault: Handler = unhandled,
            UsageFault: Handler = unhandled,
            reserved5: [4]u32 = undefined,
            SVCall: Handler = unhandled,
            reserved10: [2]u32 = undefined,
            PendSV: Handler = unhandled,
            SysTick: Handler = unhandled,
            DMA: Handler = unhandled,
            GPIO_EVEN: Handler = unhandled,
            TIMER0: Handler = unhandled,
            USART0_RX: Handler = unhandled,
            USART0_TX: Handler = unhandled,
            USB: Handler = unhandled,
            ACMP0: Handler = unhandled,
            ADC0: Handler = unhandled,
            DAC0: Handler = unhandled,
            I2C0: Handler = unhandled,
            I2C1: Handler = unhandled,
            GPIO_ODD: Handler = unhandled,
            TIMER1: Handler = unhandled,
            TIMER2: Handler = unhandled,
            TIMER3: Handler = unhandled,
            USART1_RX: Handler = unhandled,
            USART1_TX: Handler = unhandled,
            LESENSE: Handler = unhandled,
            USART2_RX: Handler = unhandled,
            USART2_TX: Handler = unhandled,
            UART0_RX: Handler = unhandled,
            UART0_TX: Handler = unhandled,
            UART1_RX: Handler = unhandled,
            UART1_TX: Handler = unhandled,
            LEUART0: Handler = unhandled,
            LEUART1: Handler = unhandled,
            LETIMER0: Handler = unhandled,
            PCNT0: Handler = unhandled,
            PCNT1: Handler = unhandled,
            PCNT2: Handler = unhandled,
            RTC: Handler = unhandled,
            BURTC: Handler = unhandled,
            CMU: Handler = unhandled,
            VCMP: Handler = unhandled,
            reserved48: [1]u32 = undefined,
            MSC: Handler = unhandled,
            AES: Handler = unhandled,
            EBI: Handler = unhandled,
            EMU: Handler = unhandled,
        };

        pub const peripherals = struct {
            ///  VCMP
            pub const VCMP = @ptrFromInt(*volatile types.peripherals.VCMP, 0x40000000);
            ///  ACMP0
            pub const ACMP0 = @ptrFromInt(*volatile types.peripherals.ACMP0, 0x40001000);
            ///  ACMP1
            pub const ACMP1 = @ptrFromInt(*volatile types.peripherals.ACMP1, 0x40001400);
            ///  ADC0
            pub const ADC0 = @ptrFromInt(*volatile types.peripherals.ADC0, 0x40002000);
            ///  DAC0
            pub const DAC0 = @ptrFromInt(*volatile types.peripherals.DAC0, 0x40004000);
            ///  GPIO
            pub const GPIO = @ptrFromInt(*volatile types.peripherals.GPIO, 0x40006000);
            ///  EBI
            pub const EBI = @ptrFromInt(*volatile types.peripherals.EBI, 0x40008000);
            ///  I2C0
            pub const I2C0 = @ptrFromInt(*volatile types.peripherals.I2C0, 0x4000a000);
            ///  I2C1
            pub const I2C1 = @ptrFromInt(*volatile types.peripherals.I2C1, 0x4000a400);
            ///  USART0
            pub const USART0 = @ptrFromInt(*volatile types.peripherals.USART0, 0x4000c000);
            ///  USART1
            pub const USART1 = @ptrFromInt(*volatile types.peripherals.USART1, 0x4000c400);
            ///  USART2
            pub const USART2 = @ptrFromInt(*volatile types.peripherals.USART2, 0x4000c800);
            ///  UART0
            pub const UART0 = @ptrFromInt(*volatile types.peripherals.UART0, 0x4000e000);
            ///  UART1
            pub const UART1 = @ptrFromInt(*volatile types.peripherals.UART1, 0x4000e400);
            ///  TIMER0
            pub const TIMER0 = @ptrFromInt(*volatile types.peripherals.TIMER0, 0x40010000);
            ///  TIMER1
            pub const TIMER1 = @ptrFromInt(*volatile types.peripherals.TIMER1, 0x40010400);
            ///  TIMER2
            pub const TIMER2 = @ptrFromInt(*volatile types.peripherals.TIMER2, 0x40010800);
            ///  TIMER3
            pub const TIMER3 = @ptrFromInt(*volatile types.peripherals.TIMER3, 0x40010c00);
            ///  RTC
            pub const RTC = @ptrFromInt(*volatile types.peripherals.RTC, 0x40080000);
            ///  BURTC
            pub const BURTC = @ptrFromInt(*volatile types.peripherals.BURTC, 0x40081000);
            ///  LETIMER0
            pub const LETIMER0 = @ptrFromInt(*volatile types.peripherals.LETIMER0, 0x40082000);
            ///  LEUART0
            pub const LEUART0 = @ptrFromInt(*volatile types.peripherals.LEUART0, 0x40084000);
            ///  LEUART1
            pub const LEUART1 = @ptrFromInt(*volatile types.peripherals.LEUART1, 0x40084400);
            ///  PCNT0
            pub const PCNT0 = @ptrFromInt(*volatile types.peripherals.PCNT0, 0x40086000);
            ///  PCNT1
            pub const PCNT1 = @ptrFromInt(*volatile types.peripherals.PCNT1, 0x40086400);
            ///  PCNT2
            pub const PCNT2 = @ptrFromInt(*volatile types.peripherals.PCNT2, 0x40086800);
            ///  WDOG
            pub const WDOG = @ptrFromInt(*volatile types.peripherals.WDOG, 0x40088000);
            ///  LESENSE
            pub const LESENSE = @ptrFromInt(*volatile types.peripherals.LESENSE, 0x4008c000);
            ///  MSC
            pub const MSC = @ptrFromInt(*volatile types.peripherals.MSC, 0x400c0000);
            ///  DMA
            pub const DMA = @ptrFromInt(*volatile types.peripherals.DMA, 0x400c2000);
            ///  USB
            pub const USB = @ptrFromInt(*volatile types.peripherals.USB, 0x400c4000);
            ///  EMU
            pub const EMU = @ptrFromInt(*volatile types.peripherals.EMU, 0x400c6000);
            ///  CMU
            pub const CMU = @ptrFromInt(*volatile types.peripherals.CMU, 0x400c8000);
            ///  RMU
            pub const RMU = @ptrFromInt(*volatile types.peripherals.RMU, 0x400ca000);
            ///  PRS
            pub const PRS = @ptrFromInt(*volatile types.peripherals.PRS, 0x400cc000);
            ///  AES
            pub const AES = @ptrFromInt(*volatile types.peripherals.AES, 0x400e0000);
            ///  ETM
            pub const ETM = @ptrFromInt(*volatile types.peripherals.ETM, 0xe0041000);
        };
    };
};

pub const types = struct {
    pub const peripherals = struct {
        ///  DMA
        pub const DMA = extern struct {
            ///  DMA Status Registers
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  DMA Enable Status
                EN: u1,
                reserved4: u3,
                ///  Control Current State
                STATE: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Idle
                        IDLE = 0x0,
                        ///  Reading channel controller data
                        RDCHCTRLDATA = 0x1,
                        ///  Reading source data end pointer
                        RDSRCENDPTR = 0x2,
                        ///  Reading destination data end pointer
                        RDDSTENDPTR = 0x3,
                        ///  Reading source data
                        RDSRCDATA = 0x4,
                        ///  Writing destination data
                        WRDSTDATA = 0x5,
                        ///  Waiting for DMA request to clear
                        WAITREQCLR = 0x6,
                        ///  Writing channel controller data
                        WRCHCTRLDATA = 0x7,
                        ///  Stalled
                        STALLED = 0x8,
                        ///  Done
                        DONE = 0x9,
                        ///  Peripheral scatter-gather transition
                        PERSCATTRANS = 0xa,
                        _,
                    },
                },
                reserved16: u8,
                ///  Channel Number
                CHNUM: u5,
                padding: u11,
            }),
            ///  DMA Configuration Register
            CONFIG: mmio.Mmio(packed struct(u32) {
                ///  Enable DMA
                EN: u1,
                reserved5: u4,
                ///  Channel Protection Control
                CHPROT: u1,
                padding: u26,
            }),
            ///  Channel Control Data Base Pointer Register
            CTRLBASE: mmio.Mmio(packed struct(u32) {
                ///  Channel Control Data Base Pointer
                CTRLBASE: u32,
            }),
            ///  Channel Alternate Control Data Base Pointer Register
            ALTCTRLBASE: mmio.Mmio(packed struct(u32) {
                ///  Channel Alternate Control Data Base Pointer
                ALTCTRLBASE: u32,
            }),
            ///  Channel Wait on Request Status Register
            CHWAITSTATUS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Wait on Request Status
                CH0WAITSTATUS: u1,
                ///  Channel 1 Wait on Request Status
                CH1WAITSTATUS: u1,
                ///  Channel 2 Wait on Request Status
                CH2WAITSTATUS: u1,
                ///  Channel 3 Wait on Request Status
                CH3WAITSTATUS: u1,
                ///  Channel 4 Wait on Request Status
                CH4WAITSTATUS: u1,
                ///  Channel 5 Wait on Request Status
                CH5WAITSTATUS: u1,
                ///  Channel 6 Wait on Request Status
                CH6WAITSTATUS: u1,
                ///  Channel 7 Wait on Request Status
                CH7WAITSTATUS: u1,
                ///  Channel 8 Wait on Request Status
                CH8WAITSTATUS: u1,
                ///  Channel 9 Wait on Request Status
                CH9WAITSTATUS: u1,
                ///  Channel 10 Wait on Request Status
                CH10WAITSTATUS: u1,
                ///  Channel 11 Wait on Request Status
                CH11WAITSTATUS: u1,
                padding: u20,
            }),
            ///  Channel Software Request Register
            CHSWREQ: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Software Request
                CH0SWREQ: u1,
                ///  Channel 1 Software Request
                CH1SWREQ: u1,
                ///  Channel 2 Software Request
                CH2SWREQ: u1,
                ///  Channel 3 Software Request
                CH3SWREQ: u1,
                ///  Channel 4 Software Request
                CH4SWREQ: u1,
                ///  Channel 5 Software Request
                CH5SWREQ: u1,
                ///  Channel 6 Software Request
                CH6SWREQ: u1,
                ///  Channel 7 Software Request
                CH7SWREQ: u1,
                ///  Channel 8 Software Request
                CH8SWREQ: u1,
                ///  Channel 9 Software Request
                CH9SWREQ: u1,
                ///  Channel 10 Software Request
                CH10SWREQ: u1,
                ///  Channel 11 Software Request
                CH11SWREQ: u1,
                padding: u20,
            }),
            ///  Channel Useburst Set Register
            CHUSEBURSTS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Useburst Set
                CH0USEBURSTS: u1,
                ///  Channel 1 Useburst Set
                CH1USEBURSTS: u1,
                ///  Channel 2 Useburst Set
                CH2USEBURSTS: u1,
                ///  Channel 3 Useburst Set
                CH3USEBURSTS: u1,
                ///  Channel 4 Useburst Set
                CH4USEBURSTS: u1,
                ///  Channel 5 Useburst Set
                CH5USEBURSTS: u1,
                ///  Channel 6 Useburst Set
                CH6USEBURSTS: u1,
                ///  Channel 7 Useburst Set
                CH7USEBURSTS: u1,
                ///  Channel 8 Useburst Set
                CH8USEBURSTS: u1,
                ///  Channel 9 Useburst Set
                CH9USEBURSTS: u1,
                ///  Channel 10 Useburst Set
                CH10USEBURSTS: u1,
                ///  Channel 11 Useburst Set
                CH11USEBURSTS: u1,
                padding: u20,
            }),
            ///  Channel Useburst Clear Register
            CHUSEBURSTC: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Useburst Clear
                CH0USEBURSTC: u1,
                ///  Channel 1 Useburst Clear
                CH1USEBURSTC: u1,
                ///  Channel 2 Useburst Clear
                CH2USEBURSTC: u1,
                ///  Channel 3 Useburst Clear
                CH3USEBURSTC: u1,
                ///  Channel 4 Useburst Clear
                CH4USEBURSTC: u1,
                ///  Channel 5 Useburst Clear
                CH5USEBURSTC: u1,
                ///  Channel 6 Useburst Clear
                CH6USEBURSTC: u1,
                ///  Channel 7 Useburst Clear
                CH7USEBURSTC: u1,
                ///  Channel 8 Useburst Clear
                CH08USEBURSTC: u1,
                ///  Channel 9 Useburst Clear
                CH9USEBURSTC: u1,
                ///  Channel 10 Useburst Clear
                CH10USEBURSTC: u1,
                ///  Channel 11 Useburst Clear
                CH11USEBURSTC: u1,
                padding: u20,
            }),
            ///  Channel Request Mask Set Register
            CHREQMASKS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Request Mask Set
                CH0REQMASKS: u1,
                ///  Channel 1 Request Mask Set
                CH1REQMASKS: u1,
                ///  Channel 2 Request Mask Set
                CH2REQMASKS: u1,
                ///  Channel 3 Request Mask Set
                CH3REQMASKS: u1,
                ///  Channel 4 Request Mask Set
                CH4REQMASKS: u1,
                ///  Channel 5 Request Mask Set
                CH5REQMASKS: u1,
                ///  Channel 6 Request Mask Set
                CH6REQMASKS: u1,
                ///  Channel 7 Request Mask Set
                CH7REQMASKS: u1,
                ///  Channel 8 Request Mask Set
                CH8REQMASKS: u1,
                ///  Channel 9 Request Mask Set
                CH9REQMASKS: u1,
                ///  Channel 10 Request Mask Set
                CH10REQMASKS: u1,
                ///  Channel 11 Request Mask Set
                CH11REQMASKS: u1,
                padding: u20,
            }),
            ///  Channel Request Mask Clear Register
            CHREQMASKC: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Request Mask Clear
                CH0REQMASKC: u1,
                ///  Channel 1 Request Mask Clear
                CH1REQMASKC: u1,
                ///  Channel 2 Request Mask Clear
                CH2REQMASKC: u1,
                ///  Channel 3 Request Mask Clear
                CH3REQMASKC: u1,
                ///  Channel 4 Request Mask Clear
                CH4REQMASKC: u1,
                ///  Channel 5 Request Mask Clear
                CH5REQMASKC: u1,
                ///  Channel 6 Request Mask Clear
                CH6REQMASKC: u1,
                ///  Channel 7 Request Mask Clear
                CH7REQMASKC: u1,
                ///  Channel 8 Request Mask Clear
                CH8REQMASKC: u1,
                ///  Channel 9 Request Mask Clear
                CH9REQMASKC: u1,
                ///  Channel 10 Request Mask Clear
                CH10REQMASKC: u1,
                ///  Channel 11 Request Mask Clear
                CH11REQMASKC: u1,
                padding: u20,
            }),
            ///  Channel Enable Set Register
            CHENS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Enable Set
                CH0ENS: u1,
                ///  Channel 1 Enable Set
                CH1ENS: u1,
                ///  Channel 2 Enable Set
                CH2ENS: u1,
                ///  Channel 3 Enable Set
                CH3ENS: u1,
                ///  Channel 4 Enable Set
                CH4ENS: u1,
                ///  Channel 5 Enable Set
                CH5ENS: u1,
                ///  Channel 6 Enable Set
                CH6ENS: u1,
                ///  Channel 7 Enable Set
                CH7ENS: u1,
                ///  Channel 8 Enable Set
                CH8ENS: u1,
                ///  Channel 9 Enable Set
                CH9ENS: u1,
                ///  Channel 10 Enable Set
                CH10ENS: u1,
                ///  Channel 11 Enable Set
                CH11ENS: u1,
                padding: u20,
            }),
            ///  Channel Enable Clear Register
            CHENC: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Enable Clear
                CH0ENC: u1,
                ///  Channel 1 Enable Clear
                CH1ENC: u1,
                ///  Channel 2 Enable Clear
                CH2ENC: u1,
                ///  Channel 3 Enable Clear
                CH3ENC: u1,
                ///  Channel 4 Enable Clear
                CH4ENC: u1,
                ///  Channel 5 Enable Clear
                CH5ENC: u1,
                ///  Channel 6 Enable Clear
                CH6ENC: u1,
                ///  Channel 7 Enable Clear
                CH7ENC: u1,
                ///  Channel 8 Enable Clear
                CH8ENC: u1,
                ///  Channel 9 Enable Clear
                CH9ENC: u1,
                ///  Channel 10 Enable Clear
                CH10ENC: u1,
                ///  Channel 11 Enable Clear
                CH11ENC: u1,
                padding: u20,
            }),
            ///  Channel Alternate Set Register
            CHALTS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Alternate Structure Set
                CH0ALTS: u1,
                ///  Channel 1 Alternate Structure Set
                CH1ALTS: u1,
                ///  Channel 2 Alternate Structure Set
                CH2ALTS: u1,
                ///  Channel 3 Alternate Structure Set
                CH3ALTS: u1,
                ///  Channel 4 Alternate Structure Set
                CH4ALTS: u1,
                ///  Channel 5 Alternate Structure Set
                CH5ALTS: u1,
                ///  Channel 6 Alternate Structure Set
                CH6ALTS: u1,
                ///  Channel 7 Alternate Structure Set
                CH7ALTS: u1,
                ///  Channel 8 Alternate Structure Set
                CH8ALTS: u1,
                ///  Channel 9 Alternate Structure Set
                CH9ALTS: u1,
                ///  Channel 10 Alternate Structure Set
                CH10ALTS: u1,
                ///  Channel 11 Alternate Structure Set
                CH11ALTS: u1,
                padding: u20,
            }),
            ///  Channel Alternate Clear Register
            CHALTC: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Alternate Clear
                CH0ALTC: u1,
                ///  Channel 1 Alternate Clear
                CH1ALTC: u1,
                ///  Channel 2 Alternate Clear
                CH2ALTC: u1,
                ///  Channel 3 Alternate Clear
                CH3ALTC: u1,
                ///  Channel 4 Alternate Clear
                CH4ALTC: u1,
                ///  Channel 5 Alternate Clear
                CH5ALTC: u1,
                ///  Channel 6 Alternate Clear
                CH6ALTC: u1,
                ///  Channel 7 Alternate Clear
                CH7ALTC: u1,
                ///  Channel 8 Alternate Clear
                CH8ALTC: u1,
                ///  Channel 9 Alternate Clear
                CH9ALTC: u1,
                ///  Channel 10 Alternate Clear
                CH10ALTC: u1,
                ///  Channel 11 Alternate Clear
                CH11ALTC: u1,
                padding: u20,
            }),
            ///  Channel Priority Set Register
            CHPRIS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 High Priority Set
                CH0PRIS: u1,
                ///  Channel 1 High Priority Set
                CH1PRIS: u1,
                ///  Channel 2 High Priority Set
                CH2PRIS: u1,
                ///  Channel 3 High Priority Set
                CH3PRIS: u1,
                ///  Channel 4 High Priority Set
                CH4PRIS: u1,
                ///  Channel 5 High Priority Set
                CH5PRIS: u1,
                ///  Channel 6 High Priority Set
                CH6PRIS: u1,
                ///  Channel 7 High Priority Set
                CH7PRIS: u1,
                ///  Channel 8 High Priority Set
                CH8PRIS: u1,
                ///  Channel 9 High Priority Set
                CH9PRIS: u1,
                ///  Channel 10 High Priority Set
                CH10PRIS: u1,
                ///  Channel 11 High Priority Set
                CH11PRIS: u1,
                padding: u20,
            }),
            ///  Channel Priority Clear Register
            CHPRIC: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 High Priority Clear
                CH0PRIC: u1,
                ///  Channel 1 High Priority Clear
                CH1PRIC: u1,
                ///  Channel 2 High Priority Clear
                CH2PRIC: u1,
                ///  Channel 3 High Priority Clear
                CH3PRIC: u1,
                ///  Channel 4 High Priority Clear
                CH4PRIC: u1,
                ///  Channel 5 High Priority Clear
                CH5PRIC: u1,
                ///  Channel 6 High Priority Clear
                CH6PRIC: u1,
                ///  Channel 7 High Priority Clear
                CH7PRIC: u1,
                ///  Channel 8 High Priority Clear
                CH8PRIC: u1,
                ///  Channel 9 High Priority Clear
                CH9PRIC: u1,
                ///  Channel 10 High Priority Clear
                CH10PRIC: u1,
                ///  Channel 11 High Priority Clear
                CH11PRIC: u1,
                padding: u20,
            }),
            reserved76: [12]u8,
            ///  Bus Error Clear Register
            ERRORC: mmio.Mmio(packed struct(u32) {
                ///  Bus Error Clear
                ERRORC: u1,
                padding: u31,
            }),
            reserved3600: [3520]u8,
            ///  Channel Request Status
            CHREQSTATUS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Request Status
                CH0REQSTATUS: u1,
                ///  Channel 1 Request Status
                CH1REQSTATUS: u1,
                ///  Channel 2 Request Status
                CH2REQSTATUS: u1,
                ///  Channel 3 Request Status
                CH3REQSTATUS: u1,
                ///  Channel 4 Request Status
                CH4REQSTATUS: u1,
                ///  Channel 5 Request Status
                CH5REQSTATUS: u1,
                ///  Channel 6 Request Status
                CH6REQSTATUS: u1,
                ///  Channel 7 Request Status
                CH7REQSTATUS: u1,
                ///  Channel 8 Request Status
                CH8REQSTATUS: u1,
                ///  Channel 9 Request Status
                CH9REQSTATUS: u1,
                ///  Channel 10 Request Status
                CH10REQSTATUS: u1,
                ///  Channel 11 Request Status
                CH11REQSTATUS: u1,
                padding: u20,
            }),
            reserved3608: [4]u8,
            ///  Channel Single Request Status
            CHSREQSTATUS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Single Request Status
                CH0SREQSTATUS: u1,
                ///  Channel 1 Single Request Status
                CH1SREQSTATUS: u1,
                ///  Channel 2 Single Request Status
                CH2SREQSTATUS: u1,
                ///  Channel 3 Single Request Status
                CH3SREQSTATUS: u1,
                ///  Channel 4 Single Request Status
                CH4SREQSTATUS: u1,
                ///  Channel 5 Single Request Status
                CH5SREQSTATUS: u1,
                ///  Channel 6 Single Request Status
                CH6SREQSTATUS: u1,
                ///  Channel 7 Single Request Status
                CH7SREQSTATUS: u1,
                ///  Channel 8 Single Request Status
                CH8SREQSTATUS: u1,
                ///  Channel 9 Single Request Status
                CH9SREQSTATUS: u1,
                ///  Channel 10 Single Request Status
                CH10SREQSTATUS: u1,
                ///  Channel 11 Single Request Status
                CH11SREQSTATUS: u1,
                padding: u20,
            }),
            reserved4096: [484]u8,
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel 0 Complete Interrupt Flag
                CH0DONE: u1,
                ///  DMA Channel 1 Complete Interrupt Flag
                CH1DONE: u1,
                ///  DMA Channel 2 Complete Interrupt Flag
                CH2DONE: u1,
                ///  DMA Channel 3 Complete Interrupt Flag
                CH3DONE: u1,
                ///  DMA Channel 4 Complete Interrupt Flag
                CH4DONE: u1,
                ///  DMA Channel 5 Complete Interrupt Flag
                CH5DONE: u1,
                ///  DMA Channel 6 Complete Interrupt Flag
                CH6DONE: u1,
                ///  DMA Channel 7 Complete Interrupt Flag
                CH7DONE: u1,
                ///  DMA Channel 8 Complete Interrupt Flag
                CH8DONE: u1,
                ///  DMA Channel 9 Complete Interrupt Flag
                CH9DONE: u1,
                ///  DMA Channel 10 Complete Interrupt Flag
                CH10DONE: u1,
                ///  DMA Channel 11 Complete Interrupt Flag
                CH11DONE: u1,
                reserved31: u19,
                ///  DMA Error Interrupt Flag
                ERR: u1,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel 0 Complete Interrupt Flag Set
                CH0DONE: u1,
                ///  DMA Channel 1 Complete Interrupt Flag Set
                CH1DONE: u1,
                ///  DMA Channel 2 Complete Interrupt Flag Set
                CH2DONE: u1,
                ///  DMA Channel 3 Complete Interrupt Flag Set
                CH3DONE: u1,
                ///  DMA Channel 4 Complete Interrupt Flag Set
                CH4DONE: u1,
                ///  DMA Channel 5 Complete Interrupt Flag Set
                CH5DONE: u1,
                ///  DMA Channel 6 Complete Interrupt Flag Set
                CH6DONE: u1,
                ///  DMA Channel 7 Complete Interrupt Flag Set
                CH7DONE: u1,
                ///  DMA Channel 8 Complete Interrupt Flag Set
                CH8DONE: u1,
                ///  DMA Channel 9 Complete Interrupt Flag Set
                CH9DONE: u1,
                ///  DMA Channel 10 Complete Interrupt Flag Set
                CH10DONE: u1,
                ///  DMA Channel 11 Complete Interrupt Flag Set
                CH11DONE: u1,
                reserved31: u19,
                ///  DMA Error Interrupt Flag Set
                ERR: u1,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel 0 Complete Interrupt Flag Clear
                CH0DONE: u1,
                ///  DMA Channel 1 Complete Interrupt Flag Clear
                CH1DONE: u1,
                ///  DMA Channel 2 Complete Interrupt Flag Clear
                CH2DONE: u1,
                ///  DMA Channel 3 Complete Interrupt Flag Clear
                CH3DONE: u1,
                ///  DMA Channel 4 Complete Interrupt Flag Clear
                CH4DONE: u1,
                ///  DMA Channel 5 Complete Interrupt Flag Clear
                CH5DONE: u1,
                ///  DMA Channel 6 Complete Interrupt Flag Clear
                CH6DONE: u1,
                ///  DMA Channel 7 Complete Interrupt Flag Clear
                CH7DONE: u1,
                ///  DMA Channel 8 Complete Interrupt Flag Clear
                CH8DONE: u1,
                ///  DMA Channel 9 Complete Interrupt Flag Clear
                CH9DONE: u1,
                ///  DMA Channel 10 Complete Interrupt Flag Clear
                CH10DONE: u1,
                ///  DMA Channel 11 Complete Interrupt Flag Clear
                CH11DONE: u1,
                reserved31: u19,
                ///  DMA Error Interrupt Flag Clear
                ERR: u1,
            }),
            ///  Interrupt Enable register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel 0 Complete Interrupt Enable
                CH0DONE: u1,
                ///  DMA Channel 1 Complete Interrupt Enable
                CH1DONE: u1,
                ///  DMA Channel 2 Complete Interrupt Enable
                CH2DONE: u1,
                ///  DMA Channel 3 Complete Interrupt Enable
                CH3DONE: u1,
                ///  DMA Channel 4 Complete Interrupt Enable
                CH4DONE: u1,
                ///  DMA Channel 5 Complete Interrupt Enable
                CH5DONE: u1,
                ///  DMA Channel 6 Complete Interrupt Enable
                CH6DONE: u1,
                ///  DMA Channel 7 Complete Interrupt Enable
                CH7DONE: u1,
                ///  DMA Channel 8 Complete Interrupt Enable
                CH8DONE: u1,
                ///  DMA Channel 9 Complete Interrupt Enable
                CH9DONE: u1,
                ///  DMA Channel 10 Complete Interrupt Enable
                CH10DONE: u1,
                ///  DMA Channel 11 Complete Interrupt Enable
                CH11DONE: u1,
                reserved31: u19,
                ///  DMA Error Interrupt Flag Enable
                ERR: u1,
            }),
            ///  DMA Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Descriptor Specifies Rectangle
                DESCRECT: u1,
                ///  Prevent Rect Descriptor Update
                PRDU: u1,
                padding: u30,
            }),
            ///  DMA Retain Descriptor State
            RDS: mmio.Mmio(packed struct(u32) {
                ///  Retain Descriptor State
                RDSCH0: u1,
                ///  Retain Descriptor State
                RDSCH1: u1,
                ///  Retain Descriptor State
                RDSCH2: u1,
                ///  Retain Descriptor State
                RDSCH3: u1,
                ///  Retain Descriptor State
                RDSCH4: u1,
                ///  Retain Descriptor State
                RDSCH5: u1,
                ///  Retain Descriptor State
                RDSCH6: u1,
                ///  Retain Descriptor State
                RDSCH7: u1,
                ///  Retain Descriptor State
                RDSCH8: u1,
                ///  Retain Descriptor State
                RDSCH9: u1,
                ///  Retain Descriptor State
                RDSCH10: u1,
                ///  Retain Descriptor State
                RDSCH11: u1,
                padding: u20,
            }),
            reserved4128: [8]u8,
            ///  Channel 0 Loop Register
            LOOP0: mmio.Mmio(packed struct(u32) {
                ///  Loop Width
                WIDTH: u10,
                reserved16: u6,
                ///  DMA Channel 0 Loop Enable
                EN: u1,
                padding: u15,
            }),
            ///  Channel 1 Loop Register
            LOOP1: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel 1 Loop Width
                WIDTH: u10,
                reserved16: u6,
                ///  DMA Channel 1 Loop Enable
                EN: u1,
                padding: u15,
            }),
            reserved4192: [56]u8,
            ///  Channel 0 Rectangle Register
            RECT0: mmio.Mmio(packed struct(u32) {
                ///  DMA Channel 0 Rectangle Height
                HEIGHT: u10,
                ///  DMA Channel 0 Source Stride
                SRCSTRIDE: u11,
                ///  DMA Channel 0 Destination Stride
                DSTSTRIDE: u11,
            }),
            reserved4352: [156]u8,
            ///  Channel Control Register
            CH0_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH1_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH2_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH3_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH4_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH5_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH6_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH7_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH8_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH9_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH10_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
            ///  Channel Control Register
            CH11_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u4,
                reserved16: u12,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0xa,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0xc,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0xd,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0xe,
                        ///  Low Energy UART 0
                        LEUART0 = 0x10,
                        ///  Low Energy UART 1
                        LEUART1 = 0x11,
                        ///  I2C 0
                        I2C0 = 0x14,
                        ///  I2C 1
                        I2C1 = 0x15,
                        ///  Timer 0
                        TIMER0 = 0x18,
                        ///  Timer 1
                        TIMER1 = 0x19,
                        ///  Timer 2
                        TIMER2 = 0x1a,
                        ///  Timer 3
                        TIMER3 = 0x1b,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x2c,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2d,
                        MSC = 0x30,
                        ///  Advanced Encryption Standard Accelerator
                        AES = 0x31,
                        ///  Low Energy Sensor Interface
                        LESENSE = 0x32,
                        ///  External Bus Interface
                        EBI = 0x33,
                        _,
                    },
                },
                padding: u10,
            }),
        };

        ///  AES
        pub const AES = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Decryption/Encryption Mode
                DECRYPT: u1,
                ///  AES-256 Mode
                AES256: u1,
                ///  Key Buffer Enable
                KEYBUFEN: u1,
                reserved4: u1,
                ///  AES_DATA Write Start
                DATASTART: u1,
                ///  AES_XORDATA Write Start
                XORSTART: u1,
                ///  Configure byte order in data and key registers
                BYTEORDER: u1,
                padding: u25,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Encryption/Decryption Start
                START: u1,
                ///  Encryption/Decryption Stop
                STOP: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  AES Running
                RUNNING: u1,
                padding: u31,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Encryption/Decryption Done Interrupt Enable
                DONE: u1,
                padding: u31,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Encryption/Decryption Done Interrupt Flag
                DONE: u1,
                padding: u31,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Encryption/Decryption Done Interrupt Flag Set
                DONE: u1,
                padding: u31,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Encryption/Decryption Done Interrupt Flag Clear
                DONE: u1,
                padding: u31,
            }),
            ///  DATA Register
            DATA: mmio.Mmio(packed struct(u32) {
                ///  Data Access
                DATA: u32,
            }),
            ///  XORDATA Register
            XORDATA: mmio.Mmio(packed struct(u32) {
                ///  XOR Data Access
                XORDATA: u32,
            }),
            reserved48: [12]u8,
            ///  KEY Low Register
            KEYLA: mmio.Mmio(packed struct(u32) {
                ///  Key Low Access A
                KEYLA: u32,
            }),
            ///  KEY Low Register
            KEYLB: mmio.Mmio(packed struct(u32) {
                ///  Key Low Access B
                KEYLB: u32,
            }),
            ///  KEY Low Register
            KEYLC: mmio.Mmio(packed struct(u32) {
                ///  Key Low Access C
                KEYLC: u32,
            }),
            ///  KEY Low Register
            KEYLD: mmio.Mmio(packed struct(u32) {
                ///  Key Low Access D
                KEYLD: u32,
            }),
            ///  KEY High Register
            KEYHA: mmio.Mmio(packed struct(u32) {
                ///  Key High Access A
                KEYHA: u32,
            }),
            ///  KEY High Register
            KEYHB: mmio.Mmio(packed struct(u32) {
                ///  Key High Access B
                KEYHB: u32,
            }),
            ///  KEY High Register
            KEYHC: mmio.Mmio(packed struct(u32) {
                ///  Key High Access C
                KEYHC: u32,
            }),
            ///  KEY High Register
            KEYHD: mmio.Mmio(packed struct(u32) {
                ///  Key High Access D
                KEYHD: u32,
            }),
        };

        ///  USB
        pub const USB = extern struct {
            ///  System Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  VBUSEN Active Polarity
                VBUSENAP: u1,
                ///  DMPU Active Polarity
                DMPUAP: u1,
                reserved16: u14,
                ///  Voltage Regulator Disable
                VREGDIS: u1,
                ///  VREGO Sense Enable
                VREGOSEN: u1,
                reserved20: u2,
                ///  Regulator Bias Programming Value in EM0/1
                BIASPROGEM01: u2,
                reserved24: u2,
                ///  Regulator Bias Programming Value in EM2/3
                BIASPROGEM23: u2,
                padding: u6,
            }),
            ///  System Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  VREGO Sense Output
                VREGOS: u1,
                padding: u31,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  VREGO Sense High Interrupt Flag
                VREGOSH: u1,
                ///  VREGO Sense Low Interrupt Flag
                VREGOSL: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set VREGO Sense High Interrupt Flag
                VREGOSH: u1,
                ///  Set VREGO Sense Low Interrupt Flag
                VREGOSL: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear VREGO Sense High Interrupt Flag
                VREGOSH: u1,
                ///  Clear VREGO Sense Low Interrupt Flag
                VREGOSL: u1,
                padding: u30,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  VREGO Sense High Interrupt Enable
                VREGOSH: u1,
                ///  VREGO Sense Low Interrupt Enable
                VREGOSL: u1,
                padding: u30,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  USB PHY Pin Enable
                PHYPEN: u1,
                ///  VBUSEN Pin Enable
                VBUSENPEN: u1,
                ///  DMPU Pin Enable
                DMPUPEN: u1,
                padding: u29,
            }),
            reserved245760: [245732]u8,
            ///  OTG Control and Status Register
            GOTGCTL: mmio.Mmio(packed struct(u32) {
                ///  Session Request Success device only
                SESREQSCS: u1,
                ///  Session Request device only
                SESREQ: u1,
                ///  VBUS-Valid Override Enable
                VBVALIDOVEN: u1,
                ///  VBUS Valid Override Value
                VBVALIDOVVAL: u1,
                ///  BValid Override Enable
                BVALIDOVEN: u1,
                ///  Bvalid Override Value
                BVALIDOVVAL: u1,
                ///  AValid Override Enable
                AVALIDOVEN: u1,
                ///  Avalid Override Value
                AVALIDOVVAL: u1,
                ///  Host Negotiation Success device only
                HSTNEGSCS: u1,
                ///  HNP Request device only
                HNPREQ: u1,
                ///  Host Set HNP Enable host only
                HSTSETHNPEN: u1,
                ///  Device HNP Enabled device only
                DEVHNPEN: u1,
                reserved16: u4,
                ///  Connector ID Status host and device
                CONIDSTS: u1,
                ///  Long/Short Debounce Time host only
                DBNCTIME: u1,
                ///  A-Session Valid host only
                ASESVLD: u1,
                ///  B-Session Valid device only
                BSESVLD: u1,
                ///  OTG Version
                OTGVER: u1,
                padding: u11,
            }),
            ///  OTG Interrupt Register
            GOTGINT: mmio.Mmio(packed struct(u32) {
                reserved2: u2,
                ///  Session End Detected host and device
                SESENDDET: u1,
                reserved8: u5,
                ///  Session Request Success Status Change host and device
                SESREQSUCSTSCHNG: u1,
                ///  Host Negotiation Success Status Change host and device
                HSTNEGSUCSTSCHNG: u1,
                reserved17: u7,
                ///  Host Negotiation Detected host and device
                HSTNEGDET: u1,
                ///  A-Device Timeout Change host and device
                ADEVTOUTCHG: u1,
                ///  Debounce Done host only
                DBNCEDONE: u1,
                padding: u12,
            }),
            ///  AHB Configuration Register
            GAHBCFG: mmio.Mmio(packed struct(u32) {
                ///  Global Interrupt Mask host and device
                GLBLINTRMSK: u1,
                ///  Burst Length/Type host and device
                HBSTLEN: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Single transfer.
                        SINGLE = 0x0,
                        ///  Incrementing burst of unspecified length.
                        INCR = 0x1,
                        ///  4-beat incrementing burst.
                        INCR4 = 0x3,
                        ///  8-beat incrementing burst.
                        INCR8 = 0x5,
                        ///  16-beat incrementing burst.
                        INCR16 = 0x7,
                        _,
                    },
                },
                ///  DMA Enable host and device
                DMAEN: u1,
                reserved7: u1,
                ///  Non-Periodic TxFIFO Empty Level host and device
                NPTXFEMPLVL: u1,
                ///  Periodic TxFIFO Empty Level host only
                PTXFEMPLVL: u1,
                reserved21: u12,
                ///  Remote Memory Support
                REMMEMSUPP: u1,
                ///  Notify All DMA Writes
                NOTIALLDMAWRIT: u1,
                padding: u9,
            }),
            ///  USB Configuration Register
            GUSBCFG: mmio.Mmio(packed struct(u32) {
                ///  Timeout Calibration host and device
                TOUTCAL: u3,
                reserved5: u2,
                ///  Full-Speed Serial Interface Select host and device
                FSINTF: u1,
                reserved8: u2,
                ///  SRP-Capable host and device
                SRPCAP: u1,
                ///  HNP-Capable host and device
                HNPCAP: u1,
                ///  USB Turnaround Time device only
                USBTRDTIM: u4,
                reserved22: u8,
                ///  TermSel DLine Pulsing Selection device only
                TERMSELDLPULSE: u1,
                reserved28: u5,
                ///  Tx End Delay device only
                TXENDDELAY: u1,
                ///  Force Host Mode host and device
                FORCEHSTMODE: u1,
                ///  Force Device Mode host and device
                FORCEDEVMODE: u1,
                ///  Corrupt Tx packet host and device
                CORRUPTTXPKT: u1,
            }),
            ///  Reset Register
            GRSTCTL: mmio.Mmio(packed struct(u32) {
                ///  Core Soft Reset host and device
                CSFTRST: u1,
                reserved2: u1,
                ///  Host Frame Counter Reset host only
                FRMCNTRRST: u1,
                reserved4: u1,
                ///  RxFIFO Flush host and device
                RXFFLSH: u1,
                ///  TxFIFO Flush host and device
                TXFFLSH: u1,
                ///  TxFIFO Number host and device
                TXFNUM: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  Host mode: Non-periodic TxFIFO flush. Device: Tx FIFO 0 flush
                        F0 = 0x0,
                        ///  Host mode: Periodic TxFIFO flush. Device: TXFIFO 1 flush.
                        F1 = 0x1,
                        ///  Device mode: TXFIFO 2 flush.
                        F2 = 0x2,
                        ///  Device mode: TXFIFO 3 flush.
                        F3 = 0x3,
                        ///  Device mode: TXFIFO 4 flush.
                        F4 = 0x4,
                        ///  Device mode: TXFIFO 5 flush.
                        F5 = 0x5,
                        ///  Device mode: TXFIFO 6 flush.
                        F6 = 0x6,
                        ///  Flush all the transmit FIFOs in device or host mode.
                        FALL = 0x10,
                        _,
                    },
                },
                reserved30: u19,
                ///  DMA Request Signal host and device
                DMAREQ: u1,
                ///  AHB Master Idle host and device
                AHBIDLE: u1,
            }),
            ///  Interrupt Register
            GINTSTS: mmio.Mmio(packed struct(u32) {
                ///  Current Mode of Operation host and device
                CURMOD: u1,
                ///  Mode Mismatch Interrupt host and device
                MODEMIS: u1,
                ///  OTG Interrupt host and device
                OTGINT: u1,
                ///  Start of Frame host and device
                SOF: u1,
                ///  RxFIFO Non-Empty host and device
                RXFLVL: u1,
                ///  Non-Periodic TxFIFO Empty host only
                NPTXFEMP: u1,
                ///  Global IN Non-periodic NAK Effective device only
                GINNAKEFF: u1,
                ///  Global OUT NAK Effective device only
                GOUTNAKEFF: u1,
                reserved10: u2,
                ///  Early Suspend device only
                ERLYSUSP: u1,
                ///  USB Suspend device only
                USBSUSP: u1,
                ///  USB Reset device only
                USBRST: u1,
                ///  Enumeration Done device only
                ENUMDONE: u1,
                ///  Isochronous OUT Packet Dropped Interrupt device only
                ISOOUTDROP: u1,
                ///  End of Periodic Frame Interrupt
                EOPF: u1,
                reserved18: u2,
                ///  IN Endpoints Interrupt device only
                IEPINT: u1,
                ///  OUT Endpoints Interrupt device only
                OEPINT: u1,
                ///  Incomplete Isochronous IN Transfer device only
                INCOMPISOIN: u1,
                ///  Incomplete Periodic Transfer host and device
                INCOMPLP: u1,
                ///  Data Fetch Suspended device only
                FETSUSP: u1,
                ///  Reset detected Interrupt device only
                RESETDET: u1,
                ///  Host Port Interrupt host only
                PRTINT: u1,
                ///  Host Channels Interrupt host only
                HCHINT: u1,
                ///  Periodic TxFIFO Empty host only
                PTXFEMP: u1,
                reserved28: u1,
                ///  Connector ID Status Change host and device
                CONIDSTSCHNG: u1,
                ///  Disconnect Detected Interrupt host only
                DISCONNINT: u1,
                ///  Session Request/New Session Detected Interrupt host and device
                SESSREQINT: u1,
                ///  Resume/Remote Wakeup Detected Interrupt host and device
                WKUPINT: u1,
            }),
            ///  Interrupt Mask Register
            GINTMSK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Mode Mismatch Interrupt Mask host and device
                MODEMISMSK: u1,
                ///  OTG Interrupt Mask host and device
                OTGINTMSK: u1,
                ///  Start of Frame Mask host and device
                SOFMSK: u1,
                ///  Receive FIFO Non-Empty Mask host and device
                RXFLVLMSK: u1,
                ///  Non-Periodic TxFIFO Empty Mask host only
                NPTXFEMPMSK: u1,
                ///  Global Non-periodic IN NAK Effective Mask device only
                GINNAKEFFMSK: u1,
                ///  Global OUT NAK Effective Mask device only
                GOUTNAKEFFMSK: u1,
                reserved10: u2,
                ///  Early Suspend Mask device only
                ERLYSUSPMSK: u1,
                ///  USB Suspend Mask device only
                USBSUSPMSK: u1,
                ///  USB Reset Mask device only
                USBRSTMSK: u1,
                ///  Enumeration Done Mask device only
                ENUMDONEMSK: u1,
                ///  Isochronous OUT Packet Dropped Interrupt Mask device only
                ISOOUTDROPMSK: u1,
                ///  End of Periodic Frame Interrupt Mask device only
                EOPFMSK: u1,
                reserved18: u2,
                ///  IN Endpoints Interrupt Mask device only
                IEPINTMSK: u1,
                ///  OUT Endpoints Interrupt Mask device only
                OEPINTMSK: u1,
                ///  Incomplete Isochronous IN Transfer Mask device only
                INCOMPISOINMSK: u1,
                ///  Incomplete Periodic Transfer Mask host and device
                INCOMPLPMSK: u1,
                ///  Data Fetch Suspended Mask device only
                FETSUSPMSK: u1,
                ///  Reset detected Interrupt Mask device only
                RESETDETMSK: u1,
                ///  Host Port Interrupt Mask host only
                PRTINTMSK: u1,
                ///  Host Channels Interrupt Mask host only
                HCHINTMSK: u1,
                ///  Periodic TxFIFO Empty Mask host only
                PTXFEMPMSK: u1,
                reserved28: u1,
                ///  Connector ID Status Change Mask host and device
                CONIDSTSCHNGMSK: u1,
                ///  Disconnect Detected Interrupt Mask host and device
                DISCONNINTMSK: u1,
                ///  Session Request/New Session Detected Interrupt Mask host and device
                SESSREQINTMSK: u1,
                ///  Resume/Remote Wakeup Detected Interrupt Mask host and device
                WKUPINTMSK: u1,
            }),
            ///  Receive Status Debug Read Register
            GRXSTSR: mmio.Mmio(packed struct(u32) {
                ///  Channel Number host only / Endpoint Number device only
                CHEPNUM: u4,
                ///  Byte Count (host or device)
                BCNT: u11,
                ///  Data PID (host or device)
                DPID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA1 PID.
                        DATA1 = 0x1,
                        ///  DATA2 PID.
                        DATA2 = 0x2,
                        ///  MDATA PID.
                        MDATA = 0x3,
                    },
                },
                ///  Packet Status (host or device)
                PKTSTS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Device mode: Global OUT NAK (triggers an interrupt).
                        GOUTNAK = 0x1,
                        ///  Host mode: IN data packet received. Device mode: OUT data packet received.
                        PKTRCV = 0x2,
                        ///  Host mode: IN transfer completed (triggers an interrupt). Device mode: OUT transfer completed (triggers an interrupt).
                        XFERCOMPL = 0x3,
                        ///  Device mode: SETUP transaction completed (triggers an interrupt).
                        SETUPCOMPL = 0x4,
                        ///  Host mode: Data toggle error (triggers an interrupt).
                        TGLERR = 0x5,
                        ///  Device mode: SETUP data packet received.
                        SETUPRCV = 0x6,
                        ///  Host mode: Channel halted (triggers an interrupt).
                        CHLT = 0x7,
                        _,
                    },
                },
                ///  Frame Number device only
                FN: u4,
                padding: u7,
            }),
            ///  Receive Status Read and Pop Register
            GRXSTSP: mmio.Mmio(packed struct(u32) {
                ///  Channel Number host only / Endpoint Number device only
                CHEPNUM: u4,
                ///  Byte Count (host or device)
                BCNT: u11,
                ///  Data PID (host or device)
                DPID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA1 PID.
                        DATA1 = 0x1,
                        ///  DATA2 PID.
                        DATA2 = 0x2,
                        ///  MDATA PID.
                        MDATA = 0x3,
                    },
                },
                ///  Packet Status (host or device)
                PKTSTS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Device mode: Global OUT NAK (triggers an interrupt).
                        GOUTNAK = 0x1,
                        ///  Host mode: IN data packet received. Device mode: OUT data packet received.
                        PKTRCV = 0x2,
                        ///  Host mode: IN transfer completed (triggers an interrupt). Device mode: OUT transfer completed (triggers an interrupt).
                        XFERCOMPL = 0x3,
                        ///  Device mode: SETUP transaction completed (triggers an interrupt).
                        SETUPCOMPL = 0x4,
                        ///  Host mode: Data toggle error (triggers an interrupt).
                        TGLERR = 0x5,
                        ///  Device mode: SETUP data packet received.
                        SETUPRCV = 0x6,
                        ///  Host mode: Channel halted (triggers an interrupt).
                        CHLT = 0x7,
                        _,
                    },
                },
                ///  Frame Number device only
                FN: u4,
                padding: u7,
            }),
            ///  Receive FIFO Size Register
            GRXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  RxFIFO Depth
                RXFDEP: u10,
                padding: u22,
            }),
            ///  Non-periodic Transmit FIFO Size Register
            GNPTXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  Non-periodic Transmit RAM Start Address host only
                NPTXFSTADDR: u10,
                reserved16: u6,
                ///  Non-periodic TxFIFO Depth host only / IN Endpoint TxFIFO 0 Depth device only
                NPTXFINEPTXF0DEP: u16,
            }),
            ///  Non-periodic Transmit FIFO/Queue Status Register
            GNPTXSTS: mmio.Mmio(packed struct(u32) {
                ///  Non-periodic TxFIFO Space Available
                NPTXFSPCAVAIL: u16,
                ///  Non-periodic Transmit Request Queue Space Available
                NPTXQSPCAVAIL: u8,
                ///  Top of the Non-periodic Transmit Request Queue
                NPTXQTOP: u7,
                padding: u1,
            }),
            reserved245852: [44]u8,
            ///  Global DFIFO Configuration Register
            GDFIFOCFG: mmio.Mmio(packed struct(u32) {
                ///  DFIFO Config
                GDFIFOCFG: u16,
                ///  Endpoint Info Base Address
                EPINFOBASEADDR: u16,
            }),
            reserved246016: [160]u8,
            ///  Host Periodic Transmit FIFO Size Register
            HPTXFSIZ: mmio.Mmio(packed struct(u32) {
                ///  Host Periodic TxFIFO Start Address
                PTXFSTADDR: u11,
                reserved16: u5,
                ///  Host Periodic TxFIFO Depth
                PTXFSIZE: u10,
                padding: u6,
            }),
            ///  Device IN Endpoint Transmit FIFO 1 Size Register
            DIEPTXF1: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint FIFO 1 Transmit RAM Start Address
                INEPNTXFSTADDR: u11,
                reserved16: u5,
                ///  IN Endpoint TxFIFO Depth
                INEPNTXFDEP: u10,
                padding: u6,
            }),
            ///  Device IN Endpoint Transmit FIFO 2 Size Register
            DIEPTXF2: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint FIFO 2 Transmit RAM Start Address
                INEPNTXFSTADDR: u11,
                reserved16: u5,
                ///  IN Endpoint TxFIFO Depth
                INEPNTXFDEP: u10,
                padding: u6,
            }),
            ///  Device IN Endpoint Transmit FIFO 3 Size Register
            DIEPTXF3: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint FIFO 3 Transmit RAM Start Address
                INEPNTXFSTADDR: u12,
                reserved16: u4,
                ///  IN Endpoint TxFIFO Depth
                INEPNTXFDEP: u10,
                padding: u6,
            }),
            ///  Device IN Endpoint Transmit FIFO 4 Size Register
            DIEPTXF4: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint FIFO 4 Transmit RAM Start Address
                INEPNTXFSTADDR: u12,
                reserved16: u4,
                ///  IN Endpoint TxFIFO Depth
                INEPNTXFDEP: u10,
                padding: u6,
            }),
            ///  Device IN Endpoint Transmit FIFO 5 Size Register
            DIEPTXF5: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint FIFO 5 Transmit RAM Start Address
                INEPNTXFSTADDR: u12,
                reserved16: u4,
                ///  IN Endpoint TxFIFO Depth
                INEPNTXFDEP: u10,
                padding: u6,
            }),
            ///  Device IN Endpoint Transmit FIFO 6 Size Register
            DIEPTXF6: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint FIFO 6 Transmit RAM Start Address
                INEPNTXFSTADDR: u12,
                reserved16: u4,
                ///  IN Endpoint TxFIFO Depth
                INEPNTXFDEP: u10,
                padding: u6,
            }),
            reserved246784: [740]u8,
            ///  Host Configuration Register
            HCFG: mmio.Mmio(packed struct(u32) {
                ///  FS/LS PHY Clock Select
                FSLSPCLKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Internal PHY clock is running at 48 MHz (undivided).
                        DIV1 = 0x1,
                        ///  Internal PHY clock is running at 6 MHz (48 MHz divided by 8).
                        DIV8 = 0x2,
                        _,
                    },
                },
                ///  FS- and LS-Only Support
                FSLSSUPP: u1,
                reserved7: u4,
                ///  Enable 32 KHz Suspend mode
                ENA32KHZS: u1,
                ///  Resume Validation Period
                RESVALID: u8,
                reserved31: u15,
                ///  Mode Change Time
                MODECHTIMEN: u1,
            }),
            ///  Host Frame Interval Register
            HFIR: mmio.Mmio(packed struct(u32) {
                ///  Frame Interval
                FRINT: u16,
                ///  Reload Control
                HFIRRLDCTRL: u1,
                padding: u15,
            }),
            ///  Host Frame Number/Frame Time Remaining Register
            HFNUM: mmio.Mmio(packed struct(u32) {
                ///  Frame Number
                FRNUM: u16,
                ///  Frame Time Remaining
                FRREM: u16,
            }),
            reserved246800: [4]u8,
            ///  Host Periodic Transmit FIFO/Queue Status Register
            HPTXSTS: mmio.Mmio(packed struct(u32) {
                ///  Periodic Transmit Data FIFO Space Available
                PTXFSPCAVAIL: u16,
                ///  Periodic Transmit Request Queue Space Available
                PTXQSPCAVAIL: u8,
                ///  Top of the Periodic Transmit Request Queue
                PTXQTOP: u8,
            }),
            ///  Host All Channels Interrupt Register
            HAINT: mmio.Mmio(packed struct(u32) {
                ///  Channel Interrupt for channel 0 - 13.
                HAINT: u14,
                padding: u18,
            }),
            ///  Host All Channels Interrupt Mask Register
            HAINTMSK: mmio.Mmio(packed struct(u32) {
                ///  Channel Interrupt Mask for channel 0 - 13
                HAINTMSK: u14,
                padding: u18,
            }),
            reserved246848: [36]u8,
            ///  Host Port Control and Status Register
            HPRT: mmio.Mmio(packed struct(u32) {
                ///  Port Connect Status
                PRTCONNSTS: u1,
                ///  Port Connect Detected
                PRTCONNDET: u1,
                ///  Port Enable
                PRTENA: u1,
                ///  Port Enable/Disable Change
                PRTENCHNG: u1,
                ///  Port Overcurrent Active
                PRTOVRCURRACT: u1,
                ///  Port Overcurrent Change
                PRTOVRCURRCHNG: u1,
                ///  Port Resume
                PRTRES: u1,
                ///  Port Suspend
                PRTSUSP: u1,
                ///  Port Reset
                PRTRST: u1,
                reserved10: u1,
                ///  Port Line Status
                PRTLNSTS: u2,
                ///  Port Power
                PRTPWR: u1,
                ///  Port Test Control
                PRTTSTCTL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Test mode disabled.
                        DISABLE = 0x0,
                        ///  Test_J mode.
                        J = 0x1,
                        ///  Test_K mode.
                        K = 0x2,
                        ///  Test_SE0_NAK mode.
                        SE0NAK = 0x3,
                        ///  Test_Packet mode.
                        PACKET = 0x4,
                        ///  Test_Force_Enable.
                        FORCE = 0x5,
                        _,
                    },
                },
                ///  Port Speed
                PRTSPD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  High speed.
                        HS = 0x0,
                        ///  Full speed.
                        FS = 0x1,
                        ///  Low speed.
                        LS = 0x2,
                        _,
                    },
                },
                padding: u13,
            }),
            reserved247040: [188]u8,
            ///  Host Channel x Characteristics Register
            HC0_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247048: [4]u8,
            ///  Host Channel x Interrupt Register
            HC0_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC0_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC0_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC0_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247072: [8]u8,
            ///  Host Channel x Characteristics Register
            HC1_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247080: [4]u8,
            ///  Host Channel x Interrupt Register
            HC1_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC1_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC1_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC1_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247104: [8]u8,
            ///  Host Channel x Characteristics Register
            HC2_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247112: [4]u8,
            ///  Host Channel x Interrupt Register
            HC2_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC2_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC2_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC2_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247136: [8]u8,
            ///  Host Channel x Characteristics Register
            HC3_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247144: [4]u8,
            ///  Host Channel x Interrupt Register
            HC3_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC3_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC3_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC3_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247168: [8]u8,
            ///  Host Channel x Characteristics Register
            HC4_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247176: [4]u8,
            ///  Host Channel x Interrupt Register
            HC4_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC4_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC4_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC4_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247200: [8]u8,
            ///  Host Channel x Characteristics Register
            HC5_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247208: [4]u8,
            ///  Host Channel x Interrupt Register
            HC5_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC5_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC5_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC5_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247232: [8]u8,
            ///  Host Channel x Characteristics Register
            HC6_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247240: [4]u8,
            ///  Host Channel x Interrupt Register
            HC6_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC6_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC6_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC6_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247264: [8]u8,
            ///  Host Channel x Characteristics Register
            HC7_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247272: [4]u8,
            ///  Host Channel x Interrupt Register
            HC7_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC7_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC7_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC7_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247296: [8]u8,
            ///  Host Channel x Characteristics Register
            HC8_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247304: [4]u8,
            ///  Host Channel x Interrupt Register
            HC8_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC8_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC8_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC8_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247328: [8]u8,
            ///  Host Channel x Characteristics Register
            HC9_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247336: [4]u8,
            ///  Host Channel x Interrupt Register
            HC9_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC9_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC9_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC9_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247360: [8]u8,
            ///  Host Channel x Characteristics Register
            HC10_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247368: [4]u8,
            ///  Host Channel x Interrupt Register
            HC10_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC10_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC10_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC10_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247392: [8]u8,
            ///  Host Channel x Characteristics Register
            HC11_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247400: [4]u8,
            ///  Host Channel x Interrupt Register
            HC11_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC11_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC11_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC11_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247424: [8]u8,
            ///  Host Channel x Characteristics Register
            HC12_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247432: [4]u8,
            ///  Host Channel x Interrupt Register
            HC12_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC12_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC12_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC12_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247456: [8]u8,
            ///  Host Channel x Characteristics Register
            HC13_CHAR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                ///  Endpoint Number
                EPNUM: u4,
                ///  Endpoint Direction
                EPDIR: u1,
                reserved17: u1,
                ///  Low-Speed Device
                LSPDDEV: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous endpoint.
                        ISO = 0x1,
                        ///  Bulk endpoint.
                        BULK = 0x2,
                        ///  Interrupt endpoint.
                        INT = 0x3,
                    },
                },
                ///  Multi Count
                MC: u2,
                ///  Device Address
                DEVADDR: u7,
                ///  Odd Frame
                ODDFRM: u1,
                ///  Channel Disable
                CHDIS: u1,
                ///  Channel Enable
                CHENA: u1,
            }),
            reserved247464: [4]u8,
            ///  Host Channel x Interrupt Register
            HC13_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed
                XFERCOMPL: u1,
                ///  Channel Halted
                CHHLTD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  STALL Response Received Interrupt
                STALL: u1,
                ///  NAK Response Received Interrupt
                NAK: u1,
                ///  ACK Response Received/Transmitted Interrupt
                ACK: u1,
                reserved7: u1,
                ///  Transaction Error
                XACTERR: u1,
                ///  Babble Error
                BBLERR: u1,
                ///  Frame Overrun
                FRMOVRUN: u1,
                ///  Data Toggle Error
                DATATGLERR: u1,
                padding: u21,
            }),
            ///  Host Channel x Interrupt Mask Register
            HC13_INTMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Mask
                XFERCOMPLMSK: u1,
                ///  Channel Halted Mask
                CHHLTDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  STALL Response Received Interrupt Mask
                STALLMSK: u1,
                ///  NAK Response Received Interrupt Mask
                NAKMSK: u1,
                ///  ACK Response Received/Transmitted Interrupt Mask
                ACKMSK: u1,
                reserved7: u1,
                ///  Transaction Error Mask
                XACTERRMSK: u1,
                ///  Babble Error Mask
                BBLERRMSK: u1,
                ///  Frame Overrun Mask
                FRMOVRUNMSK: u1,
                ///  Data Toggle Error Mask
                DATATGLERRMSK: u1,
                padding: u21,
            }),
            ///  Host Channel x Transfer Size Register
            HC13_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Packet ID
                PID: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID.
                        DATA2 = 0x1,
                        ///  DATA1 PID.
                        DATA1 = 0x2,
                        ///  MDATA (non-control) / SETUP (control) PID.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Host Channel x DMA Address Register
            HC13_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved247808: [328]u8,
            ///  Device Configuration Register
            DCFG: mmio.Mmio(packed struct(u32) {
                ///  Device Speed
                DEVSPD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed (PHY clock is 6 MHz). If you select 6 MHz LS mode, you must do a soft reset.
                        LS = 0x2,
                        ///  Full speed (PHY clock is 48 MHz).
                        FS = 0x3,
                        _,
                    },
                },
                ///  Non-Zero-Length Status OUT Handshake
                NZSTSOUTHSHK: u1,
                ///  Enable 32 KHz Suspend mode
                ENA32KHZSUSP: u1,
                ///  Device Address
                DEVADDR: u7,
                ///  Periodic Frame Interval
                PERFRINT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  80% of the frame interval.
                        @"80PCNT" = 0x0,
                        ///  85% of the frame interval.
                        @"85PCNT" = 0x1,
                        ///  90% of the frame interval.
                        @"90PCNT" = 0x2,
                        ///  95% of the frame interval.
                        @"95PCNT" = 0x3,
                    },
                },
                reserved26: u13,
                ///  Resume Validation Period
                RESVALID: u6,
            }),
            ///  Device Control Register
            DCTL: mmio.Mmio(packed struct(u32) {
                ///  Remote Wakeup Signaling
                RMTWKUPSIG: u1,
                ///  Soft Disconnect
                SFTDISCON: u1,
                ///  Global Non-periodic IN NAK Status
                GNPINNAKSTS: u1,
                ///  Global OUT NAK Status
                GOUTNAKSTS: u1,
                ///  Test Control
                TSTCTL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Test mode disabled.
                        DISABLE = 0x0,
                        ///  Test_J mode.
                        J = 0x1,
                        ///  Test_K mode.
                        K = 0x2,
                        ///  Test_SE0_NAK mode.
                        SE0NAK = 0x3,
                        ///  Test_Packet mode.
                        PACKET = 0x4,
                        ///  Test_Force_Enable.
                        FORCE = 0x5,
                        _,
                    },
                },
                ///  Set Global Non-periodic IN NAK
                SGNPINNAK: u1,
                ///  Clear Global Non-periodic IN NAK
                CGNPINNAK: u1,
                ///  Set Global OUT NAK
                SGOUTNAK: u1,
                ///  Clear Global OUT NAK
                CGOUTNAK: u1,
                ///  Power-On Programming Done
                PWRONPRGDONE: u1,
                reserved15: u3,
                ///  Ignore Frame number For Isochronous End points
                IGNRFRMNUM: u1,
                ///  NAK on Babble Error
                NAKONBBLE: u1,
                padding: u15,
            }),
            ///  Device Status Register
            DSTS: mmio.Mmio(packed struct(u32) {
                ///  Suspend Status
                SUSPSTS: u1,
                ///  Enumerated Speed
                ENUMSPD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low speed (PHY clock is running at 6 MHz).
                        LS = 0x2,
                        ///  Full speed (PHY clock is running at 48 MHz).
                        FS = 0x3,
                        _,
                    },
                },
                ///  Erratic Error
                ERRTICERR: u1,
                reserved8: u4,
                ///  Frame Number of the Received SOF
                SOFFN: u14,
                padding: u10,
            }),
            reserved247824: [4]u8,
            ///  Device IN Endpoint Common Interrupt Mask Register
            DIEPMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt Mask
                XFERCOMPLMSK: u1,
                ///  Endpoint Disabled Interrupt Mask
                EPDISBLDMSK: u1,
                ///  AHB Error Mask
                AHBERRMSK: u1,
                ///  Timeout Condition Mask
                TIMEOUTMSK: u1,
                ///  IN Token Received When TxFIFO Empty Mask
                INTKNTXFEMPMSK: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective Mask
                INEPNAKEFFMSK: u1,
                reserved8: u1,
                ///  Fifo Underrun Mask
                TXFIFOUNDRNMSK: u1,
                reserved13: u4,
                ///  NAK interrupt Mask
                NAKMSK: u1,
                padding: u18,
            }),
            ///  Device OUT Endpoint Common Interrupt Mask Register
            DOEPMSK: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt Mask
                XFERCOMPLMSK: u1,
                ///  Endpoint Disabled Interrupt Mask
                EPDISBLDMSK: u1,
                ///  AHB Error
                AHBERRMSK: u1,
                ///  SETUP Phase Done Mask
                SETUPMSK: u1,
                ///  OUT Token Received when Endpoint Disabled Mask
                OUTTKNEPDISMSK: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received Mask
                BACK2BACKSETUP: u1,
                reserved8: u1,
                ///  OUT Packet Error Mask
                OUTPKTERRMSK: u1,
                reserved12: u3,
                ///  Babble Error interrupt Mask
                BBLEERRMSK: u1,
                ///  NAK interrupt Mask
                NAKMSK: u1,
                padding: u18,
            }),
            ///  Device All Endpoints Interrupt Register
            DAINT: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint 0 Interrupt Bit
                INEPINT0: u1,
                ///  IN Endpoint 1 Interrupt Bit
                INEPINT1: u1,
                ///  IN Endpoint 2 Interrupt Bit
                INEPINT2: u1,
                ///  IN Endpoint 3 Interrupt Bit
                INEPINT3: u1,
                ///  IN Endpoint 4 Interrupt Bit
                INEPINT4: u1,
                ///  IN Endpoint 5 Interrupt Bit
                INEPINT5: u1,
                ///  IN Endpoint 6 Interrupt Bit
                INEPINT6: u1,
                reserved16: u9,
                ///  OUT Endpoint 0 Interrupt Bit
                OUTEPINT0: u1,
                ///  OUT Endpoint 1 Interrupt Bit
                OUTEPINT1: u1,
                ///  OUT Endpoint 2 Interrupt Bit
                OUTEPINT2: u1,
                ///  OUT Endpoint 3 Interrupt Bit
                OUTEPINT3: u1,
                ///  OUT Endpoint 4 Interrupt Bit
                OUTEPINT4: u1,
                ///  OUT Endpoint 5 Interrupt Bit
                OUTEPINT5: u1,
                ///  OUT Endpoint 6 Interrupt Bit
                OUTEPINT6: u1,
                padding: u9,
            }),
            ///  Device All Endpoints Interrupt Mask Register
            DAINTMSK: mmio.Mmio(packed struct(u32) {
                ///  IN Endpoint 0 Interrupt mask Bit
                INEPMSK0: u1,
                ///  IN Endpoint 1 Interrupt mask Bit
                INEPMSK1: u1,
                ///  IN Endpoint 2 Interrupt mask Bit
                INEPMSK2: u1,
                ///  IN Endpoint 3 Interrupt mask Bit
                INEPMSK3: u1,
                ///  IN Endpoint 4 Interrupt mask Bit
                INEPMSK4: u1,
                ///  IN Endpoint 5 Interrupt mask Bit
                INEPMSK5: u1,
                ///  IN Endpoint 6 Interrupt mask Bit
                INEPMSK6: u1,
                reserved16: u9,
                ///  OUT Endpoint 0 Interrupt mask Bit
                OUTEPMSK0: u1,
                ///  OUT Endpoint 1 Interrupt mask Bit
                OUTEPMSK1: u1,
                ///  OUT Endpoint 2 Interrupt mask Bit
                OUTEPMSK2: u1,
                ///  OUT Endpoint 3 Interrupt mask Bit
                OUTEPMSK3: u1,
                ///  OUT Endpoint 4 Interrupt mask Bit
                OUTEPMSK4: u1,
                ///  OUT Endpoint 5 Interrupt mask Bit
                OUTEPMSK5: u1,
                ///  OUT Endpoint 6 Interrupt mask Bit
                OUTEPMSK6: u1,
                padding: u9,
            }),
            reserved247848: [8]u8,
            ///  Device VBUS Discharge Time Register
            DVBUSDIS: mmio.Mmio(packed struct(u32) {
                ///  Device VBUS Discharge Time
                DVBUSDIS: u16,
                padding: u16,
            }),
            ///  Device VBUS Pulsing Time Register
            DVBUSPULSE: mmio.Mmio(packed struct(u32) {
                ///  Device VBUS Pulsing Time
                DVBUSPULSE: u12,
                padding: u20,
            }),
            reserved247860: [4]u8,
            ///  Device IN Endpoint FIFO Empty Interrupt Mask Register
            DIEPEMPMSK: mmio.Mmio(packed struct(u32) {
                ///  IN EP Tx FIFO Empty Interrupt Mask Bits
                DIEPEMPMSK: u16,
                padding: u16,
            }),
            reserved248064: [200]u8,
            ///  Device IN Endpoint 0 Control Register
            DIEP0CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  64 bytes.
                        @"64B" = 0x0,
                        ///  32 bytes.
                        @"32B" = 0x1,
                        ///  16 bytes.
                        @"16B" = 0x2,
                        ///  8 bytes.
                        @"8B" = 0x3,
                    },
                },
                reserved15: u13,
                ///  USB Active Endpoint
                USBACTEP: u1,
                reserved17: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: u2,
                reserved21: u1,
                ///  Handshake
                STALL: u1,
                ///  TxFIFO Number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                reserved30: u2,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248072: [4]u8,
            ///  Device IN Endpoint 0 Interrupt Register
            DIEP0INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Timeout Condition
                TIMEOUT: u1,
                ///  IN Token Received When TxFIFO is Empty
                INTKNTXFEMP: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective
                INEPNAKEFF: u1,
                ///  Transmit FIFO Empty
                TXFEMP: u1,
                reserved11: u3,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248080: [4]u8,
            ///  Device IN Endpoint 0 Transfer Size Register
            DIEP0TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u7,
                reserved19: u12,
                ///  Packet Count
                PKTCNT: u2,
                padding: u11,
            }),
            ///  Device IN Endpoint 0 DMA Address Register
            DIEP0DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DIEP0DMAADDR: u32,
            }),
            ///  Device IN Endpoint 0 Transmit FIFO Status Register
            DIEP0TXFSTS: mmio.Mmio(packed struct(u32) {
                ///  TxFIFO Space Available
                SPCAVAIL: u16,
                padding: u16,
            }),
            reserved248096: [4]u8,
            ///  Device IN Endpoint x+1 Control Register
            DIEP0_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even or Odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                reserved21: u1,
                ///  Handshake
                STALL: u1,
                ///  TxFIFO Number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248104: [4]u8,
            ///  Device IN Endpoint x+1 Interrupt Register
            DIEP0_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Timeout Condition
                TIMEOUT: u1,
                ///  IN Token Received When TxFIFO is Empty
                INTKNTXFEMP: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective
                INEPNAKEFF: u1,
                ///  Transmit FIFO Empty
                TXFEMP: u1,
                reserved11: u3,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248112: [4]u8,
            ///  Device IN Endpoint x+1 Transfer Size Register
            DIEP0_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Multi Count
                MC: u2,
                padding: u1,
            }),
            ///  Device IN Endpoint x+1 DMA Address Register
            DIEP0_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            ///  Device IN Endpoint x+1 Transmit FIFO Status Register
            DIEP0_TXFSTS: mmio.Mmio(packed struct(u32) {
                ///  TxFIFO Space Available
                SPCAVAIL: u16,
                padding: u16,
            }),
            reserved248128: [4]u8,
            ///  Device IN Endpoint x+1 Control Register
            DIEP1_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even or Odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                reserved21: u1,
                ///  Handshake
                STALL: u1,
                ///  TxFIFO Number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248136: [4]u8,
            ///  Device IN Endpoint x+1 Interrupt Register
            DIEP1_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Timeout Condition
                TIMEOUT: u1,
                ///  IN Token Received When TxFIFO is Empty
                INTKNTXFEMP: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective
                INEPNAKEFF: u1,
                ///  Transmit FIFO Empty
                TXFEMP: u1,
                reserved11: u3,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248144: [4]u8,
            ///  Device IN Endpoint x+1 Transfer Size Register
            DIEP1_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Multi Count
                MC: u2,
                padding: u1,
            }),
            ///  Device IN Endpoint x+1 DMA Address Register
            DIEP1_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            ///  Device IN Endpoint x+1 Transmit FIFO Status Register
            DIEP1_TXFSTS: mmio.Mmio(packed struct(u32) {
                ///  TxFIFO Space Available
                SPCAVAIL: u16,
                padding: u16,
            }),
            reserved248160: [4]u8,
            ///  Device IN Endpoint x+1 Control Register
            DIEP2_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even or Odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                reserved21: u1,
                ///  Handshake
                STALL: u1,
                ///  TxFIFO Number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248168: [4]u8,
            ///  Device IN Endpoint x+1 Interrupt Register
            DIEP2_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Timeout Condition
                TIMEOUT: u1,
                ///  IN Token Received When TxFIFO is Empty
                INTKNTXFEMP: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective
                INEPNAKEFF: u1,
                ///  Transmit FIFO Empty
                TXFEMP: u1,
                reserved11: u3,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248176: [4]u8,
            ///  Device IN Endpoint x+1 Transfer Size Register
            DIEP2_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Multi Count
                MC: u2,
                padding: u1,
            }),
            ///  Device IN Endpoint x+1 DMA Address Register
            DIEP2_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            ///  Device IN Endpoint x+1 Transmit FIFO Status Register
            DIEP2_TXFSTS: mmio.Mmio(packed struct(u32) {
                ///  TxFIFO Space Available
                SPCAVAIL: u16,
                padding: u16,
            }),
            reserved248192: [4]u8,
            ///  Device IN Endpoint x+1 Control Register
            DIEP3_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even or Odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                reserved21: u1,
                ///  Handshake
                STALL: u1,
                ///  TxFIFO Number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248200: [4]u8,
            ///  Device IN Endpoint x+1 Interrupt Register
            DIEP3_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Timeout Condition
                TIMEOUT: u1,
                ///  IN Token Received When TxFIFO is Empty
                INTKNTXFEMP: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective
                INEPNAKEFF: u1,
                ///  Transmit FIFO Empty
                TXFEMP: u1,
                reserved11: u3,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248208: [4]u8,
            ///  Device IN Endpoint x+1 Transfer Size Register
            DIEP3_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Multi Count
                MC: u2,
                padding: u1,
            }),
            ///  Device IN Endpoint x+1 DMA Address Register
            DIEP3_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            ///  Device IN Endpoint x+1 Transmit FIFO Status Register
            DIEP3_TXFSTS: mmio.Mmio(packed struct(u32) {
                ///  TxFIFO Space Available
                SPCAVAIL: u16,
                padding: u16,
            }),
            reserved248224: [4]u8,
            ///  Device IN Endpoint x+1 Control Register
            DIEP4_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even or Odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                reserved21: u1,
                ///  Handshake
                STALL: u1,
                ///  TxFIFO Number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248232: [4]u8,
            ///  Device IN Endpoint x+1 Interrupt Register
            DIEP4_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Timeout Condition
                TIMEOUT: u1,
                ///  IN Token Received When TxFIFO is Empty
                INTKNTXFEMP: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective
                INEPNAKEFF: u1,
                ///  Transmit FIFO Empty
                TXFEMP: u1,
                reserved11: u3,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248240: [4]u8,
            ///  Device IN Endpoint x+1 Transfer Size Register
            DIEP4_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Multi Count
                MC: u2,
                padding: u1,
            }),
            ///  Device IN Endpoint x+1 DMA Address Register
            DIEP4_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            ///  Device IN Endpoint x+1 Transmit FIFO Status Register
            DIEP4_TXFSTS: mmio.Mmio(packed struct(u32) {
                ///  TxFIFO Space Available
                SPCAVAIL: u16,
                padding: u16,
            }),
            reserved248256: [4]u8,
            ///  Device IN Endpoint x+1 Control Register
            DIEP5_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even or Odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                reserved21: u1,
                ///  Handshake
                STALL: u1,
                ///  TxFIFO Number
                TXFNUM: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248264: [4]u8,
            ///  Device IN Endpoint x+1 Interrupt Register
            DIEP5_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Timeout Condition
                TIMEOUT: u1,
                ///  IN Token Received When TxFIFO is Empty
                INTKNTXFEMP: u1,
                reserved6: u1,
                ///  IN Endpoint NAK Effective
                INEPNAKEFF: u1,
                ///  Transmit FIFO Empty
                TXFEMP: u1,
                reserved11: u3,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248272: [4]u8,
            ///  Device IN Endpoint x+1 Transfer Size Register
            DIEP5_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Multi Count
                MC: u2,
                padding: u1,
            }),
            ///  Device IN Endpoint x+1 DMA Address Register
            DIEP5_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            ///  Device IN Endpoint x+1 Transmit FIFO Status Register
            DIEP5_TXFSTS: mmio.Mmio(packed struct(u32) {
                ///  TxFIFO Space Available
                SPCAVAIL: u16,
                padding: u16,
            }),
            reserved248576: [292]u8,
            ///  Device OUT Endpoint 0 Control Register
            DOEP0CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  64 bytes.
                        @"64B" = 0x0,
                        ///  32 bytes.
                        @"32B" = 0x1,
                        ///  16 bytes.
                        @"16B" = 0x2,
                        ///  8 bytes.
                        @"8B" = 0x3,
                    },
                },
                reserved15: u13,
                ///  USB Active Endpoint
                USBACTEP: u1,
                reserved17: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: u2,
                ///  Snoop Mode
                SNP: u1,
                ///  Handshake
                STALL: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                reserved30: u2,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248584: [4]u8,
            ///  Device OUT Endpoint 0 Interrupt Register
            DOEP0INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Setup Phase Done
                SETUP: u1,
                ///  OUT Token Received When Endpoint Disabled
                OUTTKNEPDIS: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received
                BACK2BACKSETUP: u1,
                reserved11: u4,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  NAK Interrupt
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248592: [4]u8,
            ///  Device OUT Endpoint 0 Transfer Size Register
            DOEP0TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u7,
                reserved19: u12,
                ///  Packet Count
                PKTCNT: u1,
                reserved29: u9,
                ///  SETUP Packet Count
                SUPCNT: u2,
                padding: u1,
            }),
            ///  Device OUT Endpoint 0 DMA Address Register
            DOEP0DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DOEP0DMAADDR: u32,
            }),
            reserved248608: [8]u8,
            ///  Device OUT Endpoint x+1 Control Register
            DOEP0_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even-odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                ///  Snoop Mode
                SNP: u1,
                ///  STALL Handshake
                STALL: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248616: [4]u8,
            ///  Device OUT Endpoint x+1 Interrupt Register
            DOEP0_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Setup Phase Done
                SETUP: u1,
                ///  OUT Token Received When Endpoint Disabled
                OUTTKNEPDIS: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received
                BACK2BACKSETUP: u1,
                reserved11: u4,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  Babble Error
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248624: [4]u8,
            ///  Device OUT Endpoint x+1 Transfer Size Register
            DOEP0_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Receive Data PID / SETUP Packet Count
                RXDPIDSUPCNT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID / 1 Packet.
                        DATA2 = 0x1,
                        ///  DATA1 PID / 2 Packets.
                        DATA1 = 0x2,
                        ///  MDATA PID / 3 Packets.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Device OUT Endpoint x+1 DMA Address Register
            DOEP0_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved248640: [8]u8,
            ///  Device OUT Endpoint x+1 Control Register
            DOEP1_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even-odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                ///  Snoop Mode
                SNP: u1,
                ///  STALL Handshake
                STALL: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248648: [4]u8,
            ///  Device OUT Endpoint x+1 Interrupt Register
            DOEP1_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Setup Phase Done
                SETUP: u1,
                ///  OUT Token Received When Endpoint Disabled
                OUTTKNEPDIS: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received
                BACK2BACKSETUP: u1,
                reserved11: u4,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  Babble Error
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248656: [4]u8,
            ///  Device OUT Endpoint x+1 Transfer Size Register
            DOEP1_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Receive Data PID / SETUP Packet Count
                RXDPIDSUPCNT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID / 1 Packet.
                        DATA2 = 0x1,
                        ///  DATA1 PID / 2 Packets.
                        DATA1 = 0x2,
                        ///  MDATA PID / 3 Packets.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Device OUT Endpoint x+1 DMA Address Register
            DOEP1_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved248672: [8]u8,
            ///  Device OUT Endpoint x+1 Control Register
            DOEP2_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even-odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                ///  Snoop Mode
                SNP: u1,
                ///  STALL Handshake
                STALL: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248680: [4]u8,
            ///  Device OUT Endpoint x+1 Interrupt Register
            DOEP2_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Setup Phase Done
                SETUP: u1,
                ///  OUT Token Received When Endpoint Disabled
                OUTTKNEPDIS: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received
                BACK2BACKSETUP: u1,
                reserved11: u4,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  Babble Error
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248688: [4]u8,
            ///  Device OUT Endpoint x+1 Transfer Size Register
            DOEP2_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Receive Data PID / SETUP Packet Count
                RXDPIDSUPCNT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID / 1 Packet.
                        DATA2 = 0x1,
                        ///  DATA1 PID / 2 Packets.
                        DATA1 = 0x2,
                        ///  MDATA PID / 3 Packets.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Device OUT Endpoint x+1 DMA Address Register
            DOEP2_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved248704: [8]u8,
            ///  Device OUT Endpoint x+1 Control Register
            DOEP3_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even-odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                ///  Snoop Mode
                SNP: u1,
                ///  STALL Handshake
                STALL: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248712: [4]u8,
            ///  Device OUT Endpoint x+1 Interrupt Register
            DOEP3_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Setup Phase Done
                SETUP: u1,
                ///  OUT Token Received When Endpoint Disabled
                OUTTKNEPDIS: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received
                BACK2BACKSETUP: u1,
                reserved11: u4,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  Babble Error
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248720: [4]u8,
            ///  Device OUT Endpoint x+1 Transfer Size Register
            DOEP3_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Receive Data PID / SETUP Packet Count
                RXDPIDSUPCNT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID / 1 Packet.
                        DATA2 = 0x1,
                        ///  DATA1 PID / 2 Packets.
                        DATA1 = 0x2,
                        ///  MDATA PID / 3 Packets.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Device OUT Endpoint x+1 DMA Address Register
            DOEP3_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved248736: [8]u8,
            ///  Device OUT Endpoint x+1 Control Register
            DOEP4_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even-odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                ///  Snoop Mode
                SNP: u1,
                ///  STALL Handshake
                STALL: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248744: [4]u8,
            ///  Device OUT Endpoint x+1 Interrupt Register
            DOEP4_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Setup Phase Done
                SETUP: u1,
                ///  OUT Token Received When Endpoint Disabled
                OUTTKNEPDIS: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received
                BACK2BACKSETUP: u1,
                reserved11: u4,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  Babble Error
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248752: [4]u8,
            ///  Device OUT Endpoint x+1 Transfer Size Register
            DOEP4_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Receive Data PID / SETUP Packet Count
                RXDPIDSUPCNT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID / 1 Packet.
                        DATA2 = 0x1,
                        ///  DATA1 PID / 2 Packets.
                        DATA1 = 0x2,
                        ///  MDATA PID / 3 Packets.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Device OUT Endpoint x+1 DMA Address Register
            DOEP4_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved248768: [8]u8,
            ///  Device OUT Endpoint x+1 Control Register
            DOEP5_CTL: mmio.Mmio(packed struct(u32) {
                ///  Maximum Packet Size
                MPS: u11,
                reserved15: u4,
                ///  USB Active Endpoint
                USBACTEP: u1,
                ///  Endpoint Data PID / Even-odd Frame
                DPIDEOF: u1,
                ///  NAK Status
                NAKSTS: u1,
                ///  Endpoint Type
                EPTYPE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Control Endpoint.
                        CONTROL = 0x0,
                        ///  Isochronous Endpoint.
                        ISO = 0x1,
                        ///  Bulk Endpoint.
                        BULK = 0x2,
                        ///  Interrupt Endpoint.
                        INT = 0x3,
                    },
                },
                ///  Snoop Mode
                SNP: u1,
                ///  STALL Handshake
                STALL: u1,
                reserved26: u4,
                ///  Clear NAK
                CNAK: u1,
                ///  Set NAK
                SNAK: u1,
                ///  Set DATA0 PID / Even Frame
                SETD0PIDEF: u1,
                ///  Set DATA1 PID / Odd Frame
                SETD1PIDOF: u1,
                ///  Endpoint Disable
                EPDIS: u1,
                ///  Endpoint Enable
                EPENA: u1,
            }),
            reserved248776: [4]u8,
            ///  Device OUT Endpoint x+1 Interrupt Register
            DOEP5_INT: mmio.Mmio(packed struct(u32) {
                ///  Transfer Completed Interrupt
                XFERCOMPL: u1,
                ///  Endpoint Disabled Interrupt
                EPDISBLD: u1,
                ///  AHB Error
                AHBERR: u1,
                ///  Setup Phase Done
                SETUP: u1,
                ///  OUT Token Received When Endpoint Disabled
                OUTTKNEPDIS: u1,
                reserved6: u1,
                ///  Back-to-Back SETUP Packets Received
                BACK2BACKSETUP: u1,
                reserved11: u4,
                ///  Packet Drop Status
                PKTDRPSTS: u1,
                ///  Babble Error
                BBLEERR: u1,
                ///  NAK Interrupt
                NAKINTRPT: u1,
                padding: u18,
            }),
            reserved248784: [4]u8,
            ///  Device OUT Endpoint x+1 Transfer Size Register
            DOEP5_TSIZ: mmio.Mmio(packed struct(u32) {
                ///  Transfer Size
                XFERSIZE: u19,
                ///  Packet Count
                PKTCNT: u10,
                ///  Receive Data PID / SETUP Packet Count
                RXDPIDSUPCNT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DATA0 PID.
                        DATA0 = 0x0,
                        ///  DATA2 PID / 1 Packet.
                        DATA2 = 0x1,
                        ///  DATA1 PID / 2 Packets.
                        DATA1 = 0x2,
                        ///  MDATA PID / 3 Packets.
                        MDATA = 0x3,
                    },
                },
                padding: u1,
            }),
            ///  Device OUT Endpoint x+1 DMA Address Register
            DOEP5_DMAADDR: mmio.Mmio(packed struct(u32) {
                ///  DMA Address
                DMAADDR: u32,
            }),
            reserved249344: [552]u8,
            ///  Power and Clock Gating Control Register
            PCGCCTL: mmio.Mmio(packed struct(u32) {
                ///  Stop PHY clock
                STOPPCLK: u1,
                ///  Gate HCLK
                GATEHCLK: u1,
                ///  Power Clamp
                PWRCLMP: u1,
                ///  Reset Power-Down Modules
                RSTPDWNMODULE: u1,
                reserved6: u2,
                ///  PHY In Sleep
                PHYSLEEP: u1,
                reserved8: u1,
                ///  Reset after suspend
                RESETAFTERSUSP: u1,
                padding: u23,
            }),
        };

        ///  MSC
        pub const MSC = extern struct {
            ///  Memory System Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Bus Fault Response Enable
                BUSFAULT: u1,
                padding: u31,
            }),
            ///  Read Control Register
            READCTRL: mmio.Mmio(packed struct(u32) {
                ///  Read Mode
                MODE: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Zero wait-states inserted in fetch or read transfers.
                        WS0 = 0x0,
                        ///  One wait-state inserted for each fetch or read transfer. This mode is required for a core frequency above 16 MHz.
                        WS1 = 0x1,
                        ///  Zero wait-states inserted with the Suppressed Conditional Branch Target Prefetch (SCBTP) function enabled. SCBTP saves energy by delaying the Cortex' conditional branch target prefetches until the conditional branch instruction is in the execute stage. When the instruction reaches this stage, the evaluation of the branch condition is completed and the core does not perform a speculative prefetch of both the branch target address and the next sequential address. With the SCBTP function enabled, one instruction fetch is saved for each branch not taken, with a negligible performance penalty.
                        WS0SCBTP = 0x2,
                        ///  One wait-state access with SCBTP enabled.
                        WS1SCBTP = 0x3,
                        ///  Two wait-states inserted for each fetch or read transfer. This mode is required for a core frequency above 32 MHz.
                        WS2 = 0x4,
                        ///  Two wait-state access with SCBTP enabled.
                        WS2SCBTP = 0x5,
                        _,
                    },
                },
                ///  Internal Flash Cache Disable
                IFCDIS: u1,
                ///  Automatic Invalidate Disable
                AIDIS: u1,
                ///  Interrupt Context Cache Disable
                ICCDIS: u1,
                ///  External Bus Interface Cache Disable
                EBICDIS: u1,
                ///  RAM Cache Enable
                RAMCEN: u1,
                ///  Prefetch Mode
                PREFETCH: u1,
                reserved16: u7,
                ///  Strategy for bus matrix
                BUSSTRATEGY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        CPU = 0x0,
                        DMA = 0x1,
                        DMAEM1 = 0x2,
                        NONE = 0x3,
                    },
                },
                padding: u14,
            }),
            ///  Write Control Register
            WRITECTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable Write/Erase Controller
                WREN: u1,
                ///  Abort Page Erase on Interrupt
                IRQERASEABORT: u1,
                ///  Write two words at a time
                WDOUBLE: u1,
                ///  Low-Power Erase
                LPWRITE: u1,
                ///  Low-Power Erase
                LPERASE: u1,
                ///  Read-While-Write Enable
                RWWEN: u1,
                padding: u26,
            }),
            ///  Write Command Register
            WRITECMD: mmio.Mmio(packed struct(u32) {
                ///  Load MSC_ADDRB into ADDR
                LADDRIM: u1,
                ///  Erase Page
                ERASEPAGE: u1,
                ///  End Write Mode
                WRITEEND: u1,
                ///  Word Write-Once Trigger
                WRITEONCE: u1,
                ///  Word Write Sequence Trigger
                WRITETRIG: u1,
                ///  Abort erase sequence
                ERASEABORT: u1,
                reserved8: u2,
                ///  Mass erase region 0
                ERASEMAIN0: u1,
                ///  Mass erase region 1
                ERASEMAIN1: u1,
                reserved12: u2,
                ///  Clear WDATA state
                CLEARWDATA: u1,
                padding: u19,
            }),
            ///  Page Erase/Write Address Buffer
            ADDRB: mmio.Mmio(packed struct(u32) {
                ///  Page Erase or Write Address Buffer
                ADDRB: u32,
            }),
            reserved24: [4]u8,
            ///  Write Data Register
            WDATA: mmio.Mmio(packed struct(u32) {
                ///  Write Data
                WDATA: u32,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Erase/Write Busy
                BUSY: u1,
                ///  Access Locked
                LOCKED: u1,
                ///  Invalid Write Address or Erase Page
                INVADDR: u1,
                ///  WDATA Write Ready
                WDATAREADY: u1,
                ///  Flash Write Word Timeout
                WORDTIMEOUT: u1,
                ///  The Current Flash Erase Operation Aborted
                ERASEABORTED: u1,
                ///  Performance Counters Running
                PCRUNNING: u1,
                padding: u25,
            }),
            reserved44: [12]u8,
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Erase Done Interrupt Read Flag
                ERASE: u1,
                ///  Write Done Interrupt Read Flag
                WRITE: u1,
                ///  Cache Hits Overflow Interrupt Flag
                CHOF: u1,
                ///  Cache Misses Overflow Interrupt Flag
                CMOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Erase Done Interrupt Set
                ERASE: u1,
                ///  Write Done Interrupt Set
                WRITE: u1,
                ///  Cache Hits Overflow Interrupt Set
                CHOF: u1,
                ///  Cache Misses Overflow Interrupt Set
                CMOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Erase Done Interrupt Clear
                ERASE: u1,
                ///  Write Done Interrupt Clear
                WRITE: u1,
                ///  Cache Hits Overflow Interrupt Clear
                CHOF: u1,
                ///  Cache Misses Overflow Interrupt Clear
                CMOF: u1,
                padding: u28,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Erase Done Interrupt Enable
                ERASE: u1,
                ///  Write Done Interrupt Enable
                WRITE: u1,
                ///  Cache Hits Overflow Interrupt Enable
                CHOF: u1,
                ///  Cache Misses Overflow Interrupt Enable
                CMOF: u1,
                padding: u28,
            }),
            ///  Configuration Lock Register
            LOCK: mmio.Mmio(packed struct(u32) {
                ///  Configuration Lock
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Invalidate Instruction Cache
                INVCACHE: u1,
                ///  Start Performance Counters
                STARTPC: u1,
                ///  Stop Performance Counters
                STOPPC: u1,
                padding: u29,
            }),
            ///  Cache Hits Performance Counter
            CACHEHITS: mmio.Mmio(packed struct(u32) {
                ///  Cache hits since last performance counter start command.
                CACHEHITS: u20,
                padding: u12,
            }),
            ///  Cache Misses Performance Counter
            CACHEMISSES: mmio.Mmio(packed struct(u32) {
                ///  Cache misses since last performance counter start command.
                CACHEMISSES: u20,
                padding: u12,
            }),
            reserved80: [4]u8,
            ///  Flash Write and Erase Timebase
            TIMEBASE: mmio.Mmio(packed struct(u32) {
                ///  Timebase used by MSC to time flash writes and erases
                BASE: u6,
                reserved16: u10,
                ///  Sets the timebase period
                PERIOD: u1,
                padding: u15,
            }),
            ///  Mass Erase Lock Register
            MASSLOCK: mmio.Mmio(packed struct(u32) {
                ///  Mass Erase Lock
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        ///  Mass erase unlocked.
                        UNLOCKED = 0x0,
                        ///  Mass erase locked.
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
        };

        ///  EMU
        pub const EMU = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Energy Mode Voltage Regulator Control
                EMVREG: u1,
                ///  Energy Mode 2 Block
                EM2BLOCK: u1,
                ///  Energy Mode 4 Control
                EM4CTRL: u2,
                padding: u28,
            }),
            ///  Memory Control Register
            MEMCTRL: mmio.Mmio(packed struct(u32) {
                ///  RAM block power-down
                POWERDOWN: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Power down RAM block 3 (address range 0x20018000-0x2001FFFF).
                        BLK3 = 0x4,
                        ///  Power down RAM blocks 2-3 (address range 0x20010000-0x2001FFFF).
                        BLK23 = 0x6,
                        ///  Power down RAM blocks 1-3 (address range 0x20008000-0x2001FFFF).
                        BLK123 = 0x7,
                        _,
                    },
                },
                padding: u29,
            }),
            ///  Configuration Lock Register
            LOCK: mmio.Mmio(packed struct(u32) {
                ///  Configuration Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
            reserved36: [24]u8,
            ///  Auxiliary Control Register
            AUXCTRL: mmio.Mmio(packed struct(u32) {
                ///  Hard Reset Cause Clear
                HRCCLR: u1,
                reserved8: u7,
                ///  Reduce LFXO Start-up Boost Current
                REDLFXOBOOST: u1,
                padding: u23,
            }),
            reserved44: [4]u8,
            ///  Energy mode 4 configuration register
            EM4CONF: mmio.Mmio(packed struct(u32) {
                ///  EM4 voltage regulator enable
                VREGEN: u1,
                ///  Backup RTC EM4 wakeup enable
                BURTCWU: u1,
                ///  Select EM4 duty oscillator
                OSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ULFRCO is available.
                        ULFRCO = 0x0,
                        ///  LFRCO is available. Can only be set if LFRCO is running before EM4/backup entry.
                        LFRCO = 0x1,
                        ///  LFXO is available. Can only be set if LFXO is available before EM4/backup entry.
                        LFXO = 0x2,
                        _,
                    },
                },
                ///  Disable reset from Backup BOD in EM4
                BUBODRSTDIS: u1,
                reserved16: u11,
                ///  EM4 configuration lock enable
                LOCKCONF: u1,
                padding: u15,
            }),
            ///  Backup Power configuration register
            BUCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable backup mode
                EN: u1,
                ///  Enable backup mode status export
                STATEN: u1,
                ///  Enable BOD calibration mode
                BODCAL: u1,
                ///  Enable brown out detection on BU_VIN when in backup mode
                BUMODEBODEN: u1,
                reserved5: u1,
                ///  Voltage probe select
                PROBE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disable voltage probe.
                        DISABLE = 0x0,
                        ///  Connect probe to VDD_DREG.
                        VDDDREG = 0x1,
                        ///  Connect probe to BU_IN.
                        BUIN = 0x2,
                        ///  Connect probe to BU_OUT.
                        BUOUT = 0x3,
                    },
                },
                padding: u25,
            }),
            ///  Power connection configuration register
            PWRCONF: mmio.Mmio(packed struct(u32) {
                ///  BU_VOUT weak enable
                VOUTWEAK: u1,
                ///  BU_VOUT medium enable
                VOUTMED: u1,
                ///  BU_VOUT strong enable
                VOUTSTRONG: u1,
                ///  Power domain resistor select
                PWRRES: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Main power and backup power connected with RES0 series resistance.
                        RES0 = 0x0,
                        ///  Main power and backup power connected with RES1 series resistance.
                        RES1 = 0x1,
                        ///  Main power and backup power connected with RES2 series resistance.
                        RES2 = 0x2,
                        ///  Main power and backup power connected with RES3 series resistance.
                        RES3 = 0x3,
                    },
                },
                padding: u27,
            }),
            ///  Backup mode inactive configuration register
            BUINACT: mmio.Mmio(packed struct(u32) {
                BUENTHRES: u3,
                BUENRANGE: u2,
                ///  Power connection configuration when not in Backup mode
                PWRCON: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No connection.
                        NONE = 0x0,
                        ///  Main power and backup power are connected through a diode, allowing current to flow from backup power source to main power source, but not the other way.
                        BUMAIN = 0x1,
                        ///  Main power and backup power are connected through a diode, allowing current to flow from main power source to backup power source, but not the other way.
                        MAINBU = 0x2,
                        ///  Main power and backup power are connected without diode.
                        NODIODE = 0x3,
                    },
                },
                padding: u25,
            }),
            ///  Backup mode active configuration register
            BUACT: mmio.Mmio(packed struct(u32) {
                BUEXTHRES: u3,
                BUEXRANGE: u2,
                ///  Power connection configuration when in Backup mode
                PWRCON: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No connection.
                        NONE = 0x0,
                        ///  Main power and backup power are connected through a diode, allowing current to flow from backup power source to main power source, but not the other way.
                        BUMAIN = 0x1,
                        ///  Main power and backup power are connected through a diode, allowing current to flow from main power source to backup power source, but not the other way.
                        MAINBU = 0x2,
                        ///  Main power and backup power are connected without diode.
                        NODIODE = 0x3,
                    },
                },
                padding: u25,
            }),
            ///  Status register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Backup mode ready
                BURDY: u1,
                padding: u31,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  BU_VIN Pin Enable
                BUVINPEN: u1,
                padding: u31,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Backup functionality ready Interrupt Flag
                BURDY: u1,
                padding: u31,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set Backup functionality ready Interrupt Flag
                BURDY: u1,
                padding: u31,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear Backup functionality ready Interrupt Flag
                BURDY: u1,
                padding: u31,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Backup functionality ready Interrupt Enable
                BURDY: u1,
                padding: u31,
            }),
            ///  BU_VIN Backup BOD calibration
            BUBODBUVINCAL: mmio.Mmio(packed struct(u32) {
                THRES: u3,
                RANGE: u2,
                padding: u27,
            }),
            ///  Unregulated power Backup BOD calibration
            BUBODUNREGCAL: mmio.Mmio(packed struct(u32) {
                THRES: u3,
                RANGE: u2,
                padding: u27,
            }),
        };

        ///  RMU
        pub const RMU = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Lockup Reset Disable
                LOCKUPRDIS: u1,
                ///  Backup domain reset enable
                BURSTEN: u1,
                padding: u30,
            }),
            ///  Reset Cause Register
            RSTCAUSE: mmio.Mmio(packed struct(u32) {
                ///  Power On Reset
                PORST: u1,
                ///  Brown Out Detector Unregulated Domain Reset
                BODUNREGRST: u1,
                ///  Brown Out Detector Regulated Domain Reset
                BODREGRST: u1,
                ///  External Pin Reset
                EXTRST: u1,
                ///  Watchdog Reset
                WDOGRST: u1,
                ///  LOCKUP Reset
                LOCKUPRST: u1,
                ///  System Request Reset
                SYSREQRST: u1,
                ///  EM4 Reset
                EM4RST: u1,
                ///  EM4 Wake-up Reset
                EM4WURST: u1,
                ///  AVDD0 Bod Reset
                BODAVDD0: u1,
                ///  AVDD1 Bod Reset
                BODAVDD1: u1,
                ///  Backup Brown Out Detector, VDD_DREG
                BUBODVDDDREG: u1,
                ///  Backup Brown Out Detector, BU_VIN
                BUBODBUVIN: u1,
                ///  Backup Brown Out Detector Unregulated Domain
                BUBODUNREG: u1,
                ///  Backup Brown Out Detector Regulated Domain
                BUBODREG: u1,
                ///  Backup mode reset
                BUMODERST: u1,
                padding: u16,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Reset Cause Clear
                RCCLR: u1,
                padding: u31,
            }),
        };

        ///  CMU
        pub const CMU = extern struct {
            ///  CMU Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  HFXO Mode
                HFXOMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  4-48 MHz crystal oscillator.
                        XTAL = 0x0,
                        ///  An AC coupled buffer is coupled in series with HFXTAL_N, suitable for external sine wave (4-48 MHz). The sine wave should have a minimum of 200 mV peak to peak.
                        BUFEXTCLK = 0x1,
                        ///  Digital external clock on HFXTAL_N pin. Oscillator is effectively bypassed.
                        DIGEXTCLK = 0x2,
                        _,
                    },
                },
                ///  HFXO Start-up Boost Current
                HFXOBOOST: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  50 %.
                        @"50PCENT" = 0x0,
                        ///  70 %.
                        @"70PCENT" = 0x1,
                        ///  80 %.
                        @"80PCENT" = 0x2,
                        ///  100 % (default).
                        @"100PCENT" = 0x3,
                    },
                },
                reserved5: u1,
                ///  HFXO Boost Buffer Current
                HFXOBUFCUR: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Boost Buffer Current level when HFXO is below or equal to 32 MHz.
                        BOOSTUPTO32MHZ = 0x1,
                        ///  Boost Buffer Current Level when HFXO is above 32 MHz.
                        BOOSTABOVE32MHZ = 0x3,
                        _,
                    },
                },
                ///  HFXO Glitch Detector Enable
                HFXOGLITCHDETEN: u1,
                reserved9: u1,
                ///  HFXO Timeout
                HFXOTIMEOUT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Timeout period of 8 cycles.
                        @"8CYCLES" = 0x0,
                        ///  Timeout period of 256 cycles.
                        @"256CYCLES" = 0x1,
                        ///  Timeout period of 1024 cycles.
                        @"1KCYCLES" = 0x2,
                        ///  Timeout period of 16384 cycles.
                        @"16KCYCLES" = 0x3,
                    },
                },
                ///  LFXO Mode
                LFXOMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  32.768 kHz crystal oscillator.
                        XTAL = 0x0,
                        ///  An AC coupled buffer is coupled in series with LFXTAL_N pin, suitable for external sinus wave (32.768 kHz).
                        BUFEXTCLK = 0x1,
                        ///  Digital external clock on LFXTAL_N pin. Oscillator is effectively bypassed.
                        DIGEXTCLK = 0x2,
                        _,
                    },
                },
                ///  LFXO Start-up Boost Current
                LFXOBOOST: u1,
                ///  HFCLK Division
                HFCLKDIV: u3,
                ///  LFXO Boost Buffer Current
                LFXOBUFCUR: u1,
                ///  LFXO Timeout
                LFXOTIMEOUT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Timeout period of 8 cycles.
                        @"8CYCLES" = 0x0,
                        ///  Timeout period of 1024 cycles.
                        @"1KCYCLES" = 0x1,
                        ///  Timeout period of 16384 cycles.
                        @"16KCYCLES" = 0x2,
                        ///  Timeout period of 32768 cycles.
                        @"32KCYCLES" = 0x3,
                    },
                },
                ///  Clock Output Select 0
                CLKOUTSEL0: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  HFRCO (directly from oscillator).
                        HFRCO = 0x0,
                        ///  HFXO (directly from oscillator).
                        HFXO = 0x1,
                        ///  HFCLK/2.
                        HFCLK2 = 0x2,
                        ///  HFCLK/4.
                        HFCLK4 = 0x3,
                        ///  HFCLK/8.
                        HFCLK8 = 0x4,
                        ///  HFCLK/16.
                        HFCLK16 = 0x5,
                        ///  ULFRCO (directly from oscillator).
                        ULFRCO = 0x6,
                        ///  AUXHFRCO (directly from oscillator).
                        AUXHFRCO = 0x7,
                    },
                },
                ///  Clock Output Select 1
                CLKOUTSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  LFRCO (directly from oscillator).
                        LFRCO = 0x0,
                        ///  LFXO (directly from oscillator).
                        LFXO = 0x1,
                        ///  HFCLK (undivided).
                        HFCLK = 0x2,
                        ///  LFXO (qualified).
                        LFXOQ = 0x3,
                        ///  HFXO (qualified).
                        HFXOQ = 0x4,
                        ///  LFRCO (qualified).
                        LFRCOQ = 0x5,
                        ///  HFRCO (qualified).
                        HFRCOQ = 0x6,
                        ///  AUXHFRCO (qualified).
                        AUXHFRCOQ = 0x7,
                        _,
                    },
                },
                reserved28: u1,
                ///  Debug Clock
                DBGCLK: u1,
                reserved30: u1,
                ///  High-Frequency LE Interface
                HFLE: u1,
                padding: u1,
            }),
            ///  High Frequency Core Clock Division Register
            HFCORECLKDIV: mmio.Mmio(packed struct(u32) {
                ///  HFCORECLK Divider
                HFCORECLKDIV: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  HFCORECLK = HFCLK.
                        HFCLK = 0x0,
                        ///  HFCORECLK = HFCLK/2.
                        HFCLK2 = 0x1,
                        ///  HFCORECLK = HFCLK/4.
                        HFCLK4 = 0x2,
                        ///  HFCORECLK = HFCLK/8.
                        HFCLK8 = 0x3,
                        ///  HFCORECLK = HFCLK/16.
                        HFCLK16 = 0x4,
                        ///  HFCORECLK = HFCLK/32.
                        HFCLK32 = 0x5,
                        ///  HFCORECLK = HFCLK/64.
                        HFCLK64 = 0x6,
                        ///  HFCORECLK = HFCLK/128.
                        HFCLK128 = 0x7,
                        ///  HFCORECLK = HFCLK/256.
                        HFCLK256 = 0x8,
                        ///  HFCORECLK = HFCLK/512.
                        HFCLK512 = 0x9,
                        _,
                    },
                },
                reserved8: u4,
                ///  Additional Division Factor For HFCORECLKLE
                HFCORECLKLEDIV: u1,
                padding: u23,
            }),
            ///  High Frequency Peripheral Clock Division Register
            HFPERCLKDIV: mmio.Mmio(packed struct(u32) {
                ///  HFPERCLK Divider
                HFPERCLKDIV: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  HFPERCLK = HFCLK.
                        HFCLK = 0x0,
                        ///  HFPERCLK = HFCLK/2.
                        HFCLK2 = 0x1,
                        ///  HFPERCLK = HFCLK/4.
                        HFCLK4 = 0x2,
                        ///  HFPERCLK = HFCLK/8.
                        HFCLK8 = 0x3,
                        ///  HFPERCLK = HFCLK/16.
                        HFCLK16 = 0x4,
                        ///  HFPERCLK = HFCLK/32.
                        HFCLK32 = 0x5,
                        ///  HFPERCLK = HFCLK/64.
                        HFCLK64 = 0x6,
                        ///  HFPERCLK = HFCLK/128.
                        HFCLK128 = 0x7,
                        ///  HFPERCLK = HFCLK/256.
                        HFCLK256 = 0x8,
                        ///  HFPERCLK = HFCLK/512.
                        HFCLK512 = 0x9,
                        _,
                    },
                },
                reserved8: u4,
                ///  HFPERCLK Enable
                HFPERCLKEN: u1,
                padding: u23,
            }),
            ///  HFRCO Control Register
            HFRCOCTRL: mmio.Mmio(packed struct(u32) {
                ///  HFRCO Tuning Value
                TUNING: u8,
                ///  HFRCO Band Select
                BAND: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  1 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"1MHZ" = 0x0,
                        ///  7 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"7MHZ" = 0x1,
                        ///  11 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"11MHZ" = 0x2,
                        ///  14 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"14MHZ" = 0x3,
                        ///  21 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"21MHZ" = 0x4,
                        ///  28 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"28MHZ" = 0x5,
                        _,
                    },
                },
                reserved12: u1,
                ///  HFRCO Start-up Delay
                SUDELAY: u5,
                padding: u15,
            }),
            ///  LFRCO Control Register
            LFRCOCTRL: mmio.Mmio(packed struct(u32) {
                ///  LFRCO Tuning Value
                TUNING: u7,
                padding: u25,
            }),
            ///  AUXHFRCO Control Register
            AUXHFRCOCTRL: mmio.Mmio(packed struct(u32) {
                ///  AUXHFRCO Tuning Value
                TUNING: u8,
                ///  AUXHFRCO Band Select
                BAND: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  14 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"14MHZ" = 0x0,
                        ///  11 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"11MHZ" = 0x1,
                        ///  7 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"7MHZ" = 0x2,
                        ///  1 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"1MHZ" = 0x3,
                        ///  28 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"28MHZ" = 0x6,
                        ///  21 MHz band. NOTE: Also set the TUNING value (bits 7:0) when changing band.
                        @"21MHZ" = 0x7,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  Calibration Control Register
            CALCTRL: mmio.Mmio(packed struct(u32) {
                ///  Calibration Up-counter Select
                UPSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Select HFXO as up-counter.
                        HFXO = 0x0,
                        ///  Select LFXO as up-counter.
                        LFXO = 0x1,
                        ///  Select HFRCO as up-counter.
                        HFRCO = 0x2,
                        ///  Select LFRCO as up-counter.
                        LFRCO = 0x3,
                        ///  Select AUXHFRCO as up-counter.
                        AUXHFRCO = 0x4,
                        _,
                    },
                },
                ///  Calibration Down-counter Select
                DOWNSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Select HFCLK for down-counter.
                        HFCLK = 0x0,
                        ///  Select HFXO for down-counter.
                        HFXO = 0x1,
                        ///  Select LFXO for down-counter.
                        LFXO = 0x2,
                        ///  Select HFRCO for down-counter.
                        HFRCO = 0x3,
                        ///  Select LFRCO for down-counter.
                        LFRCO = 0x4,
                        ///  Select AUXHFRCO for down-counter.
                        AUXHFRCO = 0x5,
                        _,
                    },
                },
                ///  Continuous Calibration
                CONT: u1,
                padding: u25,
            }),
            ///  Calibration Counter Register
            CALCNT: mmio.Mmio(packed struct(u32) {
                ///  Calibration Counter
                CALCNT: u20,
                padding: u12,
            }),
            ///  Oscillator Enable/Disable Command Register
            OSCENCMD: mmio.Mmio(packed struct(u32) {
                ///  HFRCO Enable
                HFRCOEN: u1,
                ///  HFRCO Disable
                HFRCODIS: u1,
                ///  HFXO Enable
                HFXOEN: u1,
                ///  HFXO Disable
                HFXODIS: u1,
                ///  AUXHFRCO Enable
                AUXHFRCOEN: u1,
                ///  AUXHFRCO Disable
                AUXHFRCODIS: u1,
                ///  LFRCO Enable
                LFRCOEN: u1,
                ///  LFRCO Disable
                LFRCODIS: u1,
                ///  LFXO Enable
                LFXOEN: u1,
                ///  LFXO Disable
                LFXODIS: u1,
                padding: u22,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  HFCLK Select
                HFCLKSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Select HFRCO as HFCLK.
                        HFRCO = 0x1,
                        ///  Select HFXO as HFCLK.
                        HFXO = 0x2,
                        ///  Select LFRCO as HFCLK.
                        LFRCO = 0x3,
                        ///  Select LFXO as HFCLK.
                        LFXO = 0x4,
                        _,
                    },
                },
                ///  Calibration Start
                CALSTART: u1,
                ///  Calibration Stop
                CALSTOP: u1,
                ///  USB Core Clock Select
                USBCCLKSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Select HFCLK (undivided) as HFCORECLKUSBC.
                        HFCLKNODIV = 0x1,
                        ///  Select LFXO as HFCORECLKUSBC.
                        LFXO = 0x2,
                        ///  Select LFRCO as HFCORECLKUSBC.
                        LFRCO = 0x3,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  Low Frequency Clock Select Register
            LFCLKSEL: mmio.Mmio(packed struct(u32) {
                ///  Clock Select for LFA
                LFA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LFACLK is disabled
                        DISABLED = 0x0,
                        ///  LFRCO selected as LFACLK
                        LFRCO = 0x1,
                        ///  LFXO selected as LFACLK
                        LFXO = 0x2,
                        ///  HFCORECLKLE divided by two or four is selected as LFACLK. The division factor is determined by CMU_CTRL_HFLE and CMU_HFCORECLKDIV_HFCORECLKLEDIV.
                        HFCORECLKLEDIV2 = 0x3,
                    },
                },
                ///  Clock Select for LFB
                LFB: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LFBCLK is disabled
                        DISABLED = 0x0,
                        ///  LFRCO selected as LFBCLK
                        LFRCO = 0x1,
                        ///  LFXO selected as LFBCLK
                        LFXO = 0x2,
                        ///  HFCORECLKLE divided by two or four is selected as LFACLK. The division factor is determined by CMU_CTRL_HFLE and CMU_HFCORECLKDIV_HFCORECLKLEDIV.
                        HFCORECLKLEDIV2 = 0x3,
                    },
                },
                reserved16: u12,
                ///  Clock Select for LFA Extended
                LFAE: u1,
                reserved20: u3,
                ///  Clock Select for LFB Extended
                LFBE: u1,
                padding: u11,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  HFRCO Enable Status
                HFRCOENS: u1,
                ///  HFRCO Ready
                HFRCORDY: u1,
                ///  HFXO Enable Status
                HFXOENS: u1,
                ///  HFXO Ready
                HFXORDY: u1,
                ///  AUXHFRCO Enable Status
                AUXHFRCOENS: u1,
                ///  AUXHFRCO Ready
                AUXHFRCORDY: u1,
                ///  LFRCO Enable Status
                LFRCOENS: u1,
                ///  LFRCO Ready
                LFRCORDY: u1,
                ///  LFXO Enable Status
                LFXOENS: u1,
                ///  LFXO Ready
                LFXORDY: u1,
                ///  HFRCO Selected
                HFRCOSEL: u1,
                ///  HFXO Selected
                HFXOSEL: u1,
                ///  LFRCO Selected
                LFRCOSEL: u1,
                ///  LFXO Selected
                LFXOSEL: u1,
                ///  Calibration Busy
                CALBSY: u1,
                ///  USBC HFCLK Selected
                USBCHFCLKSEL: u1,
                ///  USBC LFXO Selected
                USBCLFXOSEL: u1,
                ///  USBC LFRCO Selected
                USBCLFRCOSEL: u1,
                padding: u14,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  HFRCO Ready Interrupt Flag
                HFRCORDY: u1,
                ///  HFXO Ready Interrupt Flag
                HFXORDY: u1,
                ///  LFRCO Ready Interrupt Flag
                LFRCORDY: u1,
                ///  LFXO Ready Interrupt Flag
                LFXORDY: u1,
                ///  AUXHFRCO Ready Interrupt Flag
                AUXHFRCORDY: u1,
                ///  Calibration Ready Interrupt Flag
                CALRDY: u1,
                ///  Calibration Overflow Interrupt Flag
                CALOF: u1,
                ///  USBC HFCLK Selected Interrupt Flag
                USBCHFCLKSEL: u1,
                padding: u24,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  HFRCO Ready Interrupt Flag Set
                HFRCORDY: u1,
                ///  HFXO Ready Interrupt Flag Set
                HFXORDY: u1,
                ///  LFRCO Ready Interrupt Flag Set
                LFRCORDY: u1,
                ///  LFXO Ready Interrupt Flag Set
                LFXORDY: u1,
                ///  AUXHFRCO Ready Interrupt Flag Set
                AUXHFRCORDY: u1,
                ///  Calibration Ready Interrupt Flag Set
                CALRDY: u1,
                ///  Calibration Overflow Interrupt Flag Set
                CALOF: u1,
                ///  USBC HFCLK Selected Interrupt Flag Set
                USBCHFCLKSEL: u1,
                padding: u24,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  HFRCO Ready Interrupt Flag Clear
                HFRCORDY: u1,
                ///  HFXO Ready Interrupt Flag Clear
                HFXORDY: u1,
                ///  LFRCO Ready Interrupt Flag Clear
                LFRCORDY: u1,
                ///  LFXO Ready Interrupt Flag Clear
                LFXORDY: u1,
                ///  AUXHFRCO Ready Interrupt Flag Clear
                AUXHFRCORDY: u1,
                ///  Calibration Ready Interrupt Flag Clear
                CALRDY: u1,
                ///  Calibration Overflow Interrupt Flag Clear
                CALOF: u1,
                ///  USBC HFCLK Selected Interrupt Flag Clear
                USBCHFCLKSEL: u1,
                padding: u24,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  HFRCO Ready Interrupt Enable
                HFRCORDY: u1,
                ///  HFXO Ready Interrupt Enable
                HFXORDY: u1,
                ///  LFRCO Ready Interrupt Enable
                LFRCORDY: u1,
                ///  LFXO Ready Interrupt Enable
                LFXORDY: u1,
                ///  AUXHFRCO Ready Interrupt Enable
                AUXHFRCORDY: u1,
                ///  Calibration Ready Interrupt Enable
                CALRDY: u1,
                ///  Calibration Overflow Interrupt Enable
                CALOF: u1,
                ///  USBC HFCLK Selected Interrupt Enable
                USBCHFCLKSEL: u1,
                padding: u24,
            }),
            ///  High Frequency Core Clock Enable Register 0
            HFCORECLKEN0: mmio.Mmio(packed struct(u32) {
                ///  Direct Memory Access Controller Clock Enable
                DMA: u1,
                ///  Advanced Encryption Standard Accelerator Clock Enable
                AES: u1,
                ///  Universal Serial Bus Interface Core Clock Enable
                USBC: u1,
                ///  Universal Serial Bus Interface Clock Enable
                USB: u1,
                ///  Low Energy Peripheral Interface Clock Enable
                LE: u1,
                ///  External Bus Interface Clock Enable
                EBI: u1,
                padding: u26,
            }),
            ///  High Frequency Peripheral Clock Enable Register 0
            HFPERCLKEN0: mmio.Mmio(packed struct(u32) {
                ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0 Clock Enable
                USART0: u1,
                ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1 Clock Enable
                USART1: u1,
                ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2 Clock Enable
                USART2: u1,
                ///  Universal Asynchronous Receiver/Transmitter 0 Clock Enable
                UART0: u1,
                ///  Universal Asynchronous Receiver/Transmitter 1 Clock Enable
                UART1: u1,
                ///  Timer 0 Clock Enable
                TIMER0: u1,
                ///  Timer 1 Clock Enable
                TIMER1: u1,
                ///  Timer 2 Clock Enable
                TIMER2: u1,
                ///  Timer 3 Clock Enable
                TIMER3: u1,
                ///  Analog Comparator 0 Clock Enable
                ACMP0: u1,
                ///  Analog Comparator 1 Clock Enable
                ACMP1: u1,
                ///  I2C 0 Clock Enable
                I2C0: u1,
                ///  I2C 1 Clock Enable
                I2C1: u1,
                ///  General purpose Input/Output Clock Enable
                GPIO: u1,
                ///  Voltage Comparator Clock Enable
                VCMP: u1,
                ///  Peripheral Reflex System Clock Enable
                PRS: u1,
                ///  Analog to Digital Converter 0 Clock Enable
                ADC0: u1,
                ///  Digital to Analog Converter 0 Clock Enable
                DAC0: u1,
                padding: u14,
            }),
            reserved80: [8]u8,
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  Low Frequency A Clock Enable 0 Busy
                LFACLKEN0: u1,
                reserved2: u1,
                ///  Low Frequency A Prescaler 0 Busy
                LFAPRESC0: u1,
                reserved4: u1,
                ///  Low Frequency B Clock Enable 0 Busy
                LFBCLKEN0: u1,
                reserved6: u1,
                ///  Low Frequency B Prescaler 0 Busy
                LFBPRESC0: u1,
                padding: u25,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Low Frequency A Clock Enable Register 0 (Async Reg)
            LFACLKEN0: mmio.Mmio(packed struct(u32) {
                ///  Low Energy Sensor Interface Clock Enable
                LESENSE: u1,
                ///  Real-Time Counter Clock Enable
                RTC: u1,
                ///  Low Energy Timer 0 Clock Enable
                LETIMER0: u1,
                padding: u29,
            }),
            reserved96: [4]u8,
            ///  Low Frequency B Clock Enable Register 0 (Async Reg)
            LFBCLKEN0: mmio.Mmio(packed struct(u32) {
                ///  Low Energy UART 0 Clock Enable
                LEUART0: u1,
                ///  Low Energy UART 1 Clock Enable
                LEUART1: u1,
                padding: u30,
            }),
            reserved104: [4]u8,
            ///  Low Frequency A Prescaler Register 0 (Async Reg)
            LFAPRESC0: mmio.Mmio(packed struct(u32) {
                ///  Low Energy Sensor Interface Prescaler
                LESENSE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LFACLKLESENSE = LFACLK
                        DIV1 = 0x0,
                        ///  LFACLKLESENSE = LFACLK/2
                        DIV2 = 0x1,
                        ///  LFACLKLESENSE = LFACLK/4
                        DIV4 = 0x2,
                        ///  LFACLKLESENSE = LFACLK/8
                        DIV8 = 0x3,
                    },
                },
                reserved4: u2,
                ///  Real-Time Counter Prescaler
                RTC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  LFACLKRTC = LFACLK
                        DIV1 = 0x0,
                        ///  LFACLKRTC = LFACLK/2
                        DIV2 = 0x1,
                        ///  LFACLKRTC = LFACLK/4
                        DIV4 = 0x2,
                        ///  LFACLKRTC = LFACLK/8
                        DIV8 = 0x3,
                        ///  LFACLKRTC = LFACLK/16
                        DIV16 = 0x4,
                        ///  LFACLKRTC = LFACLK/32
                        DIV32 = 0x5,
                        ///  LFACLKRTC = LFACLK/64
                        DIV64 = 0x6,
                        ///  LFACLKRTC = LFACLK/128
                        DIV128 = 0x7,
                        ///  LFACLKRTC = LFACLK/256
                        DIV256 = 0x8,
                        ///  LFACLKRTC = LFACLK/512
                        DIV512 = 0x9,
                        ///  LFACLKRTC = LFACLK/1024
                        DIV1024 = 0xa,
                        ///  LFACLKRTC = LFACLK/2048
                        DIV2048 = 0xb,
                        ///  LFACLKRTC = LFACLK/4096
                        DIV4096 = 0xc,
                        ///  LFACLKRTC = LFACLK/8192
                        DIV8192 = 0xd,
                        ///  LFACLKRTC = LFACLK/16384
                        DIV16384 = 0xe,
                        ///  LFACLKRTC = LFACLK/32768
                        DIV32768 = 0xf,
                    },
                },
                ///  Low Energy Timer 0 Prescaler
                LETIMER0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  LFACLKLETIMER0 = LFACLK
                        DIV1 = 0x0,
                        ///  LFACLKLETIMER0 = LFACLK/2
                        DIV2 = 0x1,
                        ///  LFACLKLETIMER0 = LFACLK/4
                        DIV4 = 0x2,
                        ///  LFACLKLETIMER0 = LFACLK/8
                        DIV8 = 0x3,
                        ///  LFACLKLETIMER0 = LFACLK/16
                        DIV16 = 0x4,
                        ///  LFACLKLETIMER0 = LFACLK/32
                        DIV32 = 0x5,
                        ///  LFACLKLETIMER0 = LFACLK/64
                        DIV64 = 0x6,
                        ///  LFACLKLETIMER0 = LFACLK/128
                        DIV128 = 0x7,
                        ///  LFACLKLETIMER0 = LFACLK/256
                        DIV256 = 0x8,
                        ///  LFACLKLETIMER0 = LFACLK/512
                        DIV512 = 0x9,
                        ///  LFACLKLETIMER0 = LFACLK/1024
                        DIV1024 = 0xa,
                        ///  LFACLKLETIMER0 = LFACLK/2048
                        DIV2048 = 0xb,
                        ///  LFACLKLETIMER0 = LFACLK/4096
                        DIV4096 = 0xc,
                        ///  LFACLKLETIMER0 = LFACLK/8192
                        DIV8192 = 0xd,
                        ///  LFACLKLETIMER0 = LFACLK/16384
                        DIV16384 = 0xe,
                        ///  LFACLKLETIMER0 = LFACLK/32768
                        DIV32768 = 0xf,
                    },
                },
                padding: u20,
            }),
            reserved112: [4]u8,
            ///  Low Frequency B Prescaler Register 0 (Async Reg)
            LFBPRESC0: mmio.Mmio(packed struct(u32) {
                ///  Low Energy UART 0 Prescaler
                LEUART0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LFBCLKLEUART0 = LFBCLK
                        DIV1 = 0x0,
                        ///  LFBCLKLEUART0 = LFBCLK/2
                        DIV2 = 0x1,
                        ///  LFBCLKLEUART0 = LFBCLK/4
                        DIV4 = 0x2,
                        ///  LFBCLKLEUART0 = LFBCLK/8
                        DIV8 = 0x3,
                    },
                },
                reserved4: u2,
                ///  Low Energy UART 1 Prescaler
                LEUART1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LFBCLKLEUART1 = LFBCLK
                        DIV1 = 0x0,
                        ///  LFBCLKLEUART1 = LFBCLK/2
                        DIV2 = 0x1,
                        ///  LFBCLKLEUART1 = LFBCLK/4
                        DIV4 = 0x2,
                        ///  LFBCLKLEUART1 = LFBCLK/8
                        DIV8 = 0x3,
                    },
                },
                padding: u26,
            }),
            reserved120: [4]u8,
            ///  PCNT Control Register
            PCNTCTRL: mmio.Mmio(packed struct(u32) {
                ///  PCNT0 Clock Enable
                PCNT0CLKEN: u1,
                ///  PCNT0 Clock Select
                PCNT0CLKSEL: u1,
                ///  PCNT1 Clock Enable
                PCNT1CLKEN: u1,
                ///  PCNT1 Clock Select
                PCNT1CLKSEL: u1,
                ///  PCNT2 Clock Enable
                PCNT2CLKEN: u1,
                ///  PCNT2 Clock Select
                PCNT2CLKSEL: u1,
                padding: u26,
            }),
            reserved128: [4]u8,
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  CLKOUT0 Pin Enable
                CLKOUT0PEN: u1,
                ///  CLKOUT1 Pin Enable
                CLKOUT1PEN: u1,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        _,
                    },
                },
                padding: u27,
            }),
            ///  Configuration Lock Register
            LOCK: mmio.Mmio(packed struct(u32) {
                ///  Configuration Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
        };

        ///  LESENSE
        pub const LESENSE = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Configure scan mode
                SCANMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  A new scan is started each time the period counter overflows
                        PERIODIC = 0x0,
                        ///  A single scan is performed when START in CMD is set
                        ONESHOT = 0x1,
                        ///  Pulse on PRS channel
                        PRS = 0x2,
                        _,
                    },
                },
                ///  Scan start PRS select
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Select scan configuration
                SCANCONF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The channel configuration register registers used are directly mapped to the channel number.
                        DIRMAP = 0x0,
                        ///  The channel configuration register registers used are CHX+8_CONF for channels 0-7 and CHX-8_CONF for channels 8-15.
                        INVMAP = 0x1,
                        ///  The channel configuration register registers used toggles between CHX_CONF and CHX+8_CONF when channel x triggers
                        TOGGLE = 0x2,
                        ///  The decoder state defines the CONF registers to be used.
                        DECDEF = 0x3,
                    },
                },
                reserved9: u1,
                ///  Invert analog comparator 0 output
                ACMP0INV: u1,
                ///  Invert analog comparator 1 output
                ACMP1INV: u1,
                ///  Alternative excitation map
                ALTEXMAP: u1,
                reserved13: u1,
                ///  Enable dual sample mode
                DUALSAMPLE: u1,
                reserved16: u2,
                ///  Result buffer overwrite
                BUFOW: u1,
                ///  Enable storing of SCANRES
                STRSCANRES: u1,
                ///  Result buffer interrupt and DMA trigger level
                BUFIDL: u1,
                reserved20: u1,
                ///  DMA wake-up from EM2
                DMAWU: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No DMA wake-up from EM2
                        DISABLE = 0x0,
                        ///  DMA wake-up from EM2 when data is valid in the result buffer
                        BUFDATAV = 0x1,
                        ///  DMA wake-up from EM2 when the result buffer is full/half-full depending on BUFIDL configuration
                        BUFLEVEL = 0x2,
                        _,
                    },
                },
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                padding: u9,
            }),
            ///  Timing Control Register
            TIMCTRL: mmio.Mmio(packed struct(u32) {
                ///  Prescaling factor for high frequency timer
                AUXPRESC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  High frequency timer is clocked with AUXHFRCO/1
                        DIV1 = 0x0,
                        ///  High frequency timer is clocked with AUXHFRCO/2
                        DIV2 = 0x1,
                        ///  High frequency timer is clocked with AUXHFRCO/4
                        DIV4 = 0x2,
                        ///  High frequency timer is clocked with AUXHFRCO/8
                        DIV8 = 0x3,
                    },
                },
                reserved4: u2,
                ///  Prescaling factor for low frequency timer
                LFPRESC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Low frequency timer is clocked with LFACLKLESENSE/1
                        DIV1 = 0x0,
                        ///  Low frequency timer is clocked with LFACLKLESENSE/2
                        DIV2 = 0x1,
                        ///  Low frequency timer is clocked with LFACLKLESENSE/4
                        DIV4 = 0x2,
                        ///  Low frequency timer is clocked with LFACLKLESENSE/8
                        DIV8 = 0x3,
                        ///  Low frequency timer is clocked with LFACLKLESENSE/16
                        DIV16 = 0x4,
                        ///  Low frequency timer is clocked with LFACLKLESENSE/32
                        DIV32 = 0x5,
                        ///  Low frequency timer is clocked with LFACLKLESENSE/64
                        DIV64 = 0x6,
                        ///  Low frequency timer is clocked with LFACLKLESENSE/128
                        DIV128 = 0x7,
                    },
                },
                reserved8: u1,
                ///  Period counter prescaling
                PCPRESC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  The period counter clock frequency is LFACLKLESENSE/1
                        DIV1 = 0x0,
                        ///  The period counter clock frequency is LFACLKLESENSE/2
                        DIV2 = 0x1,
                        ///  The period counter clock frequency is LFACLKLESENSE/4
                        DIV4 = 0x2,
                        ///  The period counter clock frequency is LFACLKLESENSE/8
                        DIV8 = 0x3,
                        ///  The period counter clock frequency is LFACLKLESENSE/16
                        DIV16 = 0x4,
                        ///  The period counter clock frequency is LFACLKLESENSE/32
                        DIV32 = 0x5,
                        ///  The period counter clock frequency is LFACLKLESENSE/64
                        DIV64 = 0x6,
                        ///  The period counter clock frequency is LFACLKLESENSE/128
                        DIV128 = 0x7,
                    },
                },
                reserved12: u1,
                ///  Period counter top value
                PCTOP: u8,
                reserved22: u2,
                ///  Start delay configuration
                STARTDLY: u2,
                padding: u8,
            }),
            ///  Peripheral Control Register
            PERCTRL: mmio.Mmio(packed struct(u32) {
                ///  DAC CH0 data selection.
                DACCH0DATA: u1,
                ///  DAC CH1 data selection.
                DACCH1DATA: u1,
                ///  DAC channel 0 conversion mode
                DACCH0CONV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LESENSE does not control DAC CH0.
                        DISABLE = 0x0,
                        ///  DAC channel 0 is driven in continuous mode.
                        CONTINUOUS = 0x1,
                        ///  DAC channel 0 is driven in sample hold mode.
                        SAMPLEHOLD = 0x2,
                        ///  DAC channel 0 is driven in sample off mode.
                        SAMPLEOFF = 0x3,
                    },
                },
                ///  DAC channel 1 conversion mode
                DACCH1CONV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LESENSE does not control DAC CH1.
                        DISABLE = 0x0,
                        ///  DAC channel 1 is driven in continuous mode.
                        CONTINUOUS = 0x1,
                        ///  DAC channel 1 is driven in sample hold mode.
                        SAMPLEHOLD = 0x2,
                        ///  DAC channel 1 is driven in sample off mode.
                        SAMPLEOFF = 0x3,
                    },
                },
                ///  DAC channel 0 output mode
                DACCH0OUT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DAC CH0 output to pin and ACMP/ADC disabled
                        DISABLE = 0x0,
                        ///  DAC CH0 output to pin enabled, output to ADC and ACMP disabled
                        PIN = 0x1,
                        ///  DAC CH0 output to pin disabled, output to ADC and ACMP enabled
                        ADCACMP = 0x2,
                        ///  DAC CH0 output to pin, ADC, and ACMP enabled.
                        PINADCACMP = 0x3,
                    },
                },
                ///  DAC channel 1 output mode
                DACCH1OUT: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DAC CH1 output to pin and ACMP/ADC disabled
                        DISABLE = 0x0,
                        ///  DAC CH1 output to pin enabled, output to ADC and ACMP disabled
                        PIN = 0x1,
                        ///  DAC CH1 output to pin disabled, output to ADC and ACMP enabled
                        ADCACMP = 0x2,
                        ///  DAC CH1 output to pin, ADC, and ACMP enabled.
                        PINADCACMP = 0x3,
                    },
                },
                ///  DAC prescaler configuration.
                DACPRESC: u5,
                reserved18: u3,
                ///  DAC bandgap reference used
                DACREF: u1,
                reserved20: u1,
                ///  ACMP0 mode
                ACMP0MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LESENSE does not control ACMP0
                        DISABLE = 0x0,
                        ///  LESENSE controls the input mux (POSSEL) of ACMP0
                        MUX = 0x1,
                        ///  LESENSE controls the input mux (POSSEL) and the threshold value (VDDLEVEL) of ACMP0
                        MUXTHRES = 0x2,
                        _,
                    },
                },
                ///  ACMP1 mode
                ACMP1MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LESENSE does not control ACMP1
                        DISABLE = 0x0,
                        ///  LESENSE controls the input mux (POSSEL) of ACMP1
                        MUX = 0x1,
                        ///  LESENSE controls the input mux and the threshold value (VDDLEVEL) of ACMP1
                        MUXTHRES = 0x2,
                        _,
                    },
                },
                reserved26: u2,
                ///  ACMP and DAC duty cycle mode
                WARMUPMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The analog comparators and DAC are shut down when LESENSE is idle
                        NORMAL = 0x0,
                        ///  The analog comparators are kept powered up when LESENSE is idle
                        KEEPACMPWARM = 0x1,
                        ///  The DAC is kept powered up when LESENSE is idle
                        KEEPDACWARM = 0x2,
                        ///  The analog comparators and DAC are kept powered up when LESENSE is idle
                        KEEPACMPDACWARM = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  Decoder control Register
            DECCTRL: mmio.Mmio(packed struct(u32) {
                ///  Disable the decoder
                DISABLE: u1,
                ///  Enable check of current state
                ERRCHK: u1,
                ///  Enable decoder to channel interrupt mapping
                INTMAP: u1,
                ///  Enable decoder hysteresis on PRS0 output
                HYSTPRS0: u1,
                ///  Enable decoder hysteresis on PRS1 output
                HYSTPRS1: u1,
                ///  Enable decoder hysteresis on PRS2 output
                HYSTPRS2: u1,
                ///  Enable decoder hysteresis on interrupt requests
                HYSTIRQ: u1,
                ///  Enable count mode on decoder PRS channels 0 and 1
                PRSCNT: u1,
                INPUT: u1,
                reserved10: u1,
                PRSSEL0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                PRSSEL1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                PRSSEL2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                PRSSEL3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                padding: u6,
            }),
            ///  Bias Control Register
            BIASCTRL: mmio.Mmio(packed struct(u32) {
                ///  Select bias mode
                BIASMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Bias module duty cycled between low power and high accuracy mode
                        DUTYCYCLE = 0x0,
                        ///  Bias module always in high accuracy mode
                        HIGHACC = 0x1,
                        ///  Bias module not affected by LESENSE
                        DONTTOUCH = 0x2,
                        _,
                    },
                },
                padding: u30,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Start scanning of sensors.
                START: u1,
                ///  Stop scanning of sensors
                STOP: u1,
                ///  Start decoder
                DECODE: u1,
                ///  Clear result buffer
                CLEARBUF: u1,
                padding: u28,
            }),
            ///  Channel enable Register
            CHEN: mmio.Mmio(packed struct(u32) {
                ///  Enable scan channel
                CHEN: u16,
                padding: u16,
            }),
            ///  Scan result register
            SCANRES: mmio.Mmio(packed struct(u32) {
                ///  Scan results
                SCANRES: u16,
                padding: u16,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Result data valid
                BUFDATAV: u1,
                ///  Result buffer half full
                BUFHALFFULL: u1,
                ///  Result buffer full
                BUFFULL: u1,
                ///  LESENSE is active
                RUNNING: u1,
                ///  LESENSE is currently interfacing sensors.
                SCANACTIVE: u1,
                ///  LESENSE DAC interface is active
                DACACTIVE: u1,
                padding: u26,
            }),
            ///  Result buffer pointers
            PTR: mmio.Mmio(packed struct(u32) {
                ///  Result buffer read pointer.
                RD: u4,
                reserved5: u1,
                ///  Result buffer write pointer.
                WR: u4,
                padding: u23,
            }),
            ///  Result buffer data register
            BUFDATA: mmio.Mmio(packed struct(u32) {
                ///  Result data
                BUFDATA: u16,
                padding: u16,
            }),
            ///  Current channel index
            CURCH: mmio.Mmio(packed struct(u32) {
                ///  Shows the index of the current channel
                CURCH: u4,
                padding: u28,
            }),
            ///  Current decoder state
            DECSTATE: mmio.Mmio(packed struct(u32) {
                ///  Shows the current decoder state
                DECSTATE: u4,
                padding: u28,
            }),
            ///  Decoder input register
            SENSORSTATE: mmio.Mmio(packed struct(u32) {
                ///  Shows the status of sensors chosen as input to the decoder
                SENSORSTATE: u4,
                padding: u28,
            }),
            ///  GPIO Idle phase configuration
            IDLECONF: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 idle phase configuration
                CH0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH0 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH0 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH0 output is low in idle phase
                        LOW = 0x2,
                        ///  CH0 output is connected to DAC CH0 output in idle phase
                        DACCH0 = 0x3,
                    },
                },
                ///  Channel 1 idle phase configuration
                CH1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH1 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH1 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH1 output is low in idle phase
                        LOW = 0x2,
                        ///  CH1 output is connected to DAC CH0 output in idle phase
                        DACCH0 = 0x3,
                    },
                },
                ///  Channel 2 idle phase configuration
                CH2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH2 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH2 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH2 output is low in idle phase
                        LOW = 0x2,
                        ///  CH2 output is connected to DAC CH0 output in idle phase
                        DACCH0 = 0x3,
                    },
                },
                ///  Channel 3 idle phase configuration
                CH3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH3 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH3 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH3 output is low in idle phase
                        LOW = 0x2,
                        ///  CH3 output is connected to DAC CH0 output in idle phase
                        DACCH0 = 0x3,
                    },
                },
                ///  Channel 4 idle phase configuration
                CH4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH4 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH4 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH4 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 5 idle phase configuration
                CH5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH5 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH5 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH5 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 6 idle phase configuration
                CH6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH6 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH6 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH6 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 7 idle phase configuration
                CH7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH7 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH7 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH7 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 8 idle phase configuration
                CH8: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH8 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH8 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH8 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 9 idle phase configuration
                CH9: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH9 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH9 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH9 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 10 idle phase configuration
                CH10: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH10 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH10 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH10 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 11 idle phase configuration
                CH11: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH11 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH11 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH11 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  Channel 12 idle phase configuration
                CH12: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH12 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH12 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH12 output is low in idle phase
                        LOW = 0x2,
                        ///  CH12 output is connected to DAC CH1 output in idle phase
                        DACCH1 = 0x3,
                    },
                },
                ///  Channel 13 idle phase configuration
                CH13: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH13 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH13 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH13 output is low in idle phase
                        LOW = 0x2,
                        ///  CH13 output is connected to DAC CH1 output in idle phase
                        DACCH1 = 0x3,
                    },
                },
                ///  Channel 14 idle phase configuration
                CH14: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH14 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH14 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH14 output is low in idle phase
                        LOW = 0x2,
                        ///  CH14 output is connected to DAC CH1 output in idle phase
                        DACCH1 = 0x3,
                    },
                },
                ///  Channel 15 idle phase configuration
                CH15: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  CH15 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  CH15 output is high in idle phase
                        HIGH = 0x1,
                        ///  CH15 output is low in idle phase
                        LOW = 0x2,
                        ///  CH15 output is connected to DAC CH1 output in idle phase
                        DACCH1 = 0x3,
                    },
                },
            }),
            ///  Alternative excite pin configuration
            ALTEXCONF: mmio.Mmio(packed struct(u32) {
                ///  ALTEX0 idle phase configuration
                IDLECONF0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX0 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX0 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX0 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX1 idle phase configuration
                IDLECONF1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX1 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX1 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX1 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX2 idle phase configuration
                IDLECONF2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX2 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX2 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX2 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX3 idle phase configuration
                IDLECONF3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX3 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX3 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX3 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX4 idle phase configuration
                IDLECONF4: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX4 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX4 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX4 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX5 idle phase configuration
                IDLECONF5: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX5 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX5 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX5 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX6 idle phase configuration
                IDLECONF6: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX6 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX6 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX6 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX7 idle phase configuration
                IDLECONF7: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ALTEX7 output is disabled in idle phase
                        DISABLE = 0x0,
                        ///  ALTEX7 output is high in idle phase
                        HIGH = 0x1,
                        ///  ALTEX7 output is low in idle phase
                        LOW = 0x2,
                        _,
                    },
                },
                ///  ALTEX0 always excite enable
                AEX0: u1,
                ///  ALTEX1 always excite enable
                AEX1: u1,
                ///  ALTEX2 always excite enable
                AEX2: u1,
                ///  ALTEX3 always excite enable
                AEX3: u1,
                ///  ALTEX4 always excite enable
                AEX4: u1,
                ///  ALTEX5 always excite enable
                AEX5: u1,
                ///  ALTEX6 always excite enable
                AEX6: u1,
                ///  ALTEX7 always excite enable
                AEX7: u1,
                padding: u8,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                CH0: u1,
                CH1: u1,
                CH2: u1,
                CH3: u1,
                CH4: u1,
                CH5: u1,
                CH6: u1,
                CH7: u1,
                CH8: u1,
                CH9: u1,
                CH10: u1,
                CH11: u1,
                CH12: u1,
                CH13: u1,
                CH14: u1,
                CH15: u1,
                SCANCOMPLETE: u1,
                DEC: u1,
                DECERR: u1,
                BUFDATAV: u1,
                BUFLEVEL: u1,
                BUFOF: u1,
                CNTOF: u1,
                padding: u9,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                CH0: u1,
                CH1: u1,
                CH2: u1,
                CH3: u1,
                CH4: u1,
                CH5: u1,
                CH6: u1,
                CH7: u1,
                CH8: u1,
                CH9: u1,
                CH10: u1,
                CH11: u1,
                CH12: u1,
                CH13: u1,
                CH14: u1,
                CH15: u1,
                SCANCOMPLETE: u1,
                DEC: u1,
                DECERR: u1,
                BUFDATAV: u1,
                BUFLEVEL: u1,
                BUFOF: u1,
                CNTOF: u1,
                padding: u9,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                CH0: u1,
                CH1: u1,
                CH2: u1,
                CH3: u1,
                CH4: u1,
                CH5: u1,
                CH6: u1,
                CH7: u1,
                CH8: u1,
                CH9: u1,
                CH10: u1,
                CH11: u1,
                CH12: u1,
                CH13: u1,
                CH14: u1,
                CH15: u1,
                SCANCOMPLETE: u1,
                DEC: u1,
                DECERR: u1,
                BUFDATAV: u1,
                BUFLEVEL: u1,
                BUFOF: u1,
                CNTOF: u1,
                padding: u9,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                CH0: u1,
                CH1: u1,
                CH2: u1,
                CH3: u1,
                CH4: u1,
                CH5: u1,
                CH6: u1,
                CH7: u1,
                CH8: u1,
                CH9: u1,
                CH10: u1,
                CH11: u1,
                CH12: u1,
                CH13: u1,
                CH14: u1,
                CH15: u1,
                SCANCOMPLETE: u1,
                DEC: u1,
                DECERR: u1,
                BUFDATAV: u1,
                BUFLEVEL: u1,
                BUFOF: u1,
                CNTOF: u1,
                padding: u9,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  LESENSE_CTRL Register Busy
                CTRL: u1,
                ///  LESENSE_TIMCTRL Register Busy
                TIMCTRL: u1,
                ///  LESENSE_PERCTRL Register Busy
                PERCTRL: u1,
                ///  LESENSE_DECCTRL Register Busy
                DECCTRL: u1,
                ///  LESENSE_BIASCTRL Register Busy
                BIASCTRL: u1,
                ///  LESENSE_CMD Register Busy
                CMD: u1,
                ///  LESENSE_CHEN Register Busy
                CHEN: u1,
                ///  LESENSE_SCANRES Register Busy
                SCANRES: u1,
                ///  LESENSE_STATUS Register Busy
                STATUS: u1,
                ///  LESENSE_PTR Register Busy
                PTR: u1,
                ///  LESENSE_BUFDATA Register Busy
                BUFDATA: u1,
                ///  LESENSE_CURCH Register Busy
                CURCH: u1,
                ///  LESENSE_DECSTATE Register Busy
                DECSTATE: u1,
                ///  LESENSE_SENSORSTATE Register Busy
                SENSORSTATE: u1,
                ///  LESENSE_IDLECONF Register Busy
                IDLECONF: u1,
                ///  LESENSE_ALTEXCONF Register Busy
                ALTEXCONF: u1,
                ///  LESENSE_ROUTE Register Busy
                ROUTE: u1,
                ///  LESENSE_POWERDOWN Register Busy
                POWERDOWN: u1,
                reserved21: u3,
                ///  LESENSE_STx_TCONFA Register Busy
                TCONFA: u1,
                ///  LESENSE_STx_TCONFB Register Busy
                TCONFB: u1,
                ///  LESENSE_BUFx_DATA Register Busy
                DATA: u1,
                ///  LESENSE_CHx_TIMING Register Busy
                TIMING: u1,
                ///  LESENSE_CHx_INTERACT Register Busy
                INTERACT: u1,
                ///  LESENSE_CHx_EVAL Register Busy
                EVAL: u1,
                padding: u5,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  CH0 Pin Enable
                CH0PEN: u1,
                ///  CH0 Pin Enable
                CH1PEN: u1,
                ///  CH2 Pin Enable
                CH2PEN: u1,
                ///  CH3 Pin Enable
                CH3PEN: u1,
                ///  CH4 Pin Enable
                CH4PEN: u1,
                ///  CH5 Pin Enable
                CH5PEN: u1,
                ///  CH6 Pin Enable
                CH6PEN: u1,
                ///  CH7 Pin Enable
                CH7PEN: u1,
                ///  CH8 Pin Enable
                CH8PEN: u1,
                ///  CH9 Pin Enable
                CH9PEN: u1,
                ///  CH10 Pin Enable
                CH10PEN: u1,
                ///  CH11 Pin Enable
                CH11PEN: u1,
                ///  CH12 Pin Enable
                CH12PEN: u1,
                ///  CH13 Pin Enable
                CH13PEN: u1,
                ///  CH14 Pin Enable
                CH14PEN: u1,
                ///  CH15 Pin Enable
                CH15PEN: u1,
                ///  ALTEX0 Pin Enable
                ALTEX0PEN: u1,
                ///  ALTEX1 Pin Enable
                ALTEX1PEN: u1,
                ///  ALTEX2 Pin Enable
                ALTEX2PEN: u1,
                ///  ALTEX3 Pin Enable
                ALTEX3PEN: u1,
                ///  ALTEX4 Pin Enable
                ALTEX4PEN: u1,
                ///  ALTEX5 Pin Enable
                ALTEX5PEN: u1,
                ///  ALTEX6 Pin Enable
                ALTEX6PEN: u1,
                ///  ALTEX7 Pin Enable
                ALTEX7PEN: u1,
                padding: u8,
            }),
            ///  LESENSE RAM power-down register
            POWERDOWN: mmio.Mmio(packed struct(u32) {
                ///  LESENSE RAM power-down
                RAM: u1,
                padding: u31,
            }),
            reserved512: [420]u8,
            ///  State transition configuration A
            ST0_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST0_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST1_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST1_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST2_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST2_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST3_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST3_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST4_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST4_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST5_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST5_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST6_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST6_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST7_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST7_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST8_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST8_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST9_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST9_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST10_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST10_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST11_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST11_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST12_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST12_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST13_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST13_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST14_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST14_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  State transition configuration A
            ST15_TCONFA: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag enable
                SETIF: u1,
                reserved18: u1,
                ///  Enable state descriptor chaining
                CHAIN: u1,
                padding: u13,
            }),
            ///  State transition configuration B
            ST15_TCONFB: mmio.Mmio(packed struct(u32) {
                ///  Sensor compare value
                COMP: u4,
                ///  Sensor mask
                MASK: u4,
                ///  Next state index
                NEXTSTATE: u4,
                ///  Configure transition action
                PRSACT: u3,
                reserved16: u1,
                ///  Set interrupt flag
                SETIF: u1,
                padding: u15,
            }),
            ///  Scan results
            BUF0_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF1_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF2_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF3_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF4_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF5_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF6_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF7_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF8_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF9_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF10_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF11_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF12_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF13_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF14_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan results
            BUF15_DATA: mmio.Mmio(packed struct(u32) {
                ///  Scan result buffer
                DATA: u16,
                padding: u16,
            }),
            ///  Scan configuration
            CH0_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH0_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH0_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved720: [4]u8,
            ///  Scan configuration
            CH1_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH1_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH1_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved736: [4]u8,
            ///  Scan configuration
            CH2_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH2_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH2_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved752: [4]u8,
            ///  Scan configuration
            CH3_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH3_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH3_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved768: [4]u8,
            ///  Scan configuration
            CH4_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH4_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH4_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved784: [4]u8,
            ///  Scan configuration
            CH5_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH5_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH5_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved800: [4]u8,
            ///  Scan configuration
            CH6_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH6_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH6_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved816: [4]u8,
            ///  Scan configuration
            CH7_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH7_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH7_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved832: [4]u8,
            ///  Scan configuration
            CH8_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH8_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH8_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved848: [4]u8,
            ///  Scan configuration
            CH9_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH9_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH9_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved864: [4]u8,
            ///  Scan configuration
            CH10_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH10_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH10_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved880: [4]u8,
            ///  Scan configuration
            CH11_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH11_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH11_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved896: [4]u8,
            ///  Scan configuration
            CH12_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH12_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH12_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved912: [4]u8,
            ///  Scan configuration
            CH13_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH13_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH13_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved928: [4]u8,
            ///  Scan configuration
            CH14_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH14_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH14_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
            reserved944: [4]u8,
            ///  Scan configuration
            CH15_TIMING: mmio.Mmio(packed struct(u32) {
                ///  Set excitation time
                EXTIME: u6,
                ///  Set sample delay
                SAMPLEDLY: u7,
                ///  Set measure delay
                MEASUREDLY: u7,
                padding: u12,
            }),
            ///  Scan configuration
            CH15_INTERACT: mmio.Mmio(packed struct(u32) {
                ///  Set ACMP threshold
                ACMPTHRES: u12,
                ///  Select sample mode
                SAMPLE: u1,
                ///  Enable interrupt generation
                SETIF: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No interrupt is generated
                        NONE = 0x0,
                        ///  Set interrupt flag if the sensor triggers.
                        LEVEL = 0x1,
                        ///  Set interrupt flag on positive edge on the sensor state
                        POSEDGE = 0x2,
                        ///  Set interrupt flag on negative edge on the sensor state
                        NEGEDGE = 0x3,
                    },
                },
                ///  Set GPIO mode
                EXMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disabled
                        DISABLE = 0x0,
                        ///  Push Pull, GPIO is driven high
                        HIGH = 0x1,
                        ///  Push Pull, GPIO is driven low
                        LOW = 0x2,
                        ///  DAC output
                        DACOUT = 0x3,
                    },
                },
                ///  Select clock used for excitation timing
                EXCLK: u1,
                ///  Select clock used for timing of sample delay
                SAMPLECLK: u1,
                ///  Use alternative excite pin
                ALTEX: u1,
                padding: u12,
            }),
            ///  Scan configuration
            CH15_EVAL: mmio.Mmio(packed struct(u32) {
                ///  Decision threshold for counter
                COMPTHRES: u16,
                ///  Select mode for counter comparison
                COMP: u1,
                ///  Send result to decoder
                DECODE: u1,
                ///  Select if counter result should be stored
                STRSAMPLE: u1,
                ///  Enable inversion of result
                SCANRESINV: u1,
                padding: u12,
            }),
        };

        ///  RTC
        pub const RTC = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  RTC Enable
                EN: u1,
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                ///  Compare Channel 0 is Top Value
                COMP0TOP: u1,
                padding: u29,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u24,
                padding: u8,
            }),
            ///  Compare Value Register 0
            COMP0: mmio.Mmio(packed struct(u32) {
                ///  Compare Value 0
                COMP0: u24,
                padding: u8,
            }),
            ///  Compare Value Register 1
            COMP1: mmio.Mmio(packed struct(u32) {
                ///  Compare Value 1
                COMP1: u24,
                padding: u8,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag
                OF: u1,
                ///  Compare Match 0 Interrupt Flag
                COMP0: u1,
                ///  Compare Match 1 Interrupt Flag
                COMP1: u1,
                padding: u29,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set Overflow Interrupt Flag
                OF: u1,
                ///  Set Compare match 0 Interrupt Flag
                COMP0: u1,
                ///  Set Compare match 1 Interrupt Flag
                COMP1: u1,
                padding: u29,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear Overflow Interrupt Flag
                OF: u1,
                ///  Clear Compare match 0 Interrupt Flag
                COMP0: u1,
                ///  Clear Compare match 1 Interrupt Flag
                COMP1: u1,
                padding: u29,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Compare Match 0 Interrupt Enable
                COMP0: u1,
                ///  Compare Match 1 Interrupt Enable
                COMP1: u1,
                padding: u29,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  COMP0 Register Busy
                COMP0: u1,
                ///  COMP1 Register Busy
                COMP1: u1,
                padding: u29,
            }),
        };

        ///  LETIMER0
        pub const LETIMER0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Repeat Mode
                REPMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  When started, the LETIMER counts down until it is stopped by software.
                        FREE = 0x0,
                        ///  The counter counts REP0 times. When REP0 reaches zero, the counter stops.
                        ONESHOT = 0x1,
                        ///  The counter counts REP0 times. If REP1 has been written, it is loaded into REP0 when REP0 reaches zero. Else the counter stops
                        BUFFERED = 0x2,
                        ///  Both REP0 and REP1 are decremented when the LETIMER wraps around. The LETIMER counts until both REP0 and REP1 are zero
                        DOUBLE = 0x3,
                    },
                },
                ///  Underflow Output Action 0
                UFOA0: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LETn_O0 is held at its idle value as defined by OPOL0.
                        NONE = 0x0,
                        ///  LETn_O0 is toggled on CNT underflow.
                        TOGGLE = 0x1,
                        ///  LETn_O0 is held active for one LFACLKLETIMER0 clock cycle on CNT underflow. The output then returns to its idle value as defined by OPOL0.
                        PULSE = 0x2,
                        ///  LETn_O0 is set idle on CNT underflow, and active on compare match with COMP1
                        PWM = 0x3,
                    },
                },
                ///  Underflow Output Action 1
                UFOA1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LETn_O1 is held at its idle value as defined by OPOL1.
                        NONE = 0x0,
                        ///  LETn_O1 is toggled on CNT underflow.
                        TOGGLE = 0x1,
                        ///  LETn_O1 is held active for one LFACLKLETIMER0 clock cycle on CNT underflow. The output then returns to its idle value as defined by OPOL1.
                        PULSE = 0x2,
                        ///  LETn_O1 is set idle on CNT underflow, and active on compare match with COMP1
                        PWM = 0x3,
                    },
                },
                ///  Output 0 Polarity
                OPOL0: u1,
                ///  Output 1 Polarity
                OPOL1: u1,
                ///  Buffered Top
                BUFTOP: u1,
                ///  Compare Value 0 Is Top Value
                COMP0TOP: u1,
                ///  RTC Compare 0 Trigger Enable
                RTCC0TEN: u1,
                ///  RTC Compare 1 Trigger Enable
                RTCC1TEN: u1,
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                padding: u19,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Start LETIMER
                START: u1,
                ///  Stop LETIMER
                STOP: u1,
                ///  Clear LETIMER
                CLEAR: u1,
                ///  Clear Toggle Output 0
                CTO0: u1,
                ///  Clear Toggle Output 1
                CTO1: u1,
                padding: u27,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  LETIMER Running
                RUNNING: u1,
                padding: u31,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  Compare Value Register 0
            COMP0: mmio.Mmio(packed struct(u32) {
                ///  Compare Value 0
                COMP0: u16,
                padding: u16,
            }),
            ///  Compare Value Register 1
            COMP1: mmio.Mmio(packed struct(u32) {
                ///  Compare Value 1
                COMP1: u16,
                padding: u16,
            }),
            ///  Repeat Counter Register 0
            REP0: mmio.Mmio(packed struct(u32) {
                ///  Repeat Counter 0
                REP0: u8,
                padding: u24,
            }),
            ///  Repeat Counter Register 1
            REP1: mmio.Mmio(packed struct(u32) {
                ///  Repeat Counter 1
                REP1: u8,
                padding: u24,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Compare Match 0 Interrupt Flag
                COMP0: u1,
                ///  Compare Match 1 Interrupt Flag
                COMP1: u1,
                ///  Underflow Interrupt Flag
                UF: u1,
                ///  Repeat Counter 0 Interrupt Flag
                REP0: u1,
                ///  Repeat Counter 1 Interrupt Flag
                REP1: u1,
                padding: u27,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set Compare Match 0 Interrupt Flag
                COMP0: u1,
                ///  Set Compare Match 1 Interrupt Flag
                COMP1: u1,
                ///  Set Underflow Interrupt Flag
                UF: u1,
                ///  Set Repeat Counter 0 Interrupt Flag
                REP0: u1,
                ///  Set Repeat Counter 1 Interrupt Flag
                REP1: u1,
                padding: u27,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear Compare Match 0 Interrupt Flag
                COMP0: u1,
                ///  Clear Compare Match 1 Interrupt Flag
                COMP1: u1,
                ///  Clear Underflow Interrupt Flag
                UF: u1,
                ///  Clear Repeat Counter 0 Interrupt Flag
                REP0: u1,
                ///  Clear Repeat Counter 1 Interrupt Flag
                REP1: u1,
                padding: u27,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Compare Match 0 Interrupt Enable
                COMP0: u1,
                ///  Compare Match 1 Interrupt Enable
                COMP1: u1,
                ///  Underflow Interrupt Enable
                UF: u1,
                ///  Repeat Counter 0 Interrupt Enable
                REP0: u1,
                ///  Repeat Counter 1 Interrupt Enable
                REP1: u1,
                padding: u27,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  CMD Register Busy
                CMD: u1,
                ///  COMP0 Register Busy
                COMP0: u1,
                ///  COMP1 Register Busy
                COMP1: u1,
                ///  REP0 Register Busy
                REP0: u1,
                ///  REP1 Register Busy
                REP1: u1,
                padding: u26,
            }),
            reserved64: [8]u8,
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  Output 0 Pin Enable
                OUT0PEN: u1,
                ///  Output 1 Pin Enable
                OUT1PEN: u1,
                reserved8: u6,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        _,
                    },
                },
                padding: u21,
            }),
        };

        ///  EBI
        pub const EBI = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  EBI_AD drives 8 bit data, 8 bit address, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A8 = 0x0,
                        ///  EBI_AD drives 16 bit data, 16 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16A16ALE = 0x1,
                        ///  EBI_AD drives 8 bit data, 24 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A24ALE = 0x2,
                        ///  EBI_AD drives 16 bit data, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16 = 0x3,
                    },
                },
                ///  Mode 1
                MODE1: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  EBI_AD drives 8 bit data, 8 bit address, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A8 = 0x0,
                        ///  EBI_AD drives 16 bit data, 16 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16A16ALE = 0x1,
                        ///  EBI_AD drives 8 bit data, 24 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A24ALE = 0x2,
                        ///  EBI_AD drives 16 bit data, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16 = 0x3,
                    },
                },
                ///  Mode 2
                MODE2: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  EBI_AD drives 8 bit data, 8 bit address, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A8 = 0x0,
                        ///  EBI_AD drives 16 bit data, 16 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16A16ALE = 0x1,
                        ///  EBI_AD drives 8 bit data, 24 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A24ALE = 0x2,
                        ///  EBI_AD drives 16 bit data, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16 = 0x3,
                    },
                },
                ///  Mode 3
                MODE3: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  EBI_AD drives 8 bit data, 8 bit address, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A8 = 0x0,
                        ///  EBI_AD drives 16 bit data, 16 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16A16ALE = 0x1,
                        ///  EBI_AD drives 8 bit data, 24 bit address, ALE is used for address latching. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D8A24ALE = 0x2,
                        ///  EBI_AD drives 16 bit data, ALE not used. Extended address bits can be enabled on EBI_A in the EBI_ROUTE register.
                        D16 = 0x3,
                    },
                },
                ///  Bank 0 Enable
                BANK0EN: u1,
                ///  Bank 1 Enable
                BANK1EN: u1,
                ///  Bank 2 Enable
                BANK2EN: u1,
                ///  Bank 3 Enable
                BANK3EN: u1,
                ///  No idle cycle insertion on bank 0.
                NOIDLE: u1,
                ///  No idle cycle insertion on bank 1.
                NOIDLE1: u1,
                ///  No idle cycle insertion on bank 2.
                NOIDLE2: u1,
                ///  No idle cycle insertion on bank 3.
                NOIDLE3: u1,
                ///  ARDY Enable
                ARDYEN: u1,
                ///  ARDY Timeout Disable
                ARDYTODIS: u1,
                ///  ARDY Enable for bank 1
                ARDY1EN: u1,
                ///  ARDY Timeout Disable for bank 1
                ARDYTO1DIS: u1,
                ///  ARDY Enable for bank 2
                ARDY2EN: u1,
                ///  ARDY Timeout Disable for bank 2
                ARDYTO2DIS: u1,
                ///  ARDY Enable for bank 3
                ARDY3EN: u1,
                ///  ARDY Timeout Disable for bank 3
                ARDYTO3DIS: u1,
                ///  Byte Lane Enable for bank 0
                BL: u1,
                ///  Byte Lane Enable for bank 1
                BL1: u1,
                ///  Byte Lane Enable for bank 2
                BL2: u1,
                ///  Byte Lane Enable for bank 3
                BL3: u1,
                reserved30: u2,
                ///  Individual Timing Set, Line Polarity and Mode Definition Enable
                ITS: u1,
                ///  Alternative Address Map Enable
                ALTMAP: u1,
            }),
            ///  Address Timing Register
            ADDRTIMING: mmio.Mmio(packed struct(u32) {
                ///  Address Setup Time
                ADDRSETUP: u2,
                reserved8: u6,
                ///  Address Hold Time
                ADDRHOLD: u2,
                reserved28: u18,
                ///  Half Cycle ALE Strobe Duration Enable
                HALFALE: u1,
                padding: u3,
            }),
            ///  Read Timing Register
            RDTIMING: mmio.Mmio(packed struct(u32) {
                ///  Read Setup Time
                RDSETUP: u2,
                reserved8: u6,
                ///  Read Strobe Time
                RDSTRB: u6,
                reserved16: u2,
                ///  Read Hold Time
                RDHOLD: u2,
                reserved28: u10,
                ///  Half Cycle REn Strobe Duration Enable
                HALFRE: u1,
                ///  Prefetch Enable
                PREFETCH: u1,
                ///  Page Mode Access Enable
                PAGEMODE: u1,
                padding: u1,
            }),
            ///  Write Timing Register
            WRTIMING: mmio.Mmio(packed struct(u32) {
                ///  Write Setup Time
                WRSETUP: u2,
                reserved8: u6,
                ///  Write Strobe Time
                WRSTRB: u6,
                reserved16: u2,
                ///  Write Hold Time
                WRHOLD: u2,
                reserved28: u10,
                ///  Half Cycle WEn Strobe Duration Enable
                HALFWE: u1,
                ///  Write Buffer Disable
                WBUFDIS: u1,
                padding: u2,
            }),
            ///  Polarity Register
            POLARITY: mmio.Mmio(packed struct(u32) {
                ///  Chip Select Polarity
                CSPOL: u1,
                ///  Read Enable Polarity
                REPOL: u1,
                ///  Write Enable Polarity
                WEPOL: u1,
                ///  Address Latch Polarity
                ALEPOL: u1,
                ///  ARDY Polarity
                ARDYPOL: u1,
                ///  BL Polarity
                BLPOL: u1,
                padding: u26,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  EBI Pin Enable
                EBIPEN: u1,
                ///  EBI_CS0 Pin Enable
                CS0PEN: u1,
                ///  EBI_CS1 Pin Enable
                CS1PEN: u1,
                ///  EBI_CS2 Pin Enable
                CS2PEN: u1,
                ///  EBI_CS3 Pin Enable
                CS3PEN: u1,
                ///  EBI_ALE Pin Enable
                ALEPEN: u1,
                ///  EBI_ARDY Pin Enable
                ARDYPEN: u1,
                ///  EBI_BL[1:0] Pin Enable
                BLPEN: u1,
                reserved12: u4,
                ///  NANDRE and NANDWE Pin Enable
                NANDPEN: u1,
                reserved16: u3,
                ///  Sets the lower bound for EBI_A enabling
                ALB: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Address lines from EBI_A[0] and upwards can be enabled via APEN.
                        A0 = 0x0,
                        ///  Address lines from EBI_A[8] and upwards can be enabled via APEN.
                        A8 = 0x1,
                        ///  Address lines from EBI_A[16] and upwards can be enabled via APEN.
                        A16 = 0x2,
                        ///  Address lines from EBI_A[24] and upwards can be enabled via APEN.
                        A24 = 0x3,
                    },
                },
                ///  EBI_A Pin Enable
                APEN: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  All EBI_A pins are disabled.
                        A0 = 0x0,
                        ///  EBI_A[4:L] pins enabled.
                        A5 = 0x5,
                        ///  EBI_A[5:L] pins enabled.
                        A6 = 0x6,
                        ///  EBI_A[6:L] pins enabled.
                        A7 = 0x7,
                        ///  EBI_A[7:L] pins enabled.
                        A8 = 0x8,
                        ///  EBI_A[8:L] pins enabled.
                        A9 = 0x9,
                        ///  EBI_A[9:L] pins enabled.
                        A10 = 0xa,
                        ///  EBI_A[10:L] pins enabled.
                        A11 = 0xb,
                        ///  EBI_A[11:L] pins enabled.
                        A12 = 0xc,
                        ///  EBI_A[12:L] pins enabled.
                        A13 = 0xd,
                        ///  EBI_A[13:L] pins enabled.
                        A14 = 0xe,
                        ///  EBI_A[14:L] pins enabled.
                        A15 = 0xf,
                        ///  EBI_A[15:L] pins enabled.
                        A16 = 0x10,
                        ///  EBI_A[16:L] pins enabled.
                        A17 = 0x11,
                        ///  EBI_A[17:L] pins enabled.
                        A18 = 0x12,
                        ///  EBI_A[18:L] pins enabled.
                        A19 = 0x13,
                        ///  EBI_A[19:L] pins enabled.
                        A20 = 0x14,
                        ///  EBI_A[20:L] pins enabled.
                        A21 = 0x15,
                        ///  EBI_A[21:L] pins enabled.
                        A22 = 0x16,
                        ///  EBI_A[22:L] pins enabled.
                        A23 = 0x17,
                        ///  EBI_A[23:L] pins enabled.
                        A24 = 0x18,
                        ///  EBI_A[24:L] pins enabled.
                        A25 = 0x19,
                        ///  EBI_A[25:L] pins enabled.
                        A26 = 0x1a,
                        ///  EBI_A[26:L] pins enabled.
                        A27 = 0x1b,
                        ///  EBI_A[27:L] pins enabled.
                        A28 = 0x1c,
                        _,
                    },
                },
                reserved24: u1,
                ///  EBI_TFT Pin Enable
                TFTPEN: u1,
                ///  EBI_TFT Pin Enable
                DATAENPEN: u1,
                ///  EBI_CSTFT Pin Enable
                CSTFTPEN: u1,
                reserved28: u1,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        _,
                    },
                },
                padding: u1,
            }),
            ///  Address Timing Register 1
            ADDRTIMING1: mmio.Mmio(packed struct(u32) {
                ///  Address Setup Time
                ADDRSETUP: u2,
                reserved8: u6,
                ///  Address Hold Time
                ADDRHOLD: u2,
                reserved28: u18,
                ///  Half Cycle ALE Strobe Duration Enable
                HALFALE: u1,
                padding: u3,
            }),
            ///  Read Timing Register 1
            RDTIMING1: mmio.Mmio(packed struct(u32) {
                ///  Read Setup Time
                RDSETUP: u2,
                reserved8: u6,
                ///  Read Strobe Time
                RDSTRB: u6,
                reserved16: u2,
                ///  Read Hold Time
                RDHOLD: u2,
                reserved28: u10,
                ///  Half Cycle REn Strobe Duration Enable
                HALFRE: u1,
                ///  Prefetch Enable
                PREFETCH: u1,
                ///  Page Mode Access Enable
                PAGEMODE: u1,
                padding: u1,
            }),
            ///  Write Timing Register 1
            WRTIMING1: mmio.Mmio(packed struct(u32) {
                ///  Write Setup Time
                WRSETUP: u2,
                reserved8: u6,
                ///  Write Strobe Time
                WRSTRB: u6,
                reserved16: u2,
                ///  Write Hold Time
                WRHOLD: u2,
                reserved28: u10,
                ///  Half Cycle WEn Strobe Duration Enable
                HALFWE: u1,
                ///  Write Buffer Disable
                WBUFDIS: u1,
                padding: u2,
            }),
            ///  Polarity Register 1
            POLARITY1: mmio.Mmio(packed struct(u32) {
                ///  Chip Select Polarity
                CSPOL: u1,
                ///  Read Enable Polarity
                REPOL: u1,
                ///  Write Enable Polarity
                WEPOL: u1,
                ///  Address Latch Polarity
                ALEPOL: u1,
                ///  ARDY Polarity
                ARDYPOL: u1,
                ///  BL Polarity
                BLPOL: u1,
                padding: u26,
            }),
            ///  Address Timing Register 2
            ADDRTIMING2: mmio.Mmio(packed struct(u32) {
                ///  Address Setup Time
                ADDRSETUP: u2,
                reserved8: u6,
                ///  Address Hold Time
                ADDRHOLD: u2,
                reserved28: u18,
                ///  Half Cycle ALE Strobe Duration Enable
                HALFALE: u1,
                padding: u3,
            }),
            ///  Read Timing Register 2
            RDTIMING2: mmio.Mmio(packed struct(u32) {
                ///  Read Setup Time
                RDSETUP: u2,
                reserved8: u6,
                ///  Read Strobe Time
                RDSTRB: u6,
                reserved16: u2,
                ///  Read Hold Time
                RDHOLD: u2,
                reserved28: u10,
                ///  Half Cycle REn Strobe Duration Enable
                HALFRE: u1,
                ///  Prefetch Enable
                PREFETCH: u1,
                ///  Page Mode Access Enable
                PAGEMODE: u1,
                padding: u1,
            }),
            ///  Write Timing Register 2
            WRTIMING2: mmio.Mmio(packed struct(u32) {
                ///  Write Setup Time
                WRSETUP: u2,
                reserved8: u6,
                ///  Write Strobe Time
                WRSTRB: u6,
                reserved16: u2,
                ///  Write Hold Time
                WRHOLD: u2,
                reserved28: u10,
                ///  Half Cycle WEn Strobe Duration Enable
                HALFWE: u1,
                ///  Write Buffer Disable
                WBUFDIS: u1,
                padding: u2,
            }),
            ///  Polarity Register 2
            POLARITY2: mmio.Mmio(packed struct(u32) {
                ///  Chip Select Polarity
                CSPOL: u1,
                ///  Read Enable Polarity
                REPOL: u1,
                ///  Write Enable Polarity
                WEPOL: u1,
                ///  Address Latch Polarity
                ALEPOL: u1,
                ///  ARDY Polarity
                ARDYPOL: u1,
                ///  BL Polarity
                BLPOL: u1,
                padding: u26,
            }),
            ///  Address Timing Register 3
            ADDRTIMING3: mmio.Mmio(packed struct(u32) {
                ///  Address Setup Time
                ADDRSETUP: u2,
                reserved8: u6,
                ///  Address Hold Time
                ADDRHOLD: u2,
                reserved28: u18,
                ///  Half Cycle ALE Strobe Duration Enable
                HALFALE: u1,
                padding: u3,
            }),
            ///  Read Timing Register 3
            RDTIMING3: mmio.Mmio(packed struct(u32) {
                ///  Read Setup Time
                RDSETUP: u2,
                reserved8: u6,
                ///  Read Strobe Time
                RDSTRB: u6,
                reserved16: u2,
                ///  Read Hold Time
                RDHOLD: u2,
                reserved28: u10,
                ///  Half Cycle REn Strobe Duration Enable
                HALFRE: u1,
                ///  Prefetch Enable
                PREFETCH: u1,
                ///  Page Mode Access Enable
                PAGEMODE: u1,
                padding: u1,
            }),
            ///  Write Timing Register 3
            WRTIMING3: mmio.Mmio(packed struct(u32) {
                ///  Write Setup Time
                WRSETUP: u2,
                reserved8: u6,
                ///  Write Strobe Time
                WRSTRB: u6,
                reserved16: u2,
                ///  Write Hold Time
                WRHOLD: u2,
                reserved28: u10,
                ///  Half Cycle WEn Strobe Duration Enable
                HALFWE: u1,
                ///  Write Buffer Disable
                WBUFDIS: u1,
                padding: u2,
            }),
            ///  Polarity Register 3
            POLARITY3: mmio.Mmio(packed struct(u32) {
                ///  Chip Select Polarity
                CSPOL: u1,
                ///  Read Enable Polarity
                REPOL: u1,
                ///  Write Enable Polarity
                WEPOL: u1,
                ///  Address Latch Polarity
                ALEPOL: u1,
                ///  ARDY Polarity
                ARDYPOL: u1,
                ///  BL Polarity
                BLPOL: u1,
                padding: u26,
            }),
            ///  Page Control Register
            PAGECTRL: mmio.Mmio(packed struct(u32) {
                ///  Page Length
                PAGELEN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  4 members in a page.
                        MEMBER4 = 0x0,
                        ///  8 members in a page.
                        MEMBER8 = 0x1,
                        ///  16 members in a page.
                        MEMBER16 = 0x2,
                        ///  32 members in a page.
                        MEMBER32 = 0x3,
                    },
                },
                reserved4: u2,
                ///  Intrapage hit only on incremental addresses
                INCHIT: u1,
                reserved8: u3,
                ///  Page Read Access Time
                RDPA: u3,
                reserved20: u9,
                ///  Maximum Page Open Time.
                KEEPOPEN: u7,
                padding: u5,
            }),
            ///  NAND Control Register
            NANDCTRL: mmio.Mmio(packed struct(u32) {
                ///  NAND Flash control enable
                EN: u1,
                reserved4: u3,
                ///  NAND Flash Bank
                BANKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Memory bank 0 is connected to a NAND Flash device.
                        BANK0 = 0x0,
                        ///  Memory bank 1 is connected to a NAND Flash device.
                        BANK1 = 0x1,
                        ///  Memory bank 2 is connected to a NAND Flash device.
                        BANK2 = 0x2,
                        ///  Memory bank 3 is connected to a NAND Flash device.
                        BANK3 = 0x3,
                    },
                },
                padding: u26,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Error Correction Code Generation Start
                ECCSTART: u1,
                ///  Error Correction Code Generation Stop
                ECCSTOP: u1,
                ///  Error Correction Code Clear
                ECCCLEAR: u1,
                padding: u29,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  EBI Busy with AHB Transaction.
                AHBACT: u1,
                reserved4: u3,
                ///  EBI ECC Generation Active.
                ECCACT: u1,
                reserved8: u3,
                ///  EBI_TFTPIXEL0 is empty.
                TFTPIXEL0EMPTY: u1,
                ///  EBI_TFTPIXEL1 is empty.
                TFTPIXEL1EMPTY: u1,
                ///  EBI_TFTPIXEL0 is full.
                TFTPIXELFULL: u1,
                reserved12: u1,
                ///  EBI Busy with Direct Drive Transactions.
                DDACT: u1,
                ///  EBI_TFTDD register is empty.
                TFTDDEMPTY: u1,
                padding: u18,
            }),
            ///  ECC Parity register
            ECCPARITY: mmio.Mmio(packed struct(u32) {
                ///  ECC Parity Data
                ECCPARITY: u32,
            }),
            ///  TFT Control Register
            TFTCTRL: mmio.Mmio(packed struct(u32) {
                ///  TFT Direct Drive Mode
                DD: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Direct Drive is disabled.
                        DISABLED = 0x0,
                        ///  Direct Drive from internal memory enabled and started.
                        INTERNAL = 0x1,
                        ///  Direct Drive from external memory enabled and started.
                        EXTERNAL = 0x2,
                        _,
                    },
                },
                ///  TFT Mask and Blend Mode
                MASKBLEND: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Masking and Blending are disabled.
                        DISABLED = 0x0,
                        ///  Internal Masking is enabled.
                        IMASK = 0x1,
                        ///  Internal Alpha Blending is enabled.
                        IALPHA = 0x2,
                        ///  Internal Masking and Alpha Blending are enabled.
                        IMASKIALPHA = 0x3,
                        ///  External Masking is enabled.
                        EMASK = 0x5,
                        ///  External Alpha Blending is enabled.
                        EALPHA = 0x6,
                        ///  External Masking and Alpha Blending are enabled.
                        EMASKEALPHA = 0x7,
                        _,
                    },
                },
                reserved8: u3,
                ///  TFT EBI_DCLK Shift Enable
                SHIFTDCLKEN: u1,
                ///  TFT Frame Base Copy Trigger
                FBCTRIG: u1,
                ///  Interleave Mode
                INTERLEAVE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Allow unlimited interleaved EBI accesses per EBI_DCLK period. This can cause jitter on the EBI_DCLK
                        UNLIMITED = 0x0,
                        ///  Allow 1 interleaved EBI access per EBI_DCLK period.
                        ONEPERDCLK = 0x1,
                        ///  Only allow EBI accesses during TFT porches.
                        PORCH = 0x2,
                        _,
                    },
                },
                ///  Masking/Alpha Blending Color1 Source
                COLOR1SRC: u1,
                reserved16: u3,
                ///  TFT Transaction Width
                WIDTH: u1,
                reserved20: u3,
                ///  Graphics Bank
                BANKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Memory bank 0 is used for Direct Drive, Masking, and Alpha Blending.
                        BANK0 = 0x0,
                        ///  Memory bank 1 is used for Direct Drive, Masking, and Alpha Blending.
                        BANK1 = 0x1,
                        ///  Memory bank 2 is used for Direct Drive, Masking, and Alpha Blending.
                        BANK2 = 0x2,
                        ///  Memory bank 3 is used for Direct Drive, Masking, and Alpha Blending.
                        BANK3 = 0x3,
                    },
                },
                reserved24: u2,
                ///  TFT RGB Mode
                RGBMODE: u1,
                padding: u7,
            }),
            ///  TFT Status Register
            TFTSTATUS: mmio.Mmio(packed struct(u32) {
                ///  Horizontal Count
                HCNT: u11,
                reserved16: u5,
                ///  Vertical Count
                VCNT: u11,
                padding: u5,
            }),
            ///  TFT Frame Base Register
            TFTFRAMEBASE: mmio.Mmio(packed struct(u32) {
                ///  Frame Base Address
                FRAMEBASE: u28,
                padding: u4,
            }),
            ///  TFT Stride Register
            TFTSTRIDE: mmio.Mmio(packed struct(u32) {
                ///  Horizontal Stride
                HSTRIDE: u12,
                padding: u20,
            }),
            ///  TFT Size Register
            TFTSIZE: mmio.Mmio(packed struct(u32) {
                ///  Horizontal Size (excluding porches)
                HSZ: u10,
                reserved16: u6,
                ///  Vertical Size (excluding porches)
                VSZ: u10,
                padding: u6,
            }),
            ///  TFT Horizontal Porch Register
            TFTHPORCH: mmio.Mmio(packed struct(u32) {
                ///  Horizontal Synchronization Pulse Width
                HSYNC: u7,
                reserved8: u1,
                ///  Horizontal Front Porch Size
                HFPORCH: u8,
                reserved18: u2,
                ///  Horizontal Back Porch Size
                HBPORCH: u8,
                reserved28: u2,
                ///  HSYNC Start Delay
                HSYNCSTART: u2,
                padding: u2,
            }),
            ///  TFT Vertical Porch Register
            TFTVPORCH: mmio.Mmio(packed struct(u32) {
                ///  Vertical Synchronization Pulse Width
                VSYNC: u7,
                reserved8: u1,
                ///  Vertical Front Porch Size
                VFPORCH: u8,
                reserved18: u2,
                ///  Vertical Back Porch Size
                VBPORCH: u8,
                padding: u6,
            }),
            ///  TFT Timing Register
            TFTTIMING: mmio.Mmio(packed struct(u32) {
                ///  TFT Direct Drive Transaction (EBI_DCLK) Period
                DCLKPERIOD: u11,
                reserved12: u1,
                ///  TFT Direct Drive Transaction Start
                TFTSTART: u11,
                reserved24: u1,
                ///  TFT Setup Time
                TFTSETUP: u2,
                reserved28: u2,
                ///  TFT Hold Time
                TFTHOLD: u2,
                padding: u2,
            }),
            ///  TFT Polarity Register
            TFTPOLARITY: mmio.Mmio(packed struct(u32) {
                ///  TFT Chip Select Polarity
                CSPOL: u1,
                ///  TFT DCLK Polarity
                DCLKPOL: u1,
                ///  TFT DATAEN Polarity
                DATAENPOL: u1,
                ///  Address Latch Polarity
                HSYNCPOL: u1,
                ///  VSYNC Polarity
                VSYNCPOL: u1,
                padding: u27,
            }),
            ///  TFT Direct Drive Data Register
            TFTDD: mmio.Mmio(packed struct(u32) {
                ///  TFT Direct Drive Data from Internal Memory
                DATA: u16,
                padding: u16,
            }),
            ///  TFT Alpha Blending Register
            TFTALPHA: mmio.Mmio(packed struct(u32) {
                ///  TFT Alpha Blending Factor
                ALPHA: u9,
                padding: u23,
            }),
            ///  TFT Pixel 0 Register
            TFTPIXEL0: mmio.Mmio(packed struct(u32) {
                ///  RGB data.
                DATA: u16,
                padding: u16,
            }),
            ///  TFT Pixel 1 Register
            TFTPIXEL1: mmio.Mmio(packed struct(u32) {
                ///  RGB data.
                DATA: u16,
                padding: u16,
            }),
            ///  TFT Alpha Blending Result Pixel Register
            TFTPIXEL: mmio.Mmio(packed struct(u32) {
                ///  Alpha Blending Result
                DATA: u16,
                padding: u16,
            }),
            ///  TFT Masking Register
            TFTMASK: mmio.Mmio(packed struct(u32) {
                ///  TFT Mask Value
                TFTMASK: u16,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Vertical Sync Interrupt Flag
                VSYNC: u1,
                ///  Horizontal Sync Interrupt Flag
                HSYNC: u1,
                ///  Vertical Back Porch Interrupt Flag
                VBPORCH: u1,
                ///  Vertical Front Porch Interrupt Flag
                VFPORCH: u1,
                ///  Direct Drive Data Empty Interrupt Flag
                DDEMPTY: u1,
                ///  Direct Drive Jitter Interrupt Flag
                DDJIT: u1,
                padding: u26,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Vertical Sync Interrupt Flag Set
                VSYNC: u1,
                ///  Horizontal Sync Interrupt Flag Set
                HSYNC: u1,
                ///  Vertical Back Porch Interrupt Flag Set
                VBPORCH: u1,
                ///  Vertical Front Porch Interrupt Flag Set
                VFPORCH: u1,
                ///  Direct Drive Data Empty Interrupt Flag Set
                DDEMPTY: u1,
                ///  Direct Drive Jitter Interrupt Flag Set
                DDJIT: u1,
                padding: u26,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Vertical Sync Interrupt Flag Clear
                VSYNC: u1,
                ///  Horizontal Sync Interrupt Flag Clear
                HSYNC: u1,
                ///  Vertical Back Porch Interrupt Flag Clear
                VBPORCH: u1,
                ///  Vertical Front Porch Interrupt Flag Clear
                VFPORCH: u1,
                ///  Direct Drive Data Empty Interrupt Flag Clear
                DDEMPTY: u1,
                ///  Direct Drive Jitter Interrupt Flag Clear
                DDJIT: u1,
                padding: u26,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Vertical Sync Interrupt Enable
                VSYNC: u1,
                ///  Horizontal Sync Interrupt Enable
                HSYNC: u1,
                ///  Vertical Back Porch Interrupt Enable
                VBPORCH: u1,
                ///  Vertical Front Porch Interrupt Enable
                VFPORCH: u1,
                ///  Direct Drive Data Empty Interrupt Enable
                DDEMPTY: u1,
                ///  Direct Drive Jitter Interrupt Enable
                DDJIT: u1,
                padding: u26,
            }),
        };

        ///  USART0
        pub const USART0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  USART Synchronous Mode
                SYNC: u1,
                ///  Loopback Enable
                LOOPBK: u1,
                ///  Collision Check Enable
                CCEN: u1,
                ///  Multi-Processor Mode
                MPM: u1,
                ///  Multi-Processor Address-Bit
                MPAB: u1,
                ///  Oversampling
                OVS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Regular UART mode with 16X oversampling in asynchronous mode
                        X16 = 0x0,
                        ///  Double speed with 8X oversampling in asynchronous mode
                        X8 = 0x1,
                        ///  6X oversampling in asynchronous mode
                        X6 = 0x2,
                        ///  Quadruple speed with 4X oversampling in asynchronous mode
                        X4 = 0x3,
                    },
                },
                reserved8: u1,
                ///  Clock Polarity
                CLKPOL: u1,
                ///  Clock Edge For Setup/Sample
                CLKPHA: u1,
                ///  Most Significant Bit First
                MSBF: u1,
                ///  Action On Slave-Select In Master Mode
                CSMA: u1,
                ///  TX Buffer Interrupt Level
                TXBIL: u1,
                ///  Receiver Input Invert
                RXINV: u1,
                ///  Transmitter output Invert
                TXINV: u1,
                ///  Chip Select Invert
                CSINV: u1,
                ///  Automatic Chip Select
                AUTOCS: u1,
                ///  Automatic TX Tristate
                AUTOTRI: u1,
                ///  SmartCard Mode
                SCMODE: u1,
                ///  SmartCard Retransmit
                SCRETRANS: u1,
                ///  Skip Parity Error Frames
                SKIPPERRF: u1,
                ///  Bit 8 Default Value
                BIT8DV: u1,
                ///  Halt DMA On Error
                ERRSDMA: u1,
                ///  Disable RX On Error
                ERRSRX: u1,
                ///  Disable TX On Error
                ERRSTX: u1,
                reserved26: u1,
                ///  TX Delay Transmission
                TXDELAY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Frames are transmitted immediately
                        NONE = 0x0,
                        ///  Transmission of new frames are delayed by a single baud period
                        SINGLE = 0x1,
                        ///  Transmission of new frames are delayed by two baud periods
                        DOUBLE = 0x2,
                        ///  Transmission of new frames are delayed by three baud periods
                        TRIPLE = 0x3,
                    },
                },
                ///  Byteswap In Double Accesses
                BYTESWAP: u1,
                ///  Always Transmit When RX Not Full
                AUTOTX: u1,
                ///  Majority Vote Disable
                MVDIS: u1,
                padding: u1,
            }),
            ///  USART Frame Format Register
            FRAME: mmio.Mmio(packed struct(u32) {
                ///  Data-Bit Mode
                DATABITS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Each frame contains 4 data bits
                        FOUR = 0x1,
                        ///  Each frame contains 5 data bits
                        FIVE = 0x2,
                        ///  Each frame contains 6 data bits
                        SIX = 0x3,
                        ///  Each frame contains 7 data bits
                        SEVEN = 0x4,
                        ///  Each frame contains 8 data bits
                        EIGHT = 0x5,
                        ///  Each frame contains 9 data bits
                        NINE = 0x6,
                        ///  Each frame contains 10 data bits
                        TEN = 0x7,
                        ///  Each frame contains 11 data bits
                        ELEVEN = 0x8,
                        ///  Each frame contains 12 data bits
                        TWELVE = 0x9,
                        ///  Each frame contains 13 data bits
                        THIRTEEN = 0xa,
                        ///  Each frame contains 14 data bits
                        FOURTEEN = 0xb,
                        ///  Each frame contains 15 data bits
                        FIFTEEN = 0xc,
                        ///  Each frame contains 16 data bits
                        SIXTEEN = 0xd,
                        _,
                    },
                },
                reserved8: u4,
                ///  Parity-Bit Mode
                PARITY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Parity bits are not used
                        NONE = 0x0,
                        ///  Even parity are used. Parity bits are automatically generated and checked by hardware.
                        EVEN = 0x2,
                        ///  Odd parity is used. Parity bits are automatically generated and checked by hardware.
                        ODD = 0x3,
                        _,
                    },
                },
                reserved12: u2,
                ///  Stop-Bit Mode
                STOPBITS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The transmitter generates a half stop bit. Stop-bits are not verified by receiver
                        HALF = 0x0,
                        ///  One stop bit is generated and verified
                        ONE = 0x1,
                        ///  The transmitter generates one and a half stop bit. The receiver verifies the first stop bit
                        ONEANDAHALF = 0x2,
                        ///  The transmitter generates two stop bits. The receiver checks the first stop-bit only
                        TWO = 0x3,
                    },
                },
                padding: u18,
            }),
            ///  USART Trigger Control register
            TRIGCTRL: mmio.Mmio(packed struct(u32) {
                ///  Trigger PRS Channel Select
                TSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Receive Trigger Enable
                RXTEN: u1,
                ///  Transmit Trigger Enable
                TXTEN: u1,
                ///  AUTOTX Trigger Enable
                AUTOTXTEN: u1,
                padding: u25,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RXEN: u1,
                ///  Receiver Disable
                RXDIS: u1,
                ///  Transmitter Enable
                TXEN: u1,
                ///  Transmitter Disable
                TXDIS: u1,
                ///  Master Enable
                MASTEREN: u1,
                ///  Master Disable
                MASTERDIS: u1,
                ///  Receiver Block Enable
                RXBLOCKEN: u1,
                ///  Receiver Block Disable
                RXBLOCKDIS: u1,
                ///  Transmitter Tristate Enable
                TXTRIEN: u1,
                ///  Transmitter Tristate Disable
                TXTRIDIS: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear RX
                CLEARRX: u1,
                padding: u20,
            }),
            ///  USART Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable Status
                RXENS: u1,
                ///  Transmitter Enable Status
                TXENS: u1,
                ///  SPI Master Mode
                MASTER: u1,
                ///  Block Incoming Data
                RXBLOCK: u1,
                ///  Transmitter Tristated
                TXTRI: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                ///  RX FIFO Full
                RXFULL: u1,
                ///  TX Buffer Expects Double Right Data
                TXBDRIGHT: u1,
                ///  TX Buffer Expects Single Right Data
                TXBSRIGHT: u1,
                ///  RX Data Right
                RXDATAVRIGHT: u1,
                ///  RX Full of Right Data
                RXFULLRIGHT: u1,
                padding: u19,
            }),
            ///  Clock Control Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                reserved6: u6,
                ///  Fractional Clock Divider
                DIV: u15,
                padding: u11,
            }),
            ///  RX Buffer Data Extended Register
            RXDATAX: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u9,
                reserved14: u5,
                ///  Data Parity Error
                PERR: u1,
                ///  Data Framing Error
                FERR: u1,
                padding: u16,
            }),
            ///  RX Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  RX Buffer Double Data Extended Register
            RXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u9,
                reserved14: u5,
                ///  Data Parity Error 0
                PERR0: u1,
                ///  Data Framing Error 0
                FERR0: u1,
                ///  RX Data 1
                RXDATA1: u9,
                reserved30: u5,
                ///  Data Parity Error 1
                PERR1: u1,
                ///  Data Framing Error 1
                FERR1: u1,
            }),
            ///  RX FIFO Double Data Register
            RXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u8,
                ///  RX Data 1
                RXDATA1: u8,
                padding: u16,
            }),
            ///  RX Buffer Data Extended Peek Register
            RXDATAXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u9,
                reserved14: u5,
                ///  Data Parity Error Peek
                PERRP: u1,
                ///  Data Framing Error Peek
                FERRP: u1,
                padding: u16,
            }),
            ///  RX Buffer Double Data Extended Peek Register
            RXDOUBLEXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0 Peek
                RXDATAP0: u9,
                reserved14: u5,
                ///  Data Parity Error 0 Peek
                PERRP0: u1,
                ///  Data Framing Error 0 Peek
                FERRP0: u1,
                ///  RX Data 1 Peek
                RXDATAP1: u9,
                reserved30: u5,
                ///  Data Parity Error 1 Peek
                PERRP1: u1,
                ///  Data Framing Error 1 Peek
                FERRP1: u1,
            }),
            ///  TX Buffer Data Extended Register
            TXDATAX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATAX: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT: u1,
                ///  Transmit Data As Break
                TXBREAK: u1,
                ///  Clear TXEN After Transmission
                TXDISAT: u1,
                ///  Enable RX After Transmission
                RXENAT: u1,
                padding: u16,
            }),
            ///  TX Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  TX Buffer Double Data Extended Register
            TXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT0: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT0: u1,
                ///  Transmit Data As Break
                TXBREAK0: u1,
                ///  Clear TXEN After Transmission
                TXDISAT0: u1,
                ///  Enable RX After Transmission
                RXENAT0: u1,
                ///  TX Data
                TXDATA1: u9,
                reserved27: u2,
                ///  Unblock RX After Transmission
                UBRXAT1: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT1: u1,
                ///  Transmit Data As Break
                TXBREAK1: u1,
                ///  Clear TXEN After Transmission
                TXDISAT1: u1,
                ///  Enable RX After Transmission
                RXENAT1: u1,
            }),
            ///  TX Buffer Double Data Register
            TXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u8,
                ///  TX Data
                TXDATA1: u8,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Flag
                TXC: u1,
                ///  TX Buffer Level Interrupt Flag
                TXBL: u1,
                ///  RX Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  RX Overflow Interrupt Flag
                RXOF: u1,
                ///  RX Underflow Interrupt Flag
                RXUF: u1,
                ///  TX Overflow Interrupt Flag
                TXOF: u1,
                ///  TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Parity Error Interrupt Flag
                PERR: u1,
                ///  Framing Error Interrupt Flag
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Set RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Set RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Set RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Set TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Set TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Set Parity Error Interrupt Flag
                PERR: u1,
                ///  Set Framing Error Interrupt Flag
                FERR: u1,
                ///  Set Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Set Slave-Select in Master mode Interrupt Flag
                SSM: u1,
                ///  Set Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Clear RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Clear RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Clear RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Clear Parity Error Interrupt Flag
                PERR: u1,
                ///  Clear Framing Error Interrupt Flag
                FERR: u1,
                ///  Clear Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Clear Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Clear Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Enable
                TXC: u1,
                ///  TX Buffer Level Interrupt Enable
                TXBL: u1,
                ///  RX Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Enable
                RXFULL: u1,
                ///  RX Overflow Interrupt Enable
                RXOF: u1,
                ///  RX Underflow Interrupt Enable
                RXUF: u1,
                ///  TX Overflow Interrupt Enable
                TXOF: u1,
                ///  TX Underflow Interrupt Enable
                TXUF: u1,
                ///  Parity Error Interrupt Enable
                PERR: u1,
                ///  Framing Error Interrupt Enable
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Enable
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Enable
                SSM: u1,
                ///  Collision Check Fail Interrupt Enable
                CCF: u1,
                padding: u19,
            }),
            ///  IrDA Control Register
            IRCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable IrDA Module
                IREN: u1,
                ///  IrDA TX Pulse Width
                IRPW: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  IrDA pulse width is 1/16 for OVS=0 and 1/8 for OVS=1
                        ONE = 0x0,
                        ///  IrDA pulse width is 2/16 for OVS=0 and 2/8 for OVS=1
                        TWO = 0x1,
                        ///  IrDA pulse width is 3/16 for OVS=0 and 3/8 for OVS=1
                        THREE = 0x2,
                        ///  IrDA pulse width is 4/16 for OVS=0 and 4/8 for OVS=1
                        FOUR = 0x3,
                    },
                },
                ///  IrDA RX Filter
                IRFILT: u1,
                ///  IrDA PRS Channel Select
                IRPRSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                ///  IrDA PRS Channel Enable
                IRPRSEN: u1,
                padding: u24,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  RX Pin Enable
                RXPEN: u1,
                ///  TX Pin Enable
                TXPEN: u1,
                ///  CS Pin Enable
                CSPEN: u1,
                ///  CLK Pin Enable
                CLKPEN: u1,
                reserved8: u4,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  USART Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  RX PRS Channel Select
                RXPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  PRS RX Enable
                RXPRS: u1,
                padding: u27,
            }),
            ///  I2S Control Register
            I2SCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable I2S Mode
                EN: u1,
                ///  Stero or Mono
                MONO: u1,
                ///  Justification of I2S Data
                JUSTIFY: u1,
                ///  Separate DMA Request For Left/Right Data
                DMASPLIT: u1,
                ///  Delay on I2S data
                DELAY: u1,
                reserved8: u3,
                ///  I2S Word Format
                FORMAT: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  32-bit word, 32-bit data
                        W32D32 = 0x0,
                        ///  32-bit word, 32-bit data with 8 lsb masked
                        W32D24M = 0x1,
                        ///  32-bit word, 24-bit data
                        W32D24 = 0x2,
                        ///  32-bit word, 16-bit data
                        W32D16 = 0x3,
                        ///  32-bit word, 8-bit data
                        W32D8 = 0x4,
                        ///  16-bit word, 16-bit data
                        W16D16 = 0x5,
                        ///  16-bit word, 8-bit data
                        W16D8 = 0x6,
                        ///  8-bit word, 8-bit data
                        W8D8 = 0x7,
                    },
                },
                padding: u21,
            }),
        };

        ///  USART1
        pub const USART1 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  USART Synchronous Mode
                SYNC: u1,
                ///  Loopback Enable
                LOOPBK: u1,
                ///  Collision Check Enable
                CCEN: u1,
                ///  Multi-Processor Mode
                MPM: u1,
                ///  Multi-Processor Address-Bit
                MPAB: u1,
                ///  Oversampling
                OVS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Regular UART mode with 16X oversampling in asynchronous mode
                        X16 = 0x0,
                        ///  Double speed with 8X oversampling in asynchronous mode
                        X8 = 0x1,
                        ///  6X oversampling in asynchronous mode
                        X6 = 0x2,
                        ///  Quadruple speed with 4X oversampling in asynchronous mode
                        X4 = 0x3,
                    },
                },
                reserved8: u1,
                ///  Clock Polarity
                CLKPOL: u1,
                ///  Clock Edge For Setup/Sample
                CLKPHA: u1,
                ///  Most Significant Bit First
                MSBF: u1,
                ///  Action On Slave-Select In Master Mode
                CSMA: u1,
                ///  TX Buffer Interrupt Level
                TXBIL: u1,
                ///  Receiver Input Invert
                RXINV: u1,
                ///  Transmitter output Invert
                TXINV: u1,
                ///  Chip Select Invert
                CSINV: u1,
                ///  Automatic Chip Select
                AUTOCS: u1,
                ///  Automatic TX Tristate
                AUTOTRI: u1,
                ///  SmartCard Mode
                SCMODE: u1,
                ///  SmartCard Retransmit
                SCRETRANS: u1,
                ///  Skip Parity Error Frames
                SKIPPERRF: u1,
                ///  Bit 8 Default Value
                BIT8DV: u1,
                ///  Halt DMA On Error
                ERRSDMA: u1,
                ///  Disable RX On Error
                ERRSRX: u1,
                ///  Disable TX On Error
                ERRSTX: u1,
                reserved26: u1,
                ///  TX Delay Transmission
                TXDELAY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Frames are transmitted immediately
                        NONE = 0x0,
                        ///  Transmission of new frames are delayed by a single baud period
                        SINGLE = 0x1,
                        ///  Transmission of new frames are delayed by two baud periods
                        DOUBLE = 0x2,
                        ///  Transmission of new frames are delayed by three baud periods
                        TRIPLE = 0x3,
                    },
                },
                ///  Byteswap In Double Accesses
                BYTESWAP: u1,
                ///  Always Transmit When RX Not Full
                AUTOTX: u1,
                ///  Majority Vote Disable
                MVDIS: u1,
                padding: u1,
            }),
            ///  USART Frame Format Register
            FRAME: mmio.Mmio(packed struct(u32) {
                ///  Data-Bit Mode
                DATABITS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Each frame contains 4 data bits
                        FOUR = 0x1,
                        ///  Each frame contains 5 data bits
                        FIVE = 0x2,
                        ///  Each frame contains 6 data bits
                        SIX = 0x3,
                        ///  Each frame contains 7 data bits
                        SEVEN = 0x4,
                        ///  Each frame contains 8 data bits
                        EIGHT = 0x5,
                        ///  Each frame contains 9 data bits
                        NINE = 0x6,
                        ///  Each frame contains 10 data bits
                        TEN = 0x7,
                        ///  Each frame contains 11 data bits
                        ELEVEN = 0x8,
                        ///  Each frame contains 12 data bits
                        TWELVE = 0x9,
                        ///  Each frame contains 13 data bits
                        THIRTEEN = 0xa,
                        ///  Each frame contains 14 data bits
                        FOURTEEN = 0xb,
                        ///  Each frame contains 15 data bits
                        FIFTEEN = 0xc,
                        ///  Each frame contains 16 data bits
                        SIXTEEN = 0xd,
                        _,
                    },
                },
                reserved8: u4,
                ///  Parity-Bit Mode
                PARITY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Parity bits are not used
                        NONE = 0x0,
                        ///  Even parity are used. Parity bits are automatically generated and checked by hardware.
                        EVEN = 0x2,
                        ///  Odd parity is used. Parity bits are automatically generated and checked by hardware.
                        ODD = 0x3,
                        _,
                    },
                },
                reserved12: u2,
                ///  Stop-Bit Mode
                STOPBITS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The transmitter generates a half stop bit. Stop-bits are not verified by receiver
                        HALF = 0x0,
                        ///  One stop bit is generated and verified
                        ONE = 0x1,
                        ///  The transmitter generates one and a half stop bit. The receiver verifies the first stop bit
                        ONEANDAHALF = 0x2,
                        ///  The transmitter generates two stop bits. The receiver checks the first stop-bit only
                        TWO = 0x3,
                    },
                },
                padding: u18,
            }),
            ///  USART Trigger Control register
            TRIGCTRL: mmio.Mmio(packed struct(u32) {
                ///  Trigger PRS Channel Select
                TSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Receive Trigger Enable
                RXTEN: u1,
                ///  Transmit Trigger Enable
                TXTEN: u1,
                ///  AUTOTX Trigger Enable
                AUTOTXTEN: u1,
                padding: u25,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RXEN: u1,
                ///  Receiver Disable
                RXDIS: u1,
                ///  Transmitter Enable
                TXEN: u1,
                ///  Transmitter Disable
                TXDIS: u1,
                ///  Master Enable
                MASTEREN: u1,
                ///  Master Disable
                MASTERDIS: u1,
                ///  Receiver Block Enable
                RXBLOCKEN: u1,
                ///  Receiver Block Disable
                RXBLOCKDIS: u1,
                ///  Transmitter Tristate Enable
                TXTRIEN: u1,
                ///  Transmitter Tristate Disable
                TXTRIDIS: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear RX
                CLEARRX: u1,
                padding: u20,
            }),
            ///  USART Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable Status
                RXENS: u1,
                ///  Transmitter Enable Status
                TXENS: u1,
                ///  SPI Master Mode
                MASTER: u1,
                ///  Block Incoming Data
                RXBLOCK: u1,
                ///  Transmitter Tristated
                TXTRI: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                ///  RX FIFO Full
                RXFULL: u1,
                ///  TX Buffer Expects Double Right Data
                TXBDRIGHT: u1,
                ///  TX Buffer Expects Single Right Data
                TXBSRIGHT: u1,
                ///  RX Data Right
                RXDATAVRIGHT: u1,
                ///  RX Full of Right Data
                RXFULLRIGHT: u1,
                padding: u19,
            }),
            ///  Clock Control Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                reserved6: u6,
                ///  Fractional Clock Divider
                DIV: u15,
                padding: u11,
            }),
            ///  RX Buffer Data Extended Register
            RXDATAX: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u9,
                reserved14: u5,
                ///  Data Parity Error
                PERR: u1,
                ///  Data Framing Error
                FERR: u1,
                padding: u16,
            }),
            ///  RX Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  RX Buffer Double Data Extended Register
            RXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u9,
                reserved14: u5,
                ///  Data Parity Error 0
                PERR0: u1,
                ///  Data Framing Error 0
                FERR0: u1,
                ///  RX Data 1
                RXDATA1: u9,
                reserved30: u5,
                ///  Data Parity Error 1
                PERR1: u1,
                ///  Data Framing Error 1
                FERR1: u1,
            }),
            ///  RX FIFO Double Data Register
            RXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u8,
                ///  RX Data 1
                RXDATA1: u8,
                padding: u16,
            }),
            ///  RX Buffer Data Extended Peek Register
            RXDATAXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u9,
                reserved14: u5,
                ///  Data Parity Error Peek
                PERRP: u1,
                ///  Data Framing Error Peek
                FERRP: u1,
                padding: u16,
            }),
            ///  RX Buffer Double Data Extended Peek Register
            RXDOUBLEXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0 Peek
                RXDATAP0: u9,
                reserved14: u5,
                ///  Data Parity Error 0 Peek
                PERRP0: u1,
                ///  Data Framing Error 0 Peek
                FERRP0: u1,
                ///  RX Data 1 Peek
                RXDATAP1: u9,
                reserved30: u5,
                ///  Data Parity Error 1 Peek
                PERRP1: u1,
                ///  Data Framing Error 1 Peek
                FERRP1: u1,
            }),
            ///  TX Buffer Data Extended Register
            TXDATAX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATAX: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT: u1,
                ///  Transmit Data As Break
                TXBREAK: u1,
                ///  Clear TXEN After Transmission
                TXDISAT: u1,
                ///  Enable RX After Transmission
                RXENAT: u1,
                padding: u16,
            }),
            ///  TX Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  TX Buffer Double Data Extended Register
            TXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT0: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT0: u1,
                ///  Transmit Data As Break
                TXBREAK0: u1,
                ///  Clear TXEN After Transmission
                TXDISAT0: u1,
                ///  Enable RX After Transmission
                RXENAT0: u1,
                ///  TX Data
                TXDATA1: u9,
                reserved27: u2,
                ///  Unblock RX After Transmission
                UBRXAT1: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT1: u1,
                ///  Transmit Data As Break
                TXBREAK1: u1,
                ///  Clear TXEN After Transmission
                TXDISAT1: u1,
                ///  Enable RX After Transmission
                RXENAT1: u1,
            }),
            ///  TX Buffer Double Data Register
            TXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u8,
                ///  TX Data
                TXDATA1: u8,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Flag
                TXC: u1,
                ///  TX Buffer Level Interrupt Flag
                TXBL: u1,
                ///  RX Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  RX Overflow Interrupt Flag
                RXOF: u1,
                ///  RX Underflow Interrupt Flag
                RXUF: u1,
                ///  TX Overflow Interrupt Flag
                TXOF: u1,
                ///  TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Parity Error Interrupt Flag
                PERR: u1,
                ///  Framing Error Interrupt Flag
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Set RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Set RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Set RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Set TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Set TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Set Parity Error Interrupt Flag
                PERR: u1,
                ///  Set Framing Error Interrupt Flag
                FERR: u1,
                ///  Set Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Set Slave-Select in Master mode Interrupt Flag
                SSM: u1,
                ///  Set Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Clear RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Clear RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Clear RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Clear Parity Error Interrupt Flag
                PERR: u1,
                ///  Clear Framing Error Interrupt Flag
                FERR: u1,
                ///  Clear Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Clear Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Clear Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Enable
                TXC: u1,
                ///  TX Buffer Level Interrupt Enable
                TXBL: u1,
                ///  RX Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Enable
                RXFULL: u1,
                ///  RX Overflow Interrupt Enable
                RXOF: u1,
                ///  RX Underflow Interrupt Enable
                RXUF: u1,
                ///  TX Overflow Interrupt Enable
                TXOF: u1,
                ///  TX Underflow Interrupt Enable
                TXUF: u1,
                ///  Parity Error Interrupt Enable
                PERR: u1,
                ///  Framing Error Interrupt Enable
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Enable
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Enable
                SSM: u1,
                ///  Collision Check Fail Interrupt Enable
                CCF: u1,
                padding: u19,
            }),
            ///  IrDA Control Register
            IRCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable IrDA Module
                IREN: u1,
                ///  IrDA TX Pulse Width
                IRPW: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  IrDA pulse width is 1/16 for OVS=0 and 1/8 for OVS=1
                        ONE = 0x0,
                        ///  IrDA pulse width is 2/16 for OVS=0 and 2/8 for OVS=1
                        TWO = 0x1,
                        ///  IrDA pulse width is 3/16 for OVS=0 and 3/8 for OVS=1
                        THREE = 0x2,
                        ///  IrDA pulse width is 4/16 for OVS=0 and 4/8 for OVS=1
                        FOUR = 0x3,
                    },
                },
                ///  IrDA RX Filter
                IRFILT: u1,
                ///  IrDA PRS Channel Select
                IRPRSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                ///  IrDA PRS Channel Enable
                IRPRSEN: u1,
                padding: u24,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  RX Pin Enable
                RXPEN: u1,
                ///  TX Pin Enable
                TXPEN: u1,
                ///  CS Pin Enable
                CSPEN: u1,
                ///  CLK Pin Enable
                CLKPEN: u1,
                reserved8: u4,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  USART Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  RX PRS Channel Select
                RXPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  PRS RX Enable
                RXPRS: u1,
                padding: u27,
            }),
            ///  I2S Control Register
            I2SCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable I2S Mode
                EN: u1,
                ///  Stero or Mono
                MONO: u1,
                ///  Justification of I2S Data
                JUSTIFY: u1,
                ///  Separate DMA Request For Left/Right Data
                DMASPLIT: u1,
                ///  Delay on I2S data
                DELAY: u1,
                reserved8: u3,
                ///  I2S Word Format
                FORMAT: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  32-bit word, 32-bit data
                        W32D32 = 0x0,
                        ///  32-bit word, 32-bit data with 8 lsb masked
                        W32D24M = 0x1,
                        ///  32-bit word, 24-bit data
                        W32D24 = 0x2,
                        ///  32-bit word, 16-bit data
                        W32D16 = 0x3,
                        ///  32-bit word, 8-bit data
                        W32D8 = 0x4,
                        ///  16-bit word, 16-bit data
                        W16D16 = 0x5,
                        ///  16-bit word, 8-bit data
                        W16D8 = 0x6,
                        ///  8-bit word, 8-bit data
                        W8D8 = 0x7,
                    },
                },
                padding: u21,
            }),
        };

        ///  USART2
        pub const USART2 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  USART Synchronous Mode
                SYNC: u1,
                ///  Loopback Enable
                LOOPBK: u1,
                ///  Collision Check Enable
                CCEN: u1,
                ///  Multi-Processor Mode
                MPM: u1,
                ///  Multi-Processor Address-Bit
                MPAB: u1,
                ///  Oversampling
                OVS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Regular UART mode with 16X oversampling in asynchronous mode
                        X16 = 0x0,
                        ///  Double speed with 8X oversampling in asynchronous mode
                        X8 = 0x1,
                        ///  6X oversampling in asynchronous mode
                        X6 = 0x2,
                        ///  Quadruple speed with 4X oversampling in asynchronous mode
                        X4 = 0x3,
                    },
                },
                reserved8: u1,
                ///  Clock Polarity
                CLKPOL: u1,
                ///  Clock Edge For Setup/Sample
                CLKPHA: u1,
                ///  Most Significant Bit First
                MSBF: u1,
                ///  Action On Slave-Select In Master Mode
                CSMA: u1,
                ///  TX Buffer Interrupt Level
                TXBIL: u1,
                ///  Receiver Input Invert
                RXINV: u1,
                ///  Transmitter output Invert
                TXINV: u1,
                ///  Chip Select Invert
                CSINV: u1,
                ///  Automatic Chip Select
                AUTOCS: u1,
                ///  Automatic TX Tristate
                AUTOTRI: u1,
                ///  SmartCard Mode
                SCMODE: u1,
                ///  SmartCard Retransmit
                SCRETRANS: u1,
                ///  Skip Parity Error Frames
                SKIPPERRF: u1,
                ///  Bit 8 Default Value
                BIT8DV: u1,
                ///  Halt DMA On Error
                ERRSDMA: u1,
                ///  Disable RX On Error
                ERRSRX: u1,
                ///  Disable TX On Error
                ERRSTX: u1,
                reserved26: u1,
                ///  TX Delay Transmission
                TXDELAY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Frames are transmitted immediately
                        NONE = 0x0,
                        ///  Transmission of new frames are delayed by a single baud period
                        SINGLE = 0x1,
                        ///  Transmission of new frames are delayed by two baud periods
                        DOUBLE = 0x2,
                        ///  Transmission of new frames are delayed by three baud periods
                        TRIPLE = 0x3,
                    },
                },
                ///  Byteswap In Double Accesses
                BYTESWAP: u1,
                ///  Always Transmit When RX Not Full
                AUTOTX: u1,
                ///  Majority Vote Disable
                MVDIS: u1,
                padding: u1,
            }),
            ///  USART Frame Format Register
            FRAME: mmio.Mmio(packed struct(u32) {
                ///  Data-Bit Mode
                DATABITS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Each frame contains 4 data bits
                        FOUR = 0x1,
                        ///  Each frame contains 5 data bits
                        FIVE = 0x2,
                        ///  Each frame contains 6 data bits
                        SIX = 0x3,
                        ///  Each frame contains 7 data bits
                        SEVEN = 0x4,
                        ///  Each frame contains 8 data bits
                        EIGHT = 0x5,
                        ///  Each frame contains 9 data bits
                        NINE = 0x6,
                        ///  Each frame contains 10 data bits
                        TEN = 0x7,
                        ///  Each frame contains 11 data bits
                        ELEVEN = 0x8,
                        ///  Each frame contains 12 data bits
                        TWELVE = 0x9,
                        ///  Each frame contains 13 data bits
                        THIRTEEN = 0xa,
                        ///  Each frame contains 14 data bits
                        FOURTEEN = 0xb,
                        ///  Each frame contains 15 data bits
                        FIFTEEN = 0xc,
                        ///  Each frame contains 16 data bits
                        SIXTEEN = 0xd,
                        _,
                    },
                },
                reserved8: u4,
                ///  Parity-Bit Mode
                PARITY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Parity bits are not used
                        NONE = 0x0,
                        ///  Even parity are used. Parity bits are automatically generated and checked by hardware.
                        EVEN = 0x2,
                        ///  Odd parity is used. Parity bits are automatically generated and checked by hardware.
                        ODD = 0x3,
                        _,
                    },
                },
                reserved12: u2,
                ///  Stop-Bit Mode
                STOPBITS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The transmitter generates a half stop bit. Stop-bits are not verified by receiver
                        HALF = 0x0,
                        ///  One stop bit is generated and verified
                        ONE = 0x1,
                        ///  The transmitter generates one and a half stop bit. The receiver verifies the first stop bit
                        ONEANDAHALF = 0x2,
                        ///  The transmitter generates two stop bits. The receiver checks the first stop-bit only
                        TWO = 0x3,
                    },
                },
                padding: u18,
            }),
            ///  USART Trigger Control register
            TRIGCTRL: mmio.Mmio(packed struct(u32) {
                ///  Trigger PRS Channel Select
                TSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Receive Trigger Enable
                RXTEN: u1,
                ///  Transmit Trigger Enable
                TXTEN: u1,
                ///  AUTOTX Trigger Enable
                AUTOTXTEN: u1,
                padding: u25,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RXEN: u1,
                ///  Receiver Disable
                RXDIS: u1,
                ///  Transmitter Enable
                TXEN: u1,
                ///  Transmitter Disable
                TXDIS: u1,
                ///  Master Enable
                MASTEREN: u1,
                ///  Master Disable
                MASTERDIS: u1,
                ///  Receiver Block Enable
                RXBLOCKEN: u1,
                ///  Receiver Block Disable
                RXBLOCKDIS: u1,
                ///  Transmitter Tristate Enable
                TXTRIEN: u1,
                ///  Transmitter Tristate Disable
                TXTRIDIS: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear RX
                CLEARRX: u1,
                padding: u20,
            }),
            ///  USART Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable Status
                RXENS: u1,
                ///  Transmitter Enable Status
                TXENS: u1,
                ///  SPI Master Mode
                MASTER: u1,
                ///  Block Incoming Data
                RXBLOCK: u1,
                ///  Transmitter Tristated
                TXTRI: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                ///  RX FIFO Full
                RXFULL: u1,
                ///  TX Buffer Expects Double Right Data
                TXBDRIGHT: u1,
                ///  TX Buffer Expects Single Right Data
                TXBSRIGHT: u1,
                ///  RX Data Right
                RXDATAVRIGHT: u1,
                ///  RX Full of Right Data
                RXFULLRIGHT: u1,
                padding: u19,
            }),
            ///  Clock Control Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                reserved6: u6,
                ///  Fractional Clock Divider
                DIV: u15,
                padding: u11,
            }),
            ///  RX Buffer Data Extended Register
            RXDATAX: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u9,
                reserved14: u5,
                ///  Data Parity Error
                PERR: u1,
                ///  Data Framing Error
                FERR: u1,
                padding: u16,
            }),
            ///  RX Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  RX Buffer Double Data Extended Register
            RXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u9,
                reserved14: u5,
                ///  Data Parity Error 0
                PERR0: u1,
                ///  Data Framing Error 0
                FERR0: u1,
                ///  RX Data 1
                RXDATA1: u9,
                reserved30: u5,
                ///  Data Parity Error 1
                PERR1: u1,
                ///  Data Framing Error 1
                FERR1: u1,
            }),
            ///  RX FIFO Double Data Register
            RXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u8,
                ///  RX Data 1
                RXDATA1: u8,
                padding: u16,
            }),
            ///  RX Buffer Data Extended Peek Register
            RXDATAXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u9,
                reserved14: u5,
                ///  Data Parity Error Peek
                PERRP: u1,
                ///  Data Framing Error Peek
                FERRP: u1,
                padding: u16,
            }),
            ///  RX Buffer Double Data Extended Peek Register
            RXDOUBLEXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0 Peek
                RXDATAP0: u9,
                reserved14: u5,
                ///  Data Parity Error 0 Peek
                PERRP0: u1,
                ///  Data Framing Error 0 Peek
                FERRP0: u1,
                ///  RX Data 1 Peek
                RXDATAP1: u9,
                reserved30: u5,
                ///  Data Parity Error 1 Peek
                PERRP1: u1,
                ///  Data Framing Error 1 Peek
                FERRP1: u1,
            }),
            ///  TX Buffer Data Extended Register
            TXDATAX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATAX: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT: u1,
                ///  Transmit Data As Break
                TXBREAK: u1,
                ///  Clear TXEN After Transmission
                TXDISAT: u1,
                ///  Enable RX After Transmission
                RXENAT: u1,
                padding: u16,
            }),
            ///  TX Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  TX Buffer Double Data Extended Register
            TXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT0: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT0: u1,
                ///  Transmit Data As Break
                TXBREAK0: u1,
                ///  Clear TXEN After Transmission
                TXDISAT0: u1,
                ///  Enable RX After Transmission
                RXENAT0: u1,
                ///  TX Data
                TXDATA1: u9,
                reserved27: u2,
                ///  Unblock RX After Transmission
                UBRXAT1: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT1: u1,
                ///  Transmit Data As Break
                TXBREAK1: u1,
                ///  Clear TXEN After Transmission
                TXDISAT1: u1,
                ///  Enable RX After Transmission
                RXENAT1: u1,
            }),
            ///  TX Buffer Double Data Register
            TXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u8,
                ///  TX Data
                TXDATA1: u8,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Flag
                TXC: u1,
                ///  TX Buffer Level Interrupt Flag
                TXBL: u1,
                ///  RX Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  RX Overflow Interrupt Flag
                RXOF: u1,
                ///  RX Underflow Interrupt Flag
                RXUF: u1,
                ///  TX Overflow Interrupt Flag
                TXOF: u1,
                ///  TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Parity Error Interrupt Flag
                PERR: u1,
                ///  Framing Error Interrupt Flag
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Set RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Set RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Set RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Set TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Set TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Set Parity Error Interrupt Flag
                PERR: u1,
                ///  Set Framing Error Interrupt Flag
                FERR: u1,
                ///  Set Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Set Slave-Select in Master mode Interrupt Flag
                SSM: u1,
                ///  Set Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Clear RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Clear RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Clear RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Clear Parity Error Interrupt Flag
                PERR: u1,
                ///  Clear Framing Error Interrupt Flag
                FERR: u1,
                ///  Clear Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Clear Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Clear Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Enable
                TXC: u1,
                ///  TX Buffer Level Interrupt Enable
                TXBL: u1,
                ///  RX Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Enable
                RXFULL: u1,
                ///  RX Overflow Interrupt Enable
                RXOF: u1,
                ///  RX Underflow Interrupt Enable
                RXUF: u1,
                ///  TX Overflow Interrupt Enable
                TXOF: u1,
                ///  TX Underflow Interrupt Enable
                TXUF: u1,
                ///  Parity Error Interrupt Enable
                PERR: u1,
                ///  Framing Error Interrupt Enable
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Enable
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Enable
                SSM: u1,
                ///  Collision Check Fail Interrupt Enable
                CCF: u1,
                padding: u19,
            }),
            ///  IrDA Control Register
            IRCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable IrDA Module
                IREN: u1,
                ///  IrDA TX Pulse Width
                IRPW: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  IrDA pulse width is 1/16 for OVS=0 and 1/8 for OVS=1
                        ONE = 0x0,
                        ///  IrDA pulse width is 2/16 for OVS=0 and 2/8 for OVS=1
                        TWO = 0x1,
                        ///  IrDA pulse width is 3/16 for OVS=0 and 3/8 for OVS=1
                        THREE = 0x2,
                        ///  IrDA pulse width is 4/16 for OVS=0 and 4/8 for OVS=1
                        FOUR = 0x3,
                    },
                },
                ///  IrDA RX Filter
                IRFILT: u1,
                ///  IrDA PRS Channel Select
                IRPRSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                ///  IrDA PRS Channel Enable
                IRPRSEN: u1,
                padding: u24,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  RX Pin Enable
                RXPEN: u1,
                ///  TX Pin Enable
                TXPEN: u1,
                ///  CS Pin Enable
                CSPEN: u1,
                ///  CLK Pin Enable
                CLKPEN: u1,
                reserved8: u4,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  USART Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  RX PRS Channel Select
                RXPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  PRS RX Enable
                RXPRS: u1,
                padding: u27,
            }),
            ///  I2S Control Register
            I2SCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable I2S Mode
                EN: u1,
                ///  Stero or Mono
                MONO: u1,
                ///  Justification of I2S Data
                JUSTIFY: u1,
                ///  Separate DMA Request For Left/Right Data
                DMASPLIT: u1,
                ///  Delay on I2S data
                DELAY: u1,
                reserved8: u3,
                ///  I2S Word Format
                FORMAT: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  32-bit word, 32-bit data
                        W32D32 = 0x0,
                        ///  32-bit word, 32-bit data with 8 lsb masked
                        W32D24M = 0x1,
                        ///  32-bit word, 24-bit data
                        W32D24 = 0x2,
                        ///  32-bit word, 16-bit data
                        W32D16 = 0x3,
                        ///  32-bit word, 8-bit data
                        W32D8 = 0x4,
                        ///  16-bit word, 16-bit data
                        W16D16 = 0x5,
                        ///  16-bit word, 8-bit data
                        W16D8 = 0x6,
                        ///  8-bit word, 8-bit data
                        W8D8 = 0x7,
                    },
                },
                padding: u21,
            }),
        };

        ///  UART0
        pub const UART0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  USART Synchronous Mode
                SYNC: u1,
                ///  Loopback Enable
                LOOPBK: u1,
                ///  Collision Check Enable
                CCEN: u1,
                ///  Multi-Processor Mode
                MPM: u1,
                ///  Multi-Processor Address-Bit
                MPAB: u1,
                ///  Oversampling
                OVS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Regular UART mode with 16X oversampling in asynchronous mode
                        X16 = 0x0,
                        ///  Double speed with 8X oversampling in asynchronous mode
                        X8 = 0x1,
                        ///  6X oversampling in asynchronous mode
                        X6 = 0x2,
                        ///  Quadruple speed with 4X oversampling in asynchronous mode
                        X4 = 0x3,
                    },
                },
                reserved8: u1,
                ///  Clock Polarity
                CLKPOL: u1,
                ///  Clock Edge For Setup/Sample
                CLKPHA: u1,
                ///  Most Significant Bit First
                MSBF: u1,
                ///  Action On Slave-Select In Master Mode
                CSMA: u1,
                ///  TX Buffer Interrupt Level
                TXBIL: u1,
                ///  Receiver Input Invert
                RXINV: u1,
                ///  Transmitter output Invert
                TXINV: u1,
                ///  Chip Select Invert
                CSINV: u1,
                ///  Automatic Chip Select
                AUTOCS: u1,
                ///  Automatic TX Tristate
                AUTOTRI: u1,
                ///  SmartCard Mode
                SCMODE: u1,
                ///  SmartCard Retransmit
                SCRETRANS: u1,
                ///  Skip Parity Error Frames
                SKIPPERRF: u1,
                ///  Bit 8 Default Value
                BIT8DV: u1,
                ///  Halt DMA On Error
                ERRSDMA: u1,
                ///  Disable RX On Error
                ERRSRX: u1,
                ///  Disable TX On Error
                ERRSTX: u1,
                reserved26: u1,
                ///  TX Delay Transmission
                TXDELAY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Frames are transmitted immediately
                        NONE = 0x0,
                        ///  Transmission of new frames are delayed by a single baud period
                        SINGLE = 0x1,
                        ///  Transmission of new frames are delayed by two baud periods
                        DOUBLE = 0x2,
                        ///  Transmission of new frames are delayed by three baud periods
                        TRIPLE = 0x3,
                    },
                },
                ///  Byteswap In Double Accesses
                BYTESWAP: u1,
                ///  Always Transmit When RX Not Full
                AUTOTX: u1,
                ///  Majority Vote Disable
                MVDIS: u1,
                padding: u1,
            }),
            ///  USART Frame Format Register
            FRAME: mmio.Mmio(packed struct(u32) {
                ///  Data-Bit Mode
                DATABITS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Each frame contains 4 data bits
                        FOUR = 0x1,
                        ///  Each frame contains 5 data bits
                        FIVE = 0x2,
                        ///  Each frame contains 6 data bits
                        SIX = 0x3,
                        ///  Each frame contains 7 data bits
                        SEVEN = 0x4,
                        ///  Each frame contains 8 data bits
                        EIGHT = 0x5,
                        ///  Each frame contains 9 data bits
                        NINE = 0x6,
                        ///  Each frame contains 10 data bits
                        TEN = 0x7,
                        ///  Each frame contains 11 data bits
                        ELEVEN = 0x8,
                        ///  Each frame contains 12 data bits
                        TWELVE = 0x9,
                        ///  Each frame contains 13 data bits
                        THIRTEEN = 0xa,
                        ///  Each frame contains 14 data bits
                        FOURTEEN = 0xb,
                        ///  Each frame contains 15 data bits
                        FIFTEEN = 0xc,
                        ///  Each frame contains 16 data bits
                        SIXTEEN = 0xd,
                        _,
                    },
                },
                reserved8: u4,
                ///  Parity-Bit Mode
                PARITY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Parity bits are not used
                        NONE = 0x0,
                        ///  Even parity are used. Parity bits are automatically generated and checked by hardware.
                        EVEN = 0x2,
                        ///  Odd parity is used. Parity bits are automatically generated and checked by hardware.
                        ODD = 0x3,
                        _,
                    },
                },
                reserved12: u2,
                ///  Stop-Bit Mode
                STOPBITS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The transmitter generates a half stop bit. Stop-bits are not verified by receiver
                        HALF = 0x0,
                        ///  One stop bit is generated and verified
                        ONE = 0x1,
                        ///  The transmitter generates one and a half stop bit. The receiver verifies the first stop bit
                        ONEANDAHALF = 0x2,
                        ///  The transmitter generates two stop bits. The receiver checks the first stop-bit only
                        TWO = 0x3,
                    },
                },
                padding: u18,
            }),
            ///  USART Trigger Control register
            TRIGCTRL: mmio.Mmio(packed struct(u32) {
                ///  Trigger PRS Channel Select
                TSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Receive Trigger Enable
                RXTEN: u1,
                ///  Transmit Trigger Enable
                TXTEN: u1,
                ///  AUTOTX Trigger Enable
                AUTOTXTEN: u1,
                padding: u25,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RXEN: u1,
                ///  Receiver Disable
                RXDIS: u1,
                ///  Transmitter Enable
                TXEN: u1,
                ///  Transmitter Disable
                TXDIS: u1,
                ///  Master Enable
                MASTEREN: u1,
                ///  Master Disable
                MASTERDIS: u1,
                ///  Receiver Block Enable
                RXBLOCKEN: u1,
                ///  Receiver Block Disable
                RXBLOCKDIS: u1,
                ///  Transmitter Tristate Enable
                TXTRIEN: u1,
                ///  Transmitter Tristate Disable
                TXTRIDIS: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear RX
                CLEARRX: u1,
                padding: u20,
            }),
            ///  USART Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable Status
                RXENS: u1,
                ///  Transmitter Enable Status
                TXENS: u1,
                ///  SPI Master Mode
                MASTER: u1,
                ///  Block Incoming Data
                RXBLOCK: u1,
                ///  Transmitter Tristated
                TXTRI: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                ///  RX FIFO Full
                RXFULL: u1,
                ///  TX Buffer Expects Double Right Data
                TXBDRIGHT: u1,
                ///  TX Buffer Expects Single Right Data
                TXBSRIGHT: u1,
                ///  RX Data Right
                RXDATAVRIGHT: u1,
                ///  RX Full of Right Data
                RXFULLRIGHT: u1,
                padding: u19,
            }),
            ///  Clock Control Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                reserved6: u6,
                ///  Fractional Clock Divider
                DIV: u15,
                padding: u11,
            }),
            ///  RX Buffer Data Extended Register
            RXDATAX: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u9,
                reserved14: u5,
                ///  Data Parity Error
                PERR: u1,
                ///  Data Framing Error
                FERR: u1,
                padding: u16,
            }),
            ///  RX Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  RX Buffer Double Data Extended Register
            RXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u9,
                reserved14: u5,
                ///  Data Parity Error 0
                PERR0: u1,
                ///  Data Framing Error 0
                FERR0: u1,
                ///  RX Data 1
                RXDATA1: u9,
                reserved30: u5,
                ///  Data Parity Error 1
                PERR1: u1,
                ///  Data Framing Error 1
                FERR1: u1,
            }),
            ///  RX FIFO Double Data Register
            RXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u8,
                ///  RX Data 1
                RXDATA1: u8,
                padding: u16,
            }),
            ///  RX Buffer Data Extended Peek Register
            RXDATAXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u9,
                reserved14: u5,
                ///  Data Parity Error Peek
                PERRP: u1,
                ///  Data Framing Error Peek
                FERRP: u1,
                padding: u16,
            }),
            ///  RX Buffer Double Data Extended Peek Register
            RXDOUBLEXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0 Peek
                RXDATAP0: u9,
                reserved14: u5,
                ///  Data Parity Error 0 Peek
                PERRP0: u1,
                ///  Data Framing Error 0 Peek
                FERRP0: u1,
                ///  RX Data 1 Peek
                RXDATAP1: u9,
                reserved30: u5,
                ///  Data Parity Error 1 Peek
                PERRP1: u1,
                ///  Data Framing Error 1 Peek
                FERRP1: u1,
            }),
            ///  TX Buffer Data Extended Register
            TXDATAX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATAX: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT: u1,
                ///  Transmit Data As Break
                TXBREAK: u1,
                ///  Clear TXEN After Transmission
                TXDISAT: u1,
                ///  Enable RX After Transmission
                RXENAT: u1,
                padding: u16,
            }),
            ///  TX Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  TX Buffer Double Data Extended Register
            TXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT0: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT0: u1,
                ///  Transmit Data As Break
                TXBREAK0: u1,
                ///  Clear TXEN After Transmission
                TXDISAT0: u1,
                ///  Enable RX After Transmission
                RXENAT0: u1,
                ///  TX Data
                TXDATA1: u9,
                reserved27: u2,
                ///  Unblock RX After Transmission
                UBRXAT1: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT1: u1,
                ///  Transmit Data As Break
                TXBREAK1: u1,
                ///  Clear TXEN After Transmission
                TXDISAT1: u1,
                ///  Enable RX After Transmission
                RXENAT1: u1,
            }),
            ///  TX Buffer Double Data Register
            TXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u8,
                ///  TX Data
                TXDATA1: u8,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Flag
                TXC: u1,
                ///  TX Buffer Level Interrupt Flag
                TXBL: u1,
                ///  RX Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  RX Overflow Interrupt Flag
                RXOF: u1,
                ///  RX Underflow Interrupt Flag
                RXUF: u1,
                ///  TX Overflow Interrupt Flag
                TXOF: u1,
                ///  TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Parity Error Interrupt Flag
                PERR: u1,
                ///  Framing Error Interrupt Flag
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Set RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Set RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Set RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Set TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Set TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Set Parity Error Interrupt Flag
                PERR: u1,
                ///  Set Framing Error Interrupt Flag
                FERR: u1,
                ///  Set Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Set Slave-Select in Master mode Interrupt Flag
                SSM: u1,
                ///  Set Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Clear RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Clear RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Clear RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Clear Parity Error Interrupt Flag
                PERR: u1,
                ///  Clear Framing Error Interrupt Flag
                FERR: u1,
                ///  Clear Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Clear Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Clear Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Enable
                TXC: u1,
                ///  TX Buffer Level Interrupt Enable
                TXBL: u1,
                ///  RX Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Enable
                RXFULL: u1,
                ///  RX Overflow Interrupt Enable
                RXOF: u1,
                ///  RX Underflow Interrupt Enable
                RXUF: u1,
                ///  TX Overflow Interrupt Enable
                TXOF: u1,
                ///  TX Underflow Interrupt Enable
                TXUF: u1,
                ///  Parity Error Interrupt Enable
                PERR: u1,
                ///  Framing Error Interrupt Enable
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Enable
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Enable
                SSM: u1,
                ///  Collision Check Fail Interrupt Enable
                CCF: u1,
                padding: u19,
            }),
            ///  IrDA Control Register
            IRCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable IrDA Module
                IREN: u1,
                ///  IrDA TX Pulse Width
                IRPW: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  IrDA pulse width is 1/16 for OVS=0 and 1/8 for OVS=1
                        ONE = 0x0,
                        ///  IrDA pulse width is 2/16 for OVS=0 and 2/8 for OVS=1
                        TWO = 0x1,
                        ///  IrDA pulse width is 3/16 for OVS=0 and 3/8 for OVS=1
                        THREE = 0x2,
                        ///  IrDA pulse width is 4/16 for OVS=0 and 4/8 for OVS=1
                        FOUR = 0x3,
                    },
                },
                ///  IrDA RX Filter
                IRFILT: u1,
                ///  IrDA PRS Channel Select
                IRPRSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                ///  IrDA PRS Channel Enable
                IRPRSEN: u1,
                padding: u24,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  RX Pin Enable
                RXPEN: u1,
                ///  TX Pin Enable
                TXPEN: u1,
                ///  CS Pin Enable
                CSPEN: u1,
                ///  CLK Pin Enable
                CLKPEN: u1,
                reserved8: u4,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  USART Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  RX PRS Channel Select
                RXPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  PRS RX Enable
                RXPRS: u1,
                padding: u27,
            }),
            ///  I2S Control Register
            I2SCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable I2S Mode
                EN: u1,
                ///  Stero or Mono
                MONO: u1,
                ///  Justification of I2S Data
                JUSTIFY: u1,
                ///  Separate DMA Request For Left/Right Data
                DMASPLIT: u1,
                ///  Delay on I2S data
                DELAY: u1,
                reserved8: u3,
                ///  I2S Word Format
                FORMAT: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  32-bit word, 32-bit data
                        W32D32 = 0x0,
                        ///  32-bit word, 32-bit data with 8 lsb masked
                        W32D24M = 0x1,
                        ///  32-bit word, 24-bit data
                        W32D24 = 0x2,
                        ///  32-bit word, 16-bit data
                        W32D16 = 0x3,
                        ///  32-bit word, 8-bit data
                        W32D8 = 0x4,
                        ///  16-bit word, 16-bit data
                        W16D16 = 0x5,
                        ///  16-bit word, 8-bit data
                        W16D8 = 0x6,
                        ///  8-bit word, 8-bit data
                        W8D8 = 0x7,
                    },
                },
                padding: u21,
            }),
        };

        ///  UART1
        pub const UART1 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  USART Synchronous Mode
                SYNC: u1,
                ///  Loopback Enable
                LOOPBK: u1,
                ///  Collision Check Enable
                CCEN: u1,
                ///  Multi-Processor Mode
                MPM: u1,
                ///  Multi-Processor Address-Bit
                MPAB: u1,
                ///  Oversampling
                OVS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Regular UART mode with 16X oversampling in asynchronous mode
                        X16 = 0x0,
                        ///  Double speed with 8X oversampling in asynchronous mode
                        X8 = 0x1,
                        ///  6X oversampling in asynchronous mode
                        X6 = 0x2,
                        ///  Quadruple speed with 4X oversampling in asynchronous mode
                        X4 = 0x3,
                    },
                },
                reserved8: u1,
                ///  Clock Polarity
                CLKPOL: u1,
                ///  Clock Edge For Setup/Sample
                CLKPHA: u1,
                ///  Most Significant Bit First
                MSBF: u1,
                ///  Action On Slave-Select In Master Mode
                CSMA: u1,
                ///  TX Buffer Interrupt Level
                TXBIL: u1,
                ///  Receiver Input Invert
                RXINV: u1,
                ///  Transmitter output Invert
                TXINV: u1,
                ///  Chip Select Invert
                CSINV: u1,
                ///  Automatic Chip Select
                AUTOCS: u1,
                ///  Automatic TX Tristate
                AUTOTRI: u1,
                ///  SmartCard Mode
                SCMODE: u1,
                ///  SmartCard Retransmit
                SCRETRANS: u1,
                ///  Skip Parity Error Frames
                SKIPPERRF: u1,
                ///  Bit 8 Default Value
                BIT8DV: u1,
                ///  Halt DMA On Error
                ERRSDMA: u1,
                ///  Disable RX On Error
                ERRSRX: u1,
                ///  Disable TX On Error
                ERRSTX: u1,
                reserved26: u1,
                ///  TX Delay Transmission
                TXDELAY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Frames are transmitted immediately
                        NONE = 0x0,
                        ///  Transmission of new frames are delayed by a single baud period
                        SINGLE = 0x1,
                        ///  Transmission of new frames are delayed by two baud periods
                        DOUBLE = 0x2,
                        ///  Transmission of new frames are delayed by three baud periods
                        TRIPLE = 0x3,
                    },
                },
                ///  Byteswap In Double Accesses
                BYTESWAP: u1,
                ///  Always Transmit When RX Not Full
                AUTOTX: u1,
                ///  Majority Vote Disable
                MVDIS: u1,
                padding: u1,
            }),
            ///  USART Frame Format Register
            FRAME: mmio.Mmio(packed struct(u32) {
                ///  Data-Bit Mode
                DATABITS: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Each frame contains 4 data bits
                        FOUR = 0x1,
                        ///  Each frame contains 5 data bits
                        FIVE = 0x2,
                        ///  Each frame contains 6 data bits
                        SIX = 0x3,
                        ///  Each frame contains 7 data bits
                        SEVEN = 0x4,
                        ///  Each frame contains 8 data bits
                        EIGHT = 0x5,
                        ///  Each frame contains 9 data bits
                        NINE = 0x6,
                        ///  Each frame contains 10 data bits
                        TEN = 0x7,
                        ///  Each frame contains 11 data bits
                        ELEVEN = 0x8,
                        ///  Each frame contains 12 data bits
                        TWELVE = 0x9,
                        ///  Each frame contains 13 data bits
                        THIRTEEN = 0xa,
                        ///  Each frame contains 14 data bits
                        FOURTEEN = 0xb,
                        ///  Each frame contains 15 data bits
                        FIFTEEN = 0xc,
                        ///  Each frame contains 16 data bits
                        SIXTEEN = 0xd,
                        _,
                    },
                },
                reserved8: u4,
                ///  Parity-Bit Mode
                PARITY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Parity bits are not used
                        NONE = 0x0,
                        ///  Even parity are used. Parity bits are automatically generated and checked by hardware.
                        EVEN = 0x2,
                        ///  Odd parity is used. Parity bits are automatically generated and checked by hardware.
                        ODD = 0x3,
                        _,
                    },
                },
                reserved12: u2,
                ///  Stop-Bit Mode
                STOPBITS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The transmitter generates a half stop bit. Stop-bits are not verified by receiver
                        HALF = 0x0,
                        ///  One stop bit is generated and verified
                        ONE = 0x1,
                        ///  The transmitter generates one and a half stop bit. The receiver verifies the first stop bit
                        ONEANDAHALF = 0x2,
                        ///  The transmitter generates two stop bits. The receiver checks the first stop-bit only
                        TWO = 0x3,
                    },
                },
                padding: u18,
            }),
            ///  USART Trigger Control register
            TRIGCTRL: mmio.Mmio(packed struct(u32) {
                ///  Trigger PRS Channel Select
                TSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Receive Trigger Enable
                RXTEN: u1,
                ///  Transmit Trigger Enable
                TXTEN: u1,
                ///  AUTOTX Trigger Enable
                AUTOTXTEN: u1,
                padding: u25,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RXEN: u1,
                ///  Receiver Disable
                RXDIS: u1,
                ///  Transmitter Enable
                TXEN: u1,
                ///  Transmitter Disable
                TXDIS: u1,
                ///  Master Enable
                MASTEREN: u1,
                ///  Master Disable
                MASTERDIS: u1,
                ///  Receiver Block Enable
                RXBLOCKEN: u1,
                ///  Receiver Block Disable
                RXBLOCKDIS: u1,
                ///  Transmitter Tristate Enable
                TXTRIEN: u1,
                ///  Transmitter Tristate Disable
                TXTRIDIS: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear RX
                CLEARRX: u1,
                padding: u20,
            }),
            ///  USART Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable Status
                RXENS: u1,
                ///  Transmitter Enable Status
                TXENS: u1,
                ///  SPI Master Mode
                MASTER: u1,
                ///  Block Incoming Data
                RXBLOCK: u1,
                ///  Transmitter Tristated
                TXTRI: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                ///  RX FIFO Full
                RXFULL: u1,
                ///  TX Buffer Expects Double Right Data
                TXBDRIGHT: u1,
                ///  TX Buffer Expects Single Right Data
                TXBSRIGHT: u1,
                ///  RX Data Right
                RXDATAVRIGHT: u1,
                ///  RX Full of Right Data
                RXFULLRIGHT: u1,
                padding: u19,
            }),
            ///  Clock Control Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                reserved6: u6,
                ///  Fractional Clock Divider
                DIV: u15,
                padding: u11,
            }),
            ///  RX Buffer Data Extended Register
            RXDATAX: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u9,
                reserved14: u5,
                ///  Data Parity Error
                PERR: u1,
                ///  Data Framing Error
                FERR: u1,
                padding: u16,
            }),
            ///  RX Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  RX Buffer Double Data Extended Register
            RXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u9,
                reserved14: u5,
                ///  Data Parity Error 0
                PERR0: u1,
                ///  Data Framing Error 0
                FERR0: u1,
                ///  RX Data 1
                RXDATA1: u9,
                reserved30: u5,
                ///  Data Parity Error 1
                PERR1: u1,
                ///  Data Framing Error 1
                FERR1: u1,
            }),
            ///  RX FIFO Double Data Register
            RXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0
                RXDATA0: u8,
                ///  RX Data 1
                RXDATA1: u8,
                padding: u16,
            }),
            ///  RX Buffer Data Extended Peek Register
            RXDATAXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u9,
                reserved14: u5,
                ///  Data Parity Error Peek
                PERRP: u1,
                ///  Data Framing Error Peek
                FERRP: u1,
                padding: u16,
            }),
            ///  RX Buffer Double Data Extended Peek Register
            RXDOUBLEXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data 0 Peek
                RXDATAP0: u9,
                reserved14: u5,
                ///  Data Parity Error 0 Peek
                PERRP0: u1,
                ///  Data Framing Error 0 Peek
                FERRP0: u1,
                ///  RX Data 1 Peek
                RXDATAP1: u9,
                reserved30: u5,
                ///  Data Parity Error 1 Peek
                PERRP1: u1,
                ///  Data Framing Error 1 Peek
                FERRP1: u1,
            }),
            ///  TX Buffer Data Extended Register
            TXDATAX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATAX: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT: u1,
                ///  Transmit Data As Break
                TXBREAK: u1,
                ///  Clear TXEN After Transmission
                TXDISAT: u1,
                ///  Enable RX After Transmission
                RXENAT: u1,
                padding: u16,
            }),
            ///  TX Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  TX Buffer Double Data Extended Register
            TXDOUBLEX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u9,
                reserved11: u2,
                ///  Unblock RX After Transmission
                UBRXAT0: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT0: u1,
                ///  Transmit Data As Break
                TXBREAK0: u1,
                ///  Clear TXEN After Transmission
                TXDISAT0: u1,
                ///  Enable RX After Transmission
                RXENAT0: u1,
                ///  TX Data
                TXDATA1: u9,
                reserved27: u2,
                ///  Unblock RX After Transmission
                UBRXAT1: u1,
                ///  Set TXTRI After Transmission
                TXTRIAT1: u1,
                ///  Transmit Data As Break
                TXBREAK1: u1,
                ///  Clear TXEN After Transmission
                TXDISAT1: u1,
                ///  Enable RX After Transmission
                RXENAT1: u1,
            }),
            ///  TX Buffer Double Data Register
            TXDOUBLE: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA0: u8,
                ///  TX Data
                TXDATA1: u8,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Flag
                TXC: u1,
                ///  TX Buffer Level Interrupt Flag
                TXBL: u1,
                ///  RX Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  RX Overflow Interrupt Flag
                RXOF: u1,
                ///  RX Underflow Interrupt Flag
                RXUF: u1,
                ///  TX Overflow Interrupt Flag
                TXOF: u1,
                ///  TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Parity Error Interrupt Flag
                PERR: u1,
                ///  Framing Error Interrupt Flag
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Set RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Set RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Set RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Set TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Set TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Set Parity Error Interrupt Flag
                PERR: u1,
                ///  Set Framing Error Interrupt Flag
                FERR: u1,
                ///  Set Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Set Slave-Select in Master mode Interrupt Flag
                SSM: u1,
                ///  Set Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Clear RX Buffer Full Interrupt Flag
                RXFULL: u1,
                ///  Clear RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Clear RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear TX Underflow Interrupt Flag
                TXUF: u1,
                ///  Clear Parity Error Interrupt Flag
                PERR: u1,
                ///  Clear Framing Error Interrupt Flag
                FERR: u1,
                ///  Clear Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Clear Slave-Select In Master Mode Interrupt Flag
                SSM: u1,
                ///  Clear Collision Check Fail Interrupt Flag
                CCF: u1,
                padding: u19,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Enable
                TXC: u1,
                ///  TX Buffer Level Interrupt Enable
                TXBL: u1,
                ///  RX Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  RX Buffer Full Interrupt Enable
                RXFULL: u1,
                ///  RX Overflow Interrupt Enable
                RXOF: u1,
                ///  RX Underflow Interrupt Enable
                RXUF: u1,
                ///  TX Overflow Interrupt Enable
                TXOF: u1,
                ///  TX Underflow Interrupt Enable
                TXUF: u1,
                ///  Parity Error Interrupt Enable
                PERR: u1,
                ///  Framing Error Interrupt Enable
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Enable
                MPAF: u1,
                ///  Slave-Select In Master Mode Interrupt Enable
                SSM: u1,
                ///  Collision Check Fail Interrupt Enable
                CCF: u1,
                padding: u19,
            }),
            ///  IrDA Control Register
            IRCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable IrDA Module
                IREN: u1,
                ///  IrDA TX Pulse Width
                IRPW: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  IrDA pulse width is 1/16 for OVS=0 and 1/8 for OVS=1
                        ONE = 0x0,
                        ///  IrDA pulse width is 2/16 for OVS=0 and 2/8 for OVS=1
                        TWO = 0x1,
                        ///  IrDA pulse width is 3/16 for OVS=0 and 3/8 for OVS=1
                        THREE = 0x2,
                        ///  IrDA pulse width is 4/16 for OVS=0 and 4/8 for OVS=1
                        FOUR = 0x3,
                    },
                },
                ///  IrDA RX Filter
                IRFILT: u1,
                ///  IrDA PRS Channel Select
                IRPRSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                    },
                },
                ///  IrDA PRS Channel Enable
                IRPRSEN: u1,
                padding: u24,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  RX Pin Enable
                RXPEN: u1,
                ///  TX Pin Enable
                TXPEN: u1,
                ///  CS Pin Enable
                CSPEN: u1,
                ///  CLK Pin Enable
                CLKPEN: u1,
                reserved8: u4,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  USART Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  RX PRS Channel Select
                RXPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  PRS RX Enable
                RXPRS: u1,
                padding: u27,
            }),
            ///  I2S Control Register
            I2SCTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable I2S Mode
                EN: u1,
                ///  Stero or Mono
                MONO: u1,
                ///  Justification of I2S Data
                JUSTIFY: u1,
                ///  Separate DMA Request For Left/Right Data
                DMASPLIT: u1,
                ///  Delay on I2S data
                DELAY: u1,
                reserved8: u3,
                ///  I2S Word Format
                FORMAT: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  32-bit word, 32-bit data
                        W32D32 = 0x0,
                        ///  32-bit word, 32-bit data with 8 lsb masked
                        W32D24M = 0x1,
                        ///  32-bit word, 24-bit data
                        W32D24 = 0x2,
                        ///  32-bit word, 16-bit data
                        W32D16 = 0x3,
                        ///  32-bit word, 8-bit data
                        W32D8 = 0x4,
                        ///  16-bit word, 16-bit data
                        W16D16 = 0x5,
                        ///  16-bit word, 8-bit data
                        W16D8 = 0x6,
                        ///  8-bit word, 8-bit data
                        W8D8 = 0x7,
                    },
                },
                padding: u21,
            }),
        };

        ///  TIMER0
        pub const TIMER0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Timer Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Up-count mode
                        UP = 0x0,
                        ///  Down-count mode
                        DOWN = 0x1,
                        ///  Up/down-count mode
                        UPDOWN = 0x2,
                        ///  Quadrature decoder mode
                        QDEC = 0x3,
                    },
                },
                reserved3: u1,
                ///  Timer Start/Stop/Reload Synchronization
                SYNC: u1,
                ///  One-shot Mode Enable
                OSMEN: u1,
                ///  Quadrature Decoder Mode Selection
                QDM: u1,
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                ///  DMA Request Clear on Active
                DMACLRACT: u1,
                ///  Timer Rising Input Edge Action
                RISEA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                ///  Timer Falling Input Edge Action
                FALLA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                reserved13: u1,
                ///  2x Count Mode
                X2CNT: u1,
                reserved16: u2,
                ///  Clock Source Select
                CLKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Prescaled HFPERCLK
                        PRESCHFPERCLK = 0x0,
                        ///  Compare/Capture Channel 1 Input
                        CC1 = 0x1,
                        ///  Timer is clocked by underflow(down-count) or overflow(up-count) in the lower numbered neighbor Timer
                        TIMEROUF = 0x2,
                        _,
                    },
                },
                reserved24: u6,
                ///  Prescaler Setting
                PRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                ///  Always Track Inputs
                ATI: u1,
                ///  Reload-Start Sets Compare Output initial State
                RSSCOIST: u1,
                padding: u2,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Start Timer
                START: u1,
                ///  Stop Timer
                STOP: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Running
                RUNNING: u1,
                ///  Direction
                DIR: u1,
                ///  TOPB Valid
                TOPBV: u1,
                reserved8: u5,
                ///  CC0 CCVB Valid
                CCVBV0: u1,
                ///  CC1 CCVB Valid
                CCVBV1: u1,
                ///  CC2 CCVB Valid
                CCVBV2: u1,
                reserved16: u5,
                ///  CC0 Input Capture Valid
                ICV0: u1,
                ///  CC1 Input Capture Valid
                ICV1: u1,
                ///  CC2 Input Capture Valid
                ICV2: u1,
                reserved24: u5,
                ///  CC0 Polarity
                CCPOL0: u1,
                ///  CC1 Polarity
                CCPOL1: u1,
                ///  CC2 Polarity
                CCPOL2: u1,
                padding: u5,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Underflow Interrupt Enable
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Enable
                CC0: u1,
                ///  CC Channel 1 Interrupt Enable
                CC1: u1,
                ///  CC Channel 2 Interrupt Enable
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Enable
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Enable
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Enable
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag
                OF: u1,
                ///  Underflow Interrupt Flag
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Set
                OF: u1,
                ///  Underflow Interrupt Flag Set
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Set
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Set
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Set
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Clear
                OF: u1,
                ///  Underflow Interrupt Flag Clear
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Clear
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Clear
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Clear
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Counter Top Value Register
            TOP: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value
                TOP: u16,
                padding: u16,
            }),
            ///  Counter Top Value Buffer Register
            TOPB: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value Buffer
                TOPB: u16,
                padding: u16,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  CC Channel 0 Pin Enable
                CC0PEN: u1,
                ///  CC Channel 1 Pin Enable
                CC1PEN: u1,
                ///  CC Channel 2 Pin Enable
                CC2PEN: u1,
                reserved8: u5,
                ///  CC Channel 0 Complementary Dead-Time Insertion Pin Enable
                CDTI0PEN: u1,
                ///  CC Channel 1 Complementary Dead-Time Insertion Pin Enable
                CDTI1PEN: u1,
                ///  CC Channel 2 Complementary Dead-Time Insertion Pin Enable
                CDTI2PEN: u1,
                reserved16: u5,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u13,
            }),
            reserved48: [4]u8,
            ///  CC Channel Control Register
            CC0_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC0_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC0_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC0_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC1_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC1_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC1_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC1_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC2_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC2_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC2_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC2_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            reserved112: [16]u8,
            ///  DTI Control Register
            DTCTRL: mmio.Mmio(packed struct(u32) {
                ///  DTI Enable
                DTEN: u1,
                ///  DTI Automatic Start-up Functionality
                DTDAS: u1,
                ///  DTI Inactive Polarity
                DTIPOL: u1,
                ///  DTI Complementary Output Invert.
                DTCINV: u1,
                ///  DTI PRS Source Channel Select
                DTPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                reserved24: u16,
                ///  DTI PRS Source Enable
                DTPRSEN: u1,
                padding: u7,
            }),
            ///  DTI Time Control Register
            DTTIME: mmio.Mmio(packed struct(u32) {
                ///  DTI Prescaler Setting
                DTPRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                reserved8: u4,
                ///  DTI Rise-time
                DTRISET: u6,
                reserved16: u2,
                ///  DTI Fall-time
                DTFALLT: u6,
                padding: u10,
            }),
            ///  DTI Fault Configuration Register
            DTFC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS Fault Source 0 Select
                DTPRS0FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 0
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 0
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 0
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 0
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 0
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 0
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 0
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 0
                        PRSCH7 = 0x7,
                    },
                },
                reserved8: u5,
                ///  DTI PRS Fault Source 1 Select
                DTPRS1FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 1
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 1
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 1
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 1
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 1
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 1
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 1
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 1
                        PRSCH7 = 0x7,
                    },
                },
                reserved16: u5,
                ///  DTI Fault Action
                DTFA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on fault
                        NONE = 0x0,
                        ///  Set outputs inactive
                        INACTIVE = 0x1,
                        ///  Clear outputs
                        CLEAR = 0x2,
                        ///  Tristate outputs
                        TRISTATE = 0x3,
                    },
                },
                reserved24: u6,
                ///  DTI PRS 0 Fault Enable
                DTPRS0FEN: u1,
                ///  DTI PRS 1 Fault Enable
                DTPRS1FEN: u1,
                ///  DTI Debugger Fault Enable
                DTDBGFEN: u1,
                ///  DTI Lockup Fault Enable
                DTLOCKUPFEN: u1,
                padding: u4,
            }),
            ///  DTI Output Generation Enable Register
            DTOGEN: mmio.Mmio(packed struct(u32) {
                ///  DTI CC0 Output Generation Enable
                DTOGCC0EN: u1,
                ///  DTI CC1 Output Generation Enable
                DTOGCC1EN: u1,
                ///  DTI CC2 Output Generation Enable
                DTOGCC2EN: u1,
                ///  DTI CDTI0 Output Generation Enable
                DTOGCDTI0EN: u1,
                ///  DTI CDTI1 Output Generation Enable
                DTOGCDTI1EN: u1,
                ///  DTI CDTI2 Output Generation Enable
                DTOGCDTI2EN: u1,
                padding: u26,
            }),
            ///  DTI Fault Register
            DTFAULT: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS 0 Fault
                DTPRS0F: u1,
                ///  DTI PRS 1 Fault
                DTPRS1F: u1,
                ///  DTI Debugger Fault
                DTDBGF: u1,
                ///  DTI Lockup Fault
                DTLOCKUPF: u1,
                padding: u28,
            }),
            ///  DTI Fault Clear Register
            DTFAULTC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS0 Fault Clear
                DTPRS0FC: u1,
                ///  DTI PRS1 Fault Clear
                DTPRS1FC: u1,
                ///  DTI Debugger Fault Clear
                DTDBGFC: u1,
                ///  DTI Lockup Fault Clear
                TLOCKUPFC: u1,
                padding: u28,
            }),
            ///  DTI Configuration Lock Register
            DTLOCK: mmio.Mmio(packed struct(u32) {
                ///  DTI Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
        };

        ///  TIMER1
        pub const TIMER1 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Timer Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Up-count mode
                        UP = 0x0,
                        ///  Down-count mode
                        DOWN = 0x1,
                        ///  Up/down-count mode
                        UPDOWN = 0x2,
                        ///  Quadrature decoder mode
                        QDEC = 0x3,
                    },
                },
                reserved3: u1,
                ///  Timer Start/Stop/Reload Synchronization
                SYNC: u1,
                ///  One-shot Mode Enable
                OSMEN: u1,
                ///  Quadrature Decoder Mode Selection
                QDM: u1,
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                ///  DMA Request Clear on Active
                DMACLRACT: u1,
                ///  Timer Rising Input Edge Action
                RISEA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                ///  Timer Falling Input Edge Action
                FALLA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                reserved13: u1,
                ///  2x Count Mode
                X2CNT: u1,
                reserved16: u2,
                ///  Clock Source Select
                CLKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Prescaled HFPERCLK
                        PRESCHFPERCLK = 0x0,
                        ///  Compare/Capture Channel 1 Input
                        CC1 = 0x1,
                        ///  Timer is clocked by underflow(down-count) or overflow(up-count) in the lower numbered neighbor Timer
                        TIMEROUF = 0x2,
                        _,
                    },
                },
                reserved24: u6,
                ///  Prescaler Setting
                PRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                ///  Always Track Inputs
                ATI: u1,
                ///  Reload-Start Sets Compare Output initial State
                RSSCOIST: u1,
                padding: u2,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Start Timer
                START: u1,
                ///  Stop Timer
                STOP: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Running
                RUNNING: u1,
                ///  Direction
                DIR: u1,
                ///  TOPB Valid
                TOPBV: u1,
                reserved8: u5,
                ///  CC0 CCVB Valid
                CCVBV0: u1,
                ///  CC1 CCVB Valid
                CCVBV1: u1,
                ///  CC2 CCVB Valid
                CCVBV2: u1,
                reserved16: u5,
                ///  CC0 Input Capture Valid
                ICV0: u1,
                ///  CC1 Input Capture Valid
                ICV1: u1,
                ///  CC2 Input Capture Valid
                ICV2: u1,
                reserved24: u5,
                ///  CC0 Polarity
                CCPOL0: u1,
                ///  CC1 Polarity
                CCPOL1: u1,
                ///  CC2 Polarity
                CCPOL2: u1,
                padding: u5,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Underflow Interrupt Enable
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Enable
                CC0: u1,
                ///  CC Channel 1 Interrupt Enable
                CC1: u1,
                ///  CC Channel 2 Interrupt Enable
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Enable
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Enable
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Enable
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag
                OF: u1,
                ///  Underflow Interrupt Flag
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Set
                OF: u1,
                ///  Underflow Interrupt Flag Set
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Set
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Set
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Set
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Clear
                OF: u1,
                ///  Underflow Interrupt Flag Clear
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Clear
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Clear
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Clear
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Counter Top Value Register
            TOP: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value
                TOP: u16,
                padding: u16,
            }),
            ///  Counter Top Value Buffer Register
            TOPB: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value Buffer
                TOPB: u16,
                padding: u16,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  CC Channel 0 Pin Enable
                CC0PEN: u1,
                ///  CC Channel 1 Pin Enable
                CC1PEN: u1,
                ///  CC Channel 2 Pin Enable
                CC2PEN: u1,
                reserved8: u5,
                ///  CC Channel 0 Complementary Dead-Time Insertion Pin Enable
                CDTI0PEN: u1,
                ///  CC Channel 1 Complementary Dead-Time Insertion Pin Enable
                CDTI1PEN: u1,
                ///  CC Channel 2 Complementary Dead-Time Insertion Pin Enable
                CDTI2PEN: u1,
                reserved16: u5,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u13,
            }),
            reserved48: [4]u8,
            ///  CC Channel Control Register
            CC0_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC0_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC0_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC0_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC1_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC1_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC1_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC1_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC2_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC2_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC2_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC2_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            reserved112: [16]u8,
            ///  DTI Control Register
            DTCTRL: mmio.Mmio(packed struct(u32) {
                ///  DTI Enable
                DTEN: u1,
                ///  DTI Automatic Start-up Functionality
                DTDAS: u1,
                ///  DTI Inactive Polarity
                DTIPOL: u1,
                ///  DTI Complementary Output Invert.
                DTCINV: u1,
                ///  DTI PRS Source Channel Select
                DTPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                reserved24: u16,
                ///  DTI PRS Source Enable
                DTPRSEN: u1,
                padding: u7,
            }),
            ///  DTI Time Control Register
            DTTIME: mmio.Mmio(packed struct(u32) {
                ///  DTI Prescaler Setting
                DTPRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                reserved8: u4,
                ///  DTI Rise-time
                DTRISET: u6,
                reserved16: u2,
                ///  DTI Fall-time
                DTFALLT: u6,
                padding: u10,
            }),
            ///  DTI Fault Configuration Register
            DTFC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS Fault Source 0 Select
                DTPRS0FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 0
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 0
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 0
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 0
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 0
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 0
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 0
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 0
                        PRSCH7 = 0x7,
                    },
                },
                reserved8: u5,
                ///  DTI PRS Fault Source 1 Select
                DTPRS1FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 1
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 1
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 1
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 1
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 1
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 1
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 1
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 1
                        PRSCH7 = 0x7,
                    },
                },
                reserved16: u5,
                ///  DTI Fault Action
                DTFA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on fault
                        NONE = 0x0,
                        ///  Set outputs inactive
                        INACTIVE = 0x1,
                        ///  Clear outputs
                        CLEAR = 0x2,
                        ///  Tristate outputs
                        TRISTATE = 0x3,
                    },
                },
                reserved24: u6,
                ///  DTI PRS 0 Fault Enable
                DTPRS0FEN: u1,
                ///  DTI PRS 1 Fault Enable
                DTPRS1FEN: u1,
                ///  DTI Debugger Fault Enable
                DTDBGFEN: u1,
                ///  DTI Lockup Fault Enable
                DTLOCKUPFEN: u1,
                padding: u4,
            }),
            ///  DTI Output Generation Enable Register
            DTOGEN: mmio.Mmio(packed struct(u32) {
                ///  DTI CC0 Output Generation Enable
                DTOGCC0EN: u1,
                ///  DTI CC1 Output Generation Enable
                DTOGCC1EN: u1,
                ///  DTI CC2 Output Generation Enable
                DTOGCC2EN: u1,
                ///  DTI CDTI0 Output Generation Enable
                DTOGCDTI0EN: u1,
                ///  DTI CDTI1 Output Generation Enable
                DTOGCDTI1EN: u1,
                ///  DTI CDTI2 Output Generation Enable
                DTOGCDTI2EN: u1,
                padding: u26,
            }),
            ///  DTI Fault Register
            DTFAULT: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS 0 Fault
                DTPRS0F: u1,
                ///  DTI PRS 1 Fault
                DTPRS1F: u1,
                ///  DTI Debugger Fault
                DTDBGF: u1,
                ///  DTI Lockup Fault
                DTLOCKUPF: u1,
                padding: u28,
            }),
            ///  DTI Fault Clear Register
            DTFAULTC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS0 Fault Clear
                DTPRS0FC: u1,
                ///  DTI PRS1 Fault Clear
                DTPRS1FC: u1,
                ///  DTI Debugger Fault Clear
                DTDBGFC: u1,
                ///  DTI Lockup Fault Clear
                TLOCKUPFC: u1,
                padding: u28,
            }),
            ///  DTI Configuration Lock Register
            DTLOCK: mmio.Mmio(packed struct(u32) {
                ///  DTI Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
        };

        ///  TIMER2
        pub const TIMER2 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Timer Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Up-count mode
                        UP = 0x0,
                        ///  Down-count mode
                        DOWN = 0x1,
                        ///  Up/down-count mode
                        UPDOWN = 0x2,
                        ///  Quadrature decoder mode
                        QDEC = 0x3,
                    },
                },
                reserved3: u1,
                ///  Timer Start/Stop/Reload Synchronization
                SYNC: u1,
                ///  One-shot Mode Enable
                OSMEN: u1,
                ///  Quadrature Decoder Mode Selection
                QDM: u1,
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                ///  DMA Request Clear on Active
                DMACLRACT: u1,
                ///  Timer Rising Input Edge Action
                RISEA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                ///  Timer Falling Input Edge Action
                FALLA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                reserved13: u1,
                ///  2x Count Mode
                X2CNT: u1,
                reserved16: u2,
                ///  Clock Source Select
                CLKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Prescaled HFPERCLK
                        PRESCHFPERCLK = 0x0,
                        ///  Compare/Capture Channel 1 Input
                        CC1 = 0x1,
                        ///  Timer is clocked by underflow(down-count) or overflow(up-count) in the lower numbered neighbor Timer
                        TIMEROUF = 0x2,
                        _,
                    },
                },
                reserved24: u6,
                ///  Prescaler Setting
                PRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                ///  Always Track Inputs
                ATI: u1,
                ///  Reload-Start Sets Compare Output initial State
                RSSCOIST: u1,
                padding: u2,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Start Timer
                START: u1,
                ///  Stop Timer
                STOP: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Running
                RUNNING: u1,
                ///  Direction
                DIR: u1,
                ///  TOPB Valid
                TOPBV: u1,
                reserved8: u5,
                ///  CC0 CCVB Valid
                CCVBV0: u1,
                ///  CC1 CCVB Valid
                CCVBV1: u1,
                ///  CC2 CCVB Valid
                CCVBV2: u1,
                reserved16: u5,
                ///  CC0 Input Capture Valid
                ICV0: u1,
                ///  CC1 Input Capture Valid
                ICV1: u1,
                ///  CC2 Input Capture Valid
                ICV2: u1,
                reserved24: u5,
                ///  CC0 Polarity
                CCPOL0: u1,
                ///  CC1 Polarity
                CCPOL1: u1,
                ///  CC2 Polarity
                CCPOL2: u1,
                padding: u5,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Underflow Interrupt Enable
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Enable
                CC0: u1,
                ///  CC Channel 1 Interrupt Enable
                CC1: u1,
                ///  CC Channel 2 Interrupt Enable
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Enable
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Enable
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Enable
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag
                OF: u1,
                ///  Underflow Interrupt Flag
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Set
                OF: u1,
                ///  Underflow Interrupt Flag Set
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Set
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Set
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Set
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Clear
                OF: u1,
                ///  Underflow Interrupt Flag Clear
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Clear
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Clear
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Clear
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Counter Top Value Register
            TOP: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value
                TOP: u16,
                padding: u16,
            }),
            ///  Counter Top Value Buffer Register
            TOPB: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value Buffer
                TOPB: u16,
                padding: u16,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  CC Channel 0 Pin Enable
                CC0PEN: u1,
                ///  CC Channel 1 Pin Enable
                CC1PEN: u1,
                ///  CC Channel 2 Pin Enable
                CC2PEN: u1,
                reserved8: u5,
                ///  CC Channel 0 Complementary Dead-Time Insertion Pin Enable
                CDTI0PEN: u1,
                ///  CC Channel 1 Complementary Dead-Time Insertion Pin Enable
                CDTI1PEN: u1,
                ///  CC Channel 2 Complementary Dead-Time Insertion Pin Enable
                CDTI2PEN: u1,
                reserved16: u5,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u13,
            }),
            reserved48: [4]u8,
            ///  CC Channel Control Register
            CC0_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC0_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC0_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC0_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC1_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC1_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC1_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC1_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC2_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC2_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC2_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC2_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            reserved112: [16]u8,
            ///  DTI Control Register
            DTCTRL: mmio.Mmio(packed struct(u32) {
                ///  DTI Enable
                DTEN: u1,
                ///  DTI Automatic Start-up Functionality
                DTDAS: u1,
                ///  DTI Inactive Polarity
                DTIPOL: u1,
                ///  DTI Complementary Output Invert.
                DTCINV: u1,
                ///  DTI PRS Source Channel Select
                DTPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                reserved24: u16,
                ///  DTI PRS Source Enable
                DTPRSEN: u1,
                padding: u7,
            }),
            ///  DTI Time Control Register
            DTTIME: mmio.Mmio(packed struct(u32) {
                ///  DTI Prescaler Setting
                DTPRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                reserved8: u4,
                ///  DTI Rise-time
                DTRISET: u6,
                reserved16: u2,
                ///  DTI Fall-time
                DTFALLT: u6,
                padding: u10,
            }),
            ///  DTI Fault Configuration Register
            DTFC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS Fault Source 0 Select
                DTPRS0FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 0
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 0
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 0
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 0
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 0
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 0
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 0
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 0
                        PRSCH7 = 0x7,
                    },
                },
                reserved8: u5,
                ///  DTI PRS Fault Source 1 Select
                DTPRS1FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 1
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 1
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 1
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 1
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 1
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 1
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 1
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 1
                        PRSCH7 = 0x7,
                    },
                },
                reserved16: u5,
                ///  DTI Fault Action
                DTFA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on fault
                        NONE = 0x0,
                        ///  Set outputs inactive
                        INACTIVE = 0x1,
                        ///  Clear outputs
                        CLEAR = 0x2,
                        ///  Tristate outputs
                        TRISTATE = 0x3,
                    },
                },
                reserved24: u6,
                ///  DTI PRS 0 Fault Enable
                DTPRS0FEN: u1,
                ///  DTI PRS 1 Fault Enable
                DTPRS1FEN: u1,
                ///  DTI Debugger Fault Enable
                DTDBGFEN: u1,
                ///  DTI Lockup Fault Enable
                DTLOCKUPFEN: u1,
                padding: u4,
            }),
            ///  DTI Output Generation Enable Register
            DTOGEN: mmio.Mmio(packed struct(u32) {
                ///  DTI CC0 Output Generation Enable
                DTOGCC0EN: u1,
                ///  DTI CC1 Output Generation Enable
                DTOGCC1EN: u1,
                ///  DTI CC2 Output Generation Enable
                DTOGCC2EN: u1,
                ///  DTI CDTI0 Output Generation Enable
                DTOGCDTI0EN: u1,
                ///  DTI CDTI1 Output Generation Enable
                DTOGCDTI1EN: u1,
                ///  DTI CDTI2 Output Generation Enable
                DTOGCDTI2EN: u1,
                padding: u26,
            }),
            ///  DTI Fault Register
            DTFAULT: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS 0 Fault
                DTPRS0F: u1,
                ///  DTI PRS 1 Fault
                DTPRS1F: u1,
                ///  DTI Debugger Fault
                DTDBGF: u1,
                ///  DTI Lockup Fault
                DTLOCKUPF: u1,
                padding: u28,
            }),
            ///  DTI Fault Clear Register
            DTFAULTC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS0 Fault Clear
                DTPRS0FC: u1,
                ///  DTI PRS1 Fault Clear
                DTPRS1FC: u1,
                ///  DTI Debugger Fault Clear
                DTDBGFC: u1,
                ///  DTI Lockup Fault Clear
                TLOCKUPFC: u1,
                padding: u28,
            }),
            ///  DTI Configuration Lock Register
            DTLOCK: mmio.Mmio(packed struct(u32) {
                ///  DTI Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
        };

        ///  TIMER3
        pub const TIMER3 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Timer Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Up-count mode
                        UP = 0x0,
                        ///  Down-count mode
                        DOWN = 0x1,
                        ///  Up/down-count mode
                        UPDOWN = 0x2,
                        ///  Quadrature decoder mode
                        QDEC = 0x3,
                    },
                },
                reserved3: u1,
                ///  Timer Start/Stop/Reload Synchronization
                SYNC: u1,
                ///  One-shot Mode Enable
                OSMEN: u1,
                ///  Quadrature Decoder Mode Selection
                QDM: u1,
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                ///  DMA Request Clear on Active
                DMACLRACT: u1,
                ///  Timer Rising Input Edge Action
                RISEA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                ///  Timer Falling Input Edge Action
                FALLA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action
                        NONE = 0x0,
                        ///  Start counter without reload
                        START = 0x1,
                        ///  Stop counter without reload
                        STOP = 0x2,
                        ///  Reload and start counter
                        RELOADSTART = 0x3,
                    },
                },
                reserved13: u1,
                ///  2x Count Mode
                X2CNT: u1,
                reserved16: u2,
                ///  Clock Source Select
                CLKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Prescaled HFPERCLK
                        PRESCHFPERCLK = 0x0,
                        ///  Compare/Capture Channel 1 Input
                        CC1 = 0x1,
                        ///  Timer is clocked by underflow(down-count) or overflow(up-count) in the lower numbered neighbor Timer
                        TIMEROUF = 0x2,
                        _,
                    },
                },
                reserved24: u6,
                ///  Prescaler Setting
                PRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                ///  Always Track Inputs
                ATI: u1,
                ///  Reload-Start Sets Compare Output initial State
                RSSCOIST: u1,
                padding: u2,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Start Timer
                START: u1,
                ///  Stop Timer
                STOP: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Running
                RUNNING: u1,
                ///  Direction
                DIR: u1,
                ///  TOPB Valid
                TOPBV: u1,
                reserved8: u5,
                ///  CC0 CCVB Valid
                CCVBV0: u1,
                ///  CC1 CCVB Valid
                CCVBV1: u1,
                ///  CC2 CCVB Valid
                CCVBV2: u1,
                reserved16: u5,
                ///  CC0 Input Capture Valid
                ICV0: u1,
                ///  CC1 Input Capture Valid
                ICV1: u1,
                ///  CC2 Input Capture Valid
                ICV2: u1,
                reserved24: u5,
                ///  CC0 Polarity
                CCPOL0: u1,
                ///  CC1 Polarity
                CCPOL1: u1,
                ///  CC2 Polarity
                CCPOL2: u1,
                padding: u5,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Underflow Interrupt Enable
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Enable
                CC0: u1,
                ///  CC Channel 1 Interrupt Enable
                CC1: u1,
                ///  CC Channel 2 Interrupt Enable
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Enable
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Enable
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Enable
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag
                OF: u1,
                ///  Underflow Interrupt Flag
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Set
                OF: u1,
                ///  Underflow Interrupt Flag Set
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Set
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Set
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Set
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Set
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag Clear
                OF: u1,
                ///  Underflow Interrupt Flag Clear
                UF: u1,
                reserved4: u2,
                ///  CC Channel 0 Interrupt Flag Clear
                CC0: u1,
                ///  CC Channel 1 Interrupt Flag Clear
                CC1: u1,
                ///  CC Channel 2 Interrupt Flag Clear
                CC2: u1,
                reserved8: u1,
                ///  CC Channel 0 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF0: u1,
                ///  CC Channel 1 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF1: u1,
                ///  CC Channel 2 Input Capture Buffer Overflow Interrupt Flag Clear
                ICBOF2: u1,
                padding: u21,
            }),
            ///  Counter Top Value Register
            TOP: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value
                TOP: u16,
                padding: u16,
            }),
            ///  Counter Top Value Buffer Register
            TOPB: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value Buffer
                TOPB: u16,
                padding: u16,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  CC Channel 0 Pin Enable
                CC0PEN: u1,
                ///  CC Channel 1 Pin Enable
                CC1PEN: u1,
                ///  CC Channel 2 Pin Enable
                CC2PEN: u1,
                reserved8: u5,
                ///  CC Channel 0 Complementary Dead-Time Insertion Pin Enable
                CDTI0PEN: u1,
                ///  CC Channel 1 Complementary Dead-Time Insertion Pin Enable
                CDTI1PEN: u1,
                ///  CC Channel 2 Complementary Dead-Time Insertion Pin Enable
                CDTI2PEN: u1,
                reserved16: u5,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        _,
                    },
                },
                padding: u13,
            }),
            reserved48: [4]u8,
            ///  CC Channel Control Register
            CC0_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC0_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC0_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC0_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC1_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC1_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC1_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC1_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            ///  CC Channel Control Register
            CC2_CTRL: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Mode
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Compare/Capture channel turned off
                        OFF = 0x0,
                        ///  Input capture
                        INPUTCAPTURE = 0x1,
                        ///  Output compare
                        OUTPUTCOMPARE = 0x2,
                        ///  Pulse-Width Modulation
                        PWM = 0x3,
                    },
                },
                ///  Output Invert
                OUTINV: u1,
                reserved4: u1,
                ///  Compare Output Initial State
                COIST: u1,
                reserved8: u3,
                ///  Compare Match Output Action
                CMOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on compare match
                        NONE = 0x0,
                        ///  Toggle output on compare match
                        TOGGLE = 0x1,
                        ///  Clear output on compare match
                        CLEAR = 0x2,
                        ///  Set output on compare match
                        SET = 0x3,
                    },
                },
                ///  Counter Overflow Output Action
                COFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter overflow
                        NONE = 0x0,
                        ///  Toggle output on counter overflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter overflow
                        CLEAR = 0x2,
                        ///  Set output on counter overflow
                        SET = 0x3,
                    },
                },
                ///  Counter Underflow Output Action
                CUFOA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on counter underflow
                        NONE = 0x0,
                        ///  Toggle output on counter underflow
                        TOGGLE = 0x1,
                        ///  Clear output on counter underflow
                        CLEAR = 0x2,
                        ///  Set output on counter underflow
                        SET = 0x3,
                    },
                },
                reserved16: u2,
                ///  Compare/Capture Channel PRS Input Channel Selection
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  Input Selection
                INSEL: u1,
                ///  Digital Filter
                FILT: u1,
                reserved24: u2,
                ///  Input Capture Edge Select
                ICEDGE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Rising edges detected
                        RISING = 0x0,
                        ///  Falling edges detected
                        FALLING = 0x1,
                        ///  Both edges detected
                        BOTH = 0x2,
                        ///  No edge detection, signal is left as it is
                        NONE = 0x3,
                    },
                },
                ///  Input Capture Event Control
                ICEVCTRL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  PRS output pulse, interrupt flag and DMA request set on every capture
                        EVERYEDGE = 0x0,
                        ///  PRS output pulse, interrupt flag and DMA request set on every second capture
                        EVERYSECONDEDGE = 0x1,
                        ///  PRS output pulse, interrupt flag and DMA request set on rising edge only (if ICEDGE = BOTH)
                        RISING = 0x2,
                        ///  PRS output pulse, interrupt flag and DMA request set on falling edge only (if ICEDGE = BOTH)
                        FALLING = 0x3,
                    },
                },
                padding: u4,
            }),
            ///  CC Channel Value Register
            CC2_CCV: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value
                CCV: u16,
                padding: u16,
            }),
            ///  CC Channel Value Peek Register
            CC2_CCVP: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Peek
                CCVP: u16,
                padding: u16,
            }),
            ///  CC Channel Buffer Register
            CC2_CCVB: mmio.Mmio(packed struct(u32) {
                ///  CC Channel Value Buffer
                CCVB: u16,
                padding: u16,
            }),
            reserved112: [16]u8,
            ///  DTI Control Register
            DTCTRL: mmio.Mmio(packed struct(u32) {
                ///  DTI Enable
                DTEN: u1,
                ///  DTI Automatic Start-up Functionality
                DTDAS: u1,
                ///  DTI Inactive Polarity
                DTIPOL: u1,
                ///  DTI Complementary Output Invert.
                DTCINV: u1,
                ///  DTI PRS Source Channel Select
                DTPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected as input
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as input
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as input
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as input
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as input
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as input
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as input
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as input
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected as input
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected as input
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected as input
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected as input
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                reserved24: u16,
                ///  DTI PRS Source Enable
                DTPRSEN: u1,
                padding: u7,
            }),
            ///  DTI Time Control Register
            DTTIME: mmio.Mmio(packed struct(u32) {
                ///  DTI Prescaler Setting
                DTPRESC: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  The HFPERCLK is undivided
                        DIV1 = 0x0,
                        ///  The HFPERCLK is divided by 2
                        DIV2 = 0x1,
                        ///  The HFPERCLK is divided by 4
                        DIV4 = 0x2,
                        ///  The HFPERCLK is divided by 8
                        DIV8 = 0x3,
                        ///  The HFPERCLK is divided by 16
                        DIV16 = 0x4,
                        ///  The HFPERCLK is divided by 32
                        DIV32 = 0x5,
                        ///  The HFPERCLK is divided by 64
                        DIV64 = 0x6,
                        ///  The HFPERCLK is divided by 128
                        DIV128 = 0x7,
                        ///  The HFPERCLK is divided by 256
                        DIV256 = 0x8,
                        ///  The HFPERCLK is divided by 512
                        DIV512 = 0x9,
                        ///  The HFPERCLK is divided by 1024
                        DIV1024 = 0xa,
                        _,
                    },
                },
                reserved8: u4,
                ///  DTI Rise-time
                DTRISET: u6,
                reserved16: u2,
                ///  DTI Fall-time
                DTFALLT: u6,
                padding: u10,
            }),
            ///  DTI Fault Configuration Register
            DTFC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS Fault Source 0 Select
                DTPRS0FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 0
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 0
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 0
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 0
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 0
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 0
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 0
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 0
                        PRSCH7 = 0x7,
                    },
                },
                reserved8: u5,
                ///  DTI PRS Fault Source 1 Select
                DTPRS1FSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  PRS Channel 0 selected as fault source 1
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected as fault source 1
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected as fault source 1
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected as fault source 1
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected as fault source 1
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected as fault source 1
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected as fault source 1
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected as fault source 1
                        PRSCH7 = 0x7,
                    },
                },
                reserved16: u5,
                ///  DTI Fault Action
                DTFA: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No action on fault
                        NONE = 0x0,
                        ///  Set outputs inactive
                        INACTIVE = 0x1,
                        ///  Clear outputs
                        CLEAR = 0x2,
                        ///  Tristate outputs
                        TRISTATE = 0x3,
                    },
                },
                reserved24: u6,
                ///  DTI PRS 0 Fault Enable
                DTPRS0FEN: u1,
                ///  DTI PRS 1 Fault Enable
                DTPRS1FEN: u1,
                ///  DTI Debugger Fault Enable
                DTDBGFEN: u1,
                ///  DTI Lockup Fault Enable
                DTLOCKUPFEN: u1,
                padding: u4,
            }),
            ///  DTI Output Generation Enable Register
            DTOGEN: mmio.Mmio(packed struct(u32) {
                ///  DTI CC0 Output Generation Enable
                DTOGCC0EN: u1,
                ///  DTI CC1 Output Generation Enable
                DTOGCC1EN: u1,
                ///  DTI CC2 Output Generation Enable
                DTOGCC2EN: u1,
                ///  DTI CDTI0 Output Generation Enable
                DTOGCDTI0EN: u1,
                ///  DTI CDTI1 Output Generation Enable
                DTOGCDTI1EN: u1,
                ///  DTI CDTI2 Output Generation Enable
                DTOGCDTI2EN: u1,
                padding: u26,
            }),
            ///  DTI Fault Register
            DTFAULT: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS 0 Fault
                DTPRS0F: u1,
                ///  DTI PRS 1 Fault
                DTPRS1F: u1,
                ///  DTI Debugger Fault
                DTDBGF: u1,
                ///  DTI Lockup Fault
                DTLOCKUPF: u1,
                padding: u28,
            }),
            ///  DTI Fault Clear Register
            DTFAULTC: mmio.Mmio(packed struct(u32) {
                ///  DTI PRS0 Fault Clear
                DTPRS0FC: u1,
                ///  DTI PRS1 Fault Clear
                DTPRS1FC: u1,
                ///  DTI Debugger Fault Clear
                DTDBGFC: u1,
                ///  DTI Lockup Fault Clear
                TLOCKUPFC: u1,
                padding: u28,
            }),
            ///  DTI Configuration Lock Register
            DTLOCK: mmio.Mmio(packed struct(u32) {
                ///  DTI Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
        };

        ///  ACMP0
        pub const ACMP0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Analog Comparator Enable
                EN: u1,
                ///  Input Mux Enable
                MUXEN: u1,
                ///  Inactive Value
                INACTVAL: u1,
                ///  Comparator GPIO Output Invert
                GPIOINV: u1,
                ///  Hysteresis Select
                HYSTSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  No hysteresis.
                        HYST0 = 0x0,
                        ///  ~15 mV hysteresis.
                        HYST1 = 0x1,
                        ///  ~22 mV hysteresis.
                        HYST2 = 0x2,
                        ///  ~29 mV hysteresis.
                        HYST3 = 0x3,
                        ///  ~36 mV hysteresis.
                        HYST4 = 0x4,
                        ///  ~43 mV hysteresis.
                        HYST5 = 0x5,
                        ///  ~50 mV hysteresis.
                        HYST6 = 0x6,
                        ///  ~57 mV hysteresis.
                        HYST7 = 0x7,
                    },
                },
                reserved8: u1,
                ///  Warm-up Time
                WARMTIME: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  4 HFPERCLK cycles.
                        @"4CYCLES" = 0x0,
                        ///  8 HFPERCLK cycles.
                        @"8CYCLES" = 0x1,
                        ///  16 HFPERCLK cycles.
                        @"16CYCLES" = 0x2,
                        ///  32 HFPERCLK cycles.
                        @"32CYCLES" = 0x3,
                        ///  64 HFPERCLK cycles.
                        @"64CYCLES" = 0x4,
                        ///  128 HFPERCLK cycles.
                        @"128CYCLES" = 0x5,
                        ///  256 HFPERCLK cycles.
                        @"256CYCLES" = 0x6,
                        ///  512 HFPERCLK cycles.
                        @"512CYCLES" = 0x7,
                    },
                },
                reserved16: u5,
                ///  Rising Edge Interrupt Sense
                IRISE: u1,
                ///  Falling Edge Interrupt Sense
                IFALL: u1,
                reserved24: u6,
                ///  Bias Configuration
                BIASPROG: u4,
                reserved30: u2,
                ///  Half Bias Current
                HALFBIAS: u1,
                ///  Full Bias Current
                FULLBIAS: u1,
            }),
            ///  Input Selection Register
            INPUTSEL: mmio.Mmio(packed struct(u32) {
                ///  Positive Input Select
                POSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Channel 0 as positive input.
                        CH0 = 0x0,
                        ///  Channel 1 as positive input.
                        CH1 = 0x1,
                        ///  Channel 2 as positive input.
                        CH2 = 0x2,
                        ///  Channel 3 as positive input.
                        CH3 = 0x3,
                        ///  Channel 4 as positive input.
                        CH4 = 0x4,
                        ///  Channel 5 as positive input.
                        CH5 = 0x5,
                        ///  Channel 6 as positive input.
                        CH6 = 0x6,
                        ///  Channel 7 as positive input.
                        CH7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Negative Input Select
                NEGSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Channel 0 as negative input.
                        CH0 = 0x0,
                        ///  Channel 1 as negative input.
                        CH1 = 0x1,
                        ///  Channel 2 as negative input.
                        CH2 = 0x2,
                        ///  Channel 3 as negative input.
                        CH3 = 0x3,
                        ///  Channel 4 as negative input.
                        CH4 = 0x4,
                        ///  Channel 5 as negative input.
                        CH5 = 0x5,
                        ///  Channel 6 as negative input.
                        CH6 = 0x6,
                        ///  Channel 7 as negative input.
                        CH7 = 0x7,
                        ///  1.25 V as negative input.
                        @"1V25" = 0x8,
                        ///  2.5 V as negative input.
                        @"2V5" = 0x9,
                        ///  Scaled VDD as negative input.
                        VDD = 0xa,
                        ///  Capacitive sense mode.
                        CAPSENSE = 0xb,
                        ///  DAC0 channel 0.
                        DAC0CH0 = 0xc,
                        ///  DAC0 channel 1.
                        DAC0CH1 = 0xd,
                        _,
                    },
                },
                ///  VDD Reference Level
                VDDLEVEL: u6,
                reserved16: u2,
                ///  Low Power Reference Mode
                LPREF: u1,
                reserved24: u7,
                ///  Capacitive Sense Mode Internal Resistor Enable
                CSRESEN: u1,
                reserved28: u3,
                ///  Capacitive Sense Mode Internal Resistor Select
                CSRESSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Internal capacitive sense resistor value 0.
                        RES0 = 0x0,
                        ///  Internal capacitive sense resistor value 1.
                        RES1 = 0x1,
                        ///  Internal capacitive sense resistor value 2.
                        RES2 = 0x2,
                        ///  Internal capacitive sense resistor value 3.
                        RES3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Analog Comparator Active
                ACMPACT: u1,
                ///  Analog Comparator Output
                ACMPOUT: u1,
                padding: u30,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Edge Trigger Interrupt Enable
                EDGE: u1,
                ///  Warm-up Interrupt Enable
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag
                EDGE: u1,
                ///  Warm-up Interrupt Flag
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag Set
                EDGE: u1,
                ///  Warm-up Interrupt Flag Set
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag Clear
                EDGE: u1,
                ///  Warm-up Interrupt Flag Clear
                WARMUP: u1,
                padding: u30,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  ACMP Output Pin Enable
                ACMPPEN: u1,
                reserved8: u7,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        _,
                    },
                },
                padding: u21,
            }),
        };

        ///  ACMP1
        pub const ACMP1 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Analog Comparator Enable
                EN: u1,
                ///  Input Mux Enable
                MUXEN: u1,
                ///  Inactive Value
                INACTVAL: u1,
                ///  Comparator GPIO Output Invert
                GPIOINV: u1,
                ///  Hysteresis Select
                HYSTSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  No hysteresis.
                        HYST0 = 0x0,
                        ///  ~15 mV hysteresis.
                        HYST1 = 0x1,
                        ///  ~22 mV hysteresis.
                        HYST2 = 0x2,
                        ///  ~29 mV hysteresis.
                        HYST3 = 0x3,
                        ///  ~36 mV hysteresis.
                        HYST4 = 0x4,
                        ///  ~43 mV hysteresis.
                        HYST5 = 0x5,
                        ///  ~50 mV hysteresis.
                        HYST6 = 0x6,
                        ///  ~57 mV hysteresis.
                        HYST7 = 0x7,
                    },
                },
                reserved8: u1,
                ///  Warm-up Time
                WARMTIME: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  4 HFPERCLK cycles.
                        @"4CYCLES" = 0x0,
                        ///  8 HFPERCLK cycles.
                        @"8CYCLES" = 0x1,
                        ///  16 HFPERCLK cycles.
                        @"16CYCLES" = 0x2,
                        ///  32 HFPERCLK cycles.
                        @"32CYCLES" = 0x3,
                        ///  64 HFPERCLK cycles.
                        @"64CYCLES" = 0x4,
                        ///  128 HFPERCLK cycles.
                        @"128CYCLES" = 0x5,
                        ///  256 HFPERCLK cycles.
                        @"256CYCLES" = 0x6,
                        ///  512 HFPERCLK cycles.
                        @"512CYCLES" = 0x7,
                    },
                },
                reserved16: u5,
                ///  Rising Edge Interrupt Sense
                IRISE: u1,
                ///  Falling Edge Interrupt Sense
                IFALL: u1,
                reserved24: u6,
                ///  Bias Configuration
                BIASPROG: u4,
                reserved30: u2,
                ///  Half Bias Current
                HALFBIAS: u1,
                ///  Full Bias Current
                FULLBIAS: u1,
            }),
            ///  Input Selection Register
            INPUTSEL: mmio.Mmio(packed struct(u32) {
                ///  Positive Input Select
                POSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Channel 0 as positive input.
                        CH0 = 0x0,
                        ///  Channel 1 as positive input.
                        CH1 = 0x1,
                        ///  Channel 2 as positive input.
                        CH2 = 0x2,
                        ///  Channel 3 as positive input.
                        CH3 = 0x3,
                        ///  Channel 4 as positive input.
                        CH4 = 0x4,
                        ///  Channel 5 as positive input.
                        CH5 = 0x5,
                        ///  Channel 6 as positive input.
                        CH6 = 0x6,
                        ///  Channel 7 as positive input.
                        CH7 = 0x7,
                    },
                },
                reserved4: u1,
                ///  Negative Input Select
                NEGSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Channel 0 as negative input.
                        CH0 = 0x0,
                        ///  Channel 1 as negative input.
                        CH1 = 0x1,
                        ///  Channel 2 as negative input.
                        CH2 = 0x2,
                        ///  Channel 3 as negative input.
                        CH3 = 0x3,
                        ///  Channel 4 as negative input.
                        CH4 = 0x4,
                        ///  Channel 5 as negative input.
                        CH5 = 0x5,
                        ///  Channel 6 as negative input.
                        CH6 = 0x6,
                        ///  Channel 7 as negative input.
                        CH7 = 0x7,
                        ///  1.25 V as negative input.
                        @"1V25" = 0x8,
                        ///  2.5 V as negative input.
                        @"2V5" = 0x9,
                        ///  Scaled VDD as negative input.
                        VDD = 0xa,
                        ///  Capacitive sense mode.
                        CAPSENSE = 0xb,
                        ///  DAC0 channel 0.
                        DAC0CH0 = 0xc,
                        ///  DAC0 channel 1.
                        DAC0CH1 = 0xd,
                        _,
                    },
                },
                ///  VDD Reference Level
                VDDLEVEL: u6,
                reserved16: u2,
                ///  Low Power Reference Mode
                LPREF: u1,
                reserved24: u7,
                ///  Capacitive Sense Mode Internal Resistor Enable
                CSRESEN: u1,
                reserved28: u3,
                ///  Capacitive Sense Mode Internal Resistor Select
                CSRESSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Internal capacitive sense resistor value 0.
                        RES0 = 0x0,
                        ///  Internal capacitive sense resistor value 1.
                        RES1 = 0x1,
                        ///  Internal capacitive sense resistor value 2.
                        RES2 = 0x2,
                        ///  Internal capacitive sense resistor value 3.
                        RES3 = 0x3,
                    },
                },
                padding: u2,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Analog Comparator Active
                ACMPACT: u1,
                ///  Analog Comparator Output
                ACMPOUT: u1,
                padding: u30,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Edge Trigger Interrupt Enable
                EDGE: u1,
                ///  Warm-up Interrupt Enable
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag
                EDGE: u1,
                ///  Warm-up Interrupt Flag
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag Set
                EDGE: u1,
                ///  Warm-up Interrupt Flag Set
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag Clear
                EDGE: u1,
                ///  Warm-up Interrupt Flag Clear
                WARMUP: u1,
                padding: u30,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  ACMP Output Pin Enable
                ACMPPEN: u1,
                reserved8: u7,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        _,
                    },
                },
                padding: u21,
            }),
        };

        ///  I2C0
        pub const I2C0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  I2C Enable
                EN: u1,
                ///  Addressable as Slave
                SLAVE: u1,
                ///  Automatic Acknowledge
                AUTOACK: u1,
                ///  Automatic STOP when Empty
                AUTOSE: u1,
                ///  Automatic STOP on NACK
                AUTOSN: u1,
                ///  Arbitration Disable
                ARBDIS: u1,
                ///  General Call Address Match Enable
                GCAMEN: u1,
                reserved8: u1,
                ///  Clock Low High Ratio
                CLHR: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The ratio between low period and high period counters (Nlow:Nhigh) is 4:4
                        STANDARD = 0x0,
                        ///  The ratio between low period and high period counters (Nlow:Nhigh) is 6:3
                        ASYMMETRIC = 0x1,
                        ///  The ratio between low period and high period counters (Nlow:Nhigh) is 11:6
                        FAST = 0x2,
                        _,
                    },
                },
                reserved12: u2,
                ///  Bus Idle Timeout
                BITO: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Timeout disabled
                        OFF = 0x0,
                        ///  Timeout after 40 prescaled clock cycles. In standard mode at 100 kHz, this results in a 50us timeout.
                        @"40PCC" = 0x1,
                        ///  Timeout after 80 prescaled clock cycles. In standard mode at 100 kHz, this results in a 100us timeout.
                        @"80PCC" = 0x2,
                        ///  Timeout after 160 prescaled clock cycles. In standard mode at 100 kHz, this results in a 200us timeout.
                        @"160PCC" = 0x3,
                    },
                },
                reserved15: u1,
                ///  Go Idle on Bus Idle Timeout
                GIBITO: u1,
                ///  Clock Low Timeout
                CLTO: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Timeout disabled
                        OFF = 0x0,
                        ///  Timeout after 40 prescaled clock cycles. In standard mode at 100 kHz, this results in a 50us timeout.
                        @"40PCC" = 0x1,
                        ///  Timeout after 80 prescaled clock cycles. In standard mode at 100 kHz, this results in a 100us timeout.
                        @"80PCC" = 0x2,
                        ///  Timeout after 160 prescaled clock cycles. In standard mode at 100 kHz, this results in a 200us timeout.
                        @"160PCC" = 0x3,
                        ///  Timeout after 320 prescaled clock cycles. In standard mode at 100 kHz, this results in a 400us timeout.
                        @"320PPC" = 0x4,
                        ///  Timeout after 1024 prescaled clock cycles. In standard mode at 100 kHz, this results in a 1280us timeout.
                        @"1024PPC" = 0x5,
                        _,
                    },
                },
                padding: u13,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Send start condition
                START: u1,
                ///  Send stop condition
                STOP: u1,
                ///  Send ACK
                ACK: u1,
                ///  Send NACK
                NACK: u1,
                ///  Continue transmission
                CONT: u1,
                ///  Abort transmission
                ABORT: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear Pending Commands
                CLEARPC: u1,
                padding: u24,
            }),
            ///  State Register
            STATE: mmio.Mmio(packed struct(u32) {
                ///  Bus Busy
                BUSY: u1,
                ///  Master
                MASTER: u1,
                ///  Transmitter
                TRANSMITTER: u1,
                ///  Nack Received
                NACKED: u1,
                ///  Bus Held
                BUSHOLD: u1,
                ///  Transmission State
                STATE: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  No transmission is being performed.
                        IDLE = 0x0,
                        ///  Waiting for idle. Will send a start condition as soon as the bus is idle.
                        WAIT = 0x1,
                        ///  Start transmitted or received
                        START = 0x2,
                        ///  Address transmitted or received
                        ADDR = 0x3,
                        ///  Address ack/nack transmitted or received
                        ADDRACK = 0x4,
                        ///  Data transmitted or received
                        DATA = 0x5,
                        ///  Data ack/nack transmitted or received
                        DATAACK = 0x6,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Pending START
                PSTART: u1,
                ///  Pending STOP
                PSTOP: u1,
                ///  Pending ACK
                PACK: u1,
                ///  Pending NACK
                PNACK: u1,
                ///  Pending continue
                PCONT: u1,
                ///  Pending abort
                PABORT: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                padding: u23,
            }),
            ///  Clock Division Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                ///  Clock Divider
                DIV: u9,
                padding: u23,
            }),
            ///  Slave Address Register
            SADDR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Slave address
                ADDR: u7,
                padding: u24,
            }),
            ///  Slave Address Mask Register
            SADDRMASK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Slave Address Mask
                MASK: u7,
                padding: u24,
            }),
            ///  Receive Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  Receive Buffer Data Peek Register
            RXDATAP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u8,
                padding: u24,
            }),
            ///  Transmit Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  START condition Interrupt Flag
                START: u1,
                ///  Repeated START condition Interrupt Flag
                RSTART: u1,
                ///  Address Interrupt Flag
                ADDR: u1,
                ///  Transfer Completed Interrupt Flag
                TXC: u1,
                ///  Transmit Buffer Level Interrupt Flag
                TXBL: u1,
                ///  Receive Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  Acknowledge Received Interrupt Flag
                ACK: u1,
                ///  Not Acknowledge Received Interrupt Flag
                NACK: u1,
                ///  Master STOP Condition Interrupt Flag
                MSTOP: u1,
                ///  Arbitration Lost Interrupt Flag
                ARBLOST: u1,
                ///  Bus Error Interrupt Flag
                BUSERR: u1,
                ///  Bus Held Interrupt Flag
                BUSHOLD: u1,
                ///  Transmit Buffer Overflow Interrupt Flag
                TXOF: u1,
                ///  Receive Buffer Underflow Interrupt Flag
                RXUF: u1,
                ///  Bus Idle Timeout Interrupt Flag
                BITO: u1,
                ///  Clock Low Timeout Interrupt Flag
                CLTO: u1,
                ///  Slave STOP condition Interrupt Flag
                SSTOP: u1,
                padding: u15,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set START Interrupt Flag
                START: u1,
                ///  Set Repeated START Interrupt Flag
                RSTART: u1,
                ///  Set Address Interrupt Flag
                ADDR: u1,
                ///  Set Transfer Completed Interrupt Flag
                TXC: u1,
                reserved6: u2,
                ///  Set Acknowledge Received Interrupt Flag
                ACK: u1,
                ///  Set Not Acknowledge Received Interrupt Flag
                NACK: u1,
                ///  Set MSTOP Interrupt Flag
                MSTOP: u1,
                ///  Set Arbitration Lost Interrupt Flag
                ARBLOST: u1,
                ///  Set Bus Error Interrupt Flag
                BUSERR: u1,
                ///  Set Bus Held Interrupt Flag
                BUSHOLD: u1,
                ///  Set Transmit Buffer Overflow Interrupt Flag
                TXOF: u1,
                ///  Set Receive Buffer Underflow Interrupt Flag
                RXUF: u1,
                ///  Set Bus Idle Timeout Interrupt Flag
                BITO: u1,
                ///  Set Clock Low Interrupt Flag
                CLTO: u1,
                ///  Set SSTOP Interrupt Flag
                SSTOP: u1,
                padding: u15,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear START Interrupt Flag
                START: u1,
                ///  Clear Repeated START Interrupt Flag
                RSTART: u1,
                ///  Clear Address Interrupt Flag
                ADDR: u1,
                ///  Clear Transfer Completed Interrupt Flag
                TXC: u1,
                reserved6: u2,
                ///  Clear Acknowledge Received Interrupt Flag
                ACK: u1,
                ///  Clear Not Acknowledge Received Interrupt Flag
                NACK: u1,
                ///  Clear MSTOP Interrupt Flag
                MSTOP: u1,
                ///  Clear Arbitration Lost Interrupt Flag
                ARBLOST: u1,
                ///  Clear Bus Error Interrupt Flag
                BUSERR: u1,
                ///  Clear Bus Held Interrupt Flag
                BUSHOLD: u1,
                ///  Clear Transmit Buffer Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear Receive Buffer Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear Bus Idle Timeout Interrupt Flag
                BITO: u1,
                ///  Clear Clock Low Interrupt Flag
                CLTO: u1,
                ///  Clear SSTOP Interrupt Flag
                SSTOP: u1,
                padding: u15,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  START Condition Interrupt Enable
                START: u1,
                ///  Repeated START condition Interrupt Enable
                RSTART: u1,
                ///  Address Interrupt Enable
                ADDR: u1,
                ///  Transfer Completed Interrupt Enable
                TXC: u1,
                ///  Transmit Buffer level Interrupt Enable
                TXBL: u1,
                ///  Receive Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  Acknowledge Received Interrupt Enable
                ACK: u1,
                ///  Not Acknowledge Received Interrupt Enable
                NACK: u1,
                ///  MSTOP Interrupt Enable
                MSTOP: u1,
                ///  Arbitration Lost Interrupt Enable
                ARBLOST: u1,
                ///  Bus Error Interrupt Enable
                BUSERR: u1,
                ///  Bus Held Interrupt Enable
                BUSHOLD: u1,
                ///  Transmit Buffer Overflow Interrupt Enable
                TXOF: u1,
                ///  Receive Buffer Underflow Interrupt Enable
                RXUF: u1,
                ///  Bus Idle Timeout Interrupt Enable
                BITO: u1,
                ///  Clock Low Interrupt Enable
                CLTO: u1,
                ///  SSTOP Interrupt Enable
                SSTOP: u1,
                padding: u15,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  SDA Pin Enable
                SDAPEN: u1,
                ///  SCL Pin Enable
                SCLPEN: u1,
                reserved8: u6,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        ///  Location 6
                        LOC6 = 0x6,
                        _,
                    },
                },
                padding: u21,
            }),
        };

        ///  I2C1
        pub const I2C1 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  I2C Enable
                EN: u1,
                ///  Addressable as Slave
                SLAVE: u1,
                ///  Automatic Acknowledge
                AUTOACK: u1,
                ///  Automatic STOP when Empty
                AUTOSE: u1,
                ///  Automatic STOP on NACK
                AUTOSN: u1,
                ///  Arbitration Disable
                ARBDIS: u1,
                ///  General Call Address Match Enable
                GCAMEN: u1,
                reserved8: u1,
                ///  Clock Low High Ratio
                CLHR: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The ratio between low period and high period counters (Nlow:Nhigh) is 4:4
                        STANDARD = 0x0,
                        ///  The ratio between low period and high period counters (Nlow:Nhigh) is 6:3
                        ASYMMETRIC = 0x1,
                        ///  The ratio between low period and high period counters (Nlow:Nhigh) is 11:6
                        FAST = 0x2,
                        _,
                    },
                },
                reserved12: u2,
                ///  Bus Idle Timeout
                BITO: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Timeout disabled
                        OFF = 0x0,
                        ///  Timeout after 40 prescaled clock cycles. In standard mode at 100 kHz, this results in a 50us timeout.
                        @"40PCC" = 0x1,
                        ///  Timeout after 80 prescaled clock cycles. In standard mode at 100 kHz, this results in a 100us timeout.
                        @"80PCC" = 0x2,
                        ///  Timeout after 160 prescaled clock cycles. In standard mode at 100 kHz, this results in a 200us timeout.
                        @"160PCC" = 0x3,
                    },
                },
                reserved15: u1,
                ///  Go Idle on Bus Idle Timeout
                GIBITO: u1,
                ///  Clock Low Timeout
                CLTO: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Timeout disabled
                        OFF = 0x0,
                        ///  Timeout after 40 prescaled clock cycles. In standard mode at 100 kHz, this results in a 50us timeout.
                        @"40PCC" = 0x1,
                        ///  Timeout after 80 prescaled clock cycles. In standard mode at 100 kHz, this results in a 100us timeout.
                        @"80PCC" = 0x2,
                        ///  Timeout after 160 prescaled clock cycles. In standard mode at 100 kHz, this results in a 200us timeout.
                        @"160PCC" = 0x3,
                        ///  Timeout after 320 prescaled clock cycles. In standard mode at 100 kHz, this results in a 400us timeout.
                        @"320PPC" = 0x4,
                        ///  Timeout after 1024 prescaled clock cycles. In standard mode at 100 kHz, this results in a 1280us timeout.
                        @"1024PPC" = 0x5,
                        _,
                    },
                },
                padding: u13,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Send start condition
                START: u1,
                ///  Send stop condition
                STOP: u1,
                ///  Send ACK
                ACK: u1,
                ///  Send NACK
                NACK: u1,
                ///  Continue transmission
                CONT: u1,
                ///  Abort transmission
                ABORT: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear Pending Commands
                CLEARPC: u1,
                padding: u24,
            }),
            ///  State Register
            STATE: mmio.Mmio(packed struct(u32) {
                ///  Bus Busy
                BUSY: u1,
                ///  Master
                MASTER: u1,
                ///  Transmitter
                TRANSMITTER: u1,
                ///  Nack Received
                NACKED: u1,
                ///  Bus Held
                BUSHOLD: u1,
                ///  Transmission State
                STATE: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  No transmission is being performed.
                        IDLE = 0x0,
                        ///  Waiting for idle. Will send a start condition as soon as the bus is idle.
                        WAIT = 0x1,
                        ///  Start transmitted or received
                        START = 0x2,
                        ///  Address transmitted or received
                        ADDR = 0x3,
                        ///  Address ack/nack transmitted or received
                        ADDRACK = 0x4,
                        ///  Data transmitted or received
                        DATA = 0x5,
                        ///  Data ack/nack transmitted or received
                        DATAACK = 0x6,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Pending START
                PSTART: u1,
                ///  Pending STOP
                PSTOP: u1,
                ///  Pending ACK
                PACK: u1,
                ///  Pending NACK
                PNACK: u1,
                ///  Pending continue
                PCONT: u1,
                ///  Pending abort
                PABORT: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                padding: u23,
            }),
            ///  Clock Division Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                ///  Clock Divider
                DIV: u9,
                padding: u23,
            }),
            ///  Slave Address Register
            SADDR: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Slave address
                ADDR: u7,
                padding: u24,
            }),
            ///  Slave Address Mask Register
            SADDRMASK: mmio.Mmio(packed struct(u32) {
                reserved1: u1,
                ///  Slave Address Mask
                MASK: u7,
                padding: u24,
            }),
            ///  Receive Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  Receive Buffer Data Peek Register
            RXDATAP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u8,
                padding: u24,
            }),
            ///  Transmit Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  START condition Interrupt Flag
                START: u1,
                ///  Repeated START condition Interrupt Flag
                RSTART: u1,
                ///  Address Interrupt Flag
                ADDR: u1,
                ///  Transfer Completed Interrupt Flag
                TXC: u1,
                ///  Transmit Buffer Level Interrupt Flag
                TXBL: u1,
                ///  Receive Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  Acknowledge Received Interrupt Flag
                ACK: u1,
                ///  Not Acknowledge Received Interrupt Flag
                NACK: u1,
                ///  Master STOP Condition Interrupt Flag
                MSTOP: u1,
                ///  Arbitration Lost Interrupt Flag
                ARBLOST: u1,
                ///  Bus Error Interrupt Flag
                BUSERR: u1,
                ///  Bus Held Interrupt Flag
                BUSHOLD: u1,
                ///  Transmit Buffer Overflow Interrupt Flag
                TXOF: u1,
                ///  Receive Buffer Underflow Interrupt Flag
                RXUF: u1,
                ///  Bus Idle Timeout Interrupt Flag
                BITO: u1,
                ///  Clock Low Timeout Interrupt Flag
                CLTO: u1,
                ///  Slave STOP condition Interrupt Flag
                SSTOP: u1,
                padding: u15,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set START Interrupt Flag
                START: u1,
                ///  Set Repeated START Interrupt Flag
                RSTART: u1,
                ///  Set Address Interrupt Flag
                ADDR: u1,
                ///  Set Transfer Completed Interrupt Flag
                TXC: u1,
                reserved6: u2,
                ///  Set Acknowledge Received Interrupt Flag
                ACK: u1,
                ///  Set Not Acknowledge Received Interrupt Flag
                NACK: u1,
                ///  Set MSTOP Interrupt Flag
                MSTOP: u1,
                ///  Set Arbitration Lost Interrupt Flag
                ARBLOST: u1,
                ///  Set Bus Error Interrupt Flag
                BUSERR: u1,
                ///  Set Bus Held Interrupt Flag
                BUSHOLD: u1,
                ///  Set Transmit Buffer Overflow Interrupt Flag
                TXOF: u1,
                ///  Set Receive Buffer Underflow Interrupt Flag
                RXUF: u1,
                ///  Set Bus Idle Timeout Interrupt Flag
                BITO: u1,
                ///  Set Clock Low Interrupt Flag
                CLTO: u1,
                ///  Set SSTOP Interrupt Flag
                SSTOP: u1,
                padding: u15,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear START Interrupt Flag
                START: u1,
                ///  Clear Repeated START Interrupt Flag
                RSTART: u1,
                ///  Clear Address Interrupt Flag
                ADDR: u1,
                ///  Clear Transfer Completed Interrupt Flag
                TXC: u1,
                reserved6: u2,
                ///  Clear Acknowledge Received Interrupt Flag
                ACK: u1,
                ///  Clear Not Acknowledge Received Interrupt Flag
                NACK: u1,
                ///  Clear MSTOP Interrupt Flag
                MSTOP: u1,
                ///  Clear Arbitration Lost Interrupt Flag
                ARBLOST: u1,
                ///  Clear Bus Error Interrupt Flag
                BUSERR: u1,
                ///  Clear Bus Held Interrupt Flag
                BUSHOLD: u1,
                ///  Clear Transmit Buffer Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear Receive Buffer Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear Bus Idle Timeout Interrupt Flag
                BITO: u1,
                ///  Clear Clock Low Interrupt Flag
                CLTO: u1,
                ///  Clear SSTOP Interrupt Flag
                SSTOP: u1,
                padding: u15,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  START Condition Interrupt Enable
                START: u1,
                ///  Repeated START condition Interrupt Enable
                RSTART: u1,
                ///  Address Interrupt Enable
                ADDR: u1,
                ///  Transfer Completed Interrupt Enable
                TXC: u1,
                ///  Transmit Buffer level Interrupt Enable
                TXBL: u1,
                ///  Receive Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  Acknowledge Received Interrupt Enable
                ACK: u1,
                ///  Not Acknowledge Received Interrupt Enable
                NACK: u1,
                ///  MSTOP Interrupt Enable
                MSTOP: u1,
                ///  Arbitration Lost Interrupt Enable
                ARBLOST: u1,
                ///  Bus Error Interrupt Enable
                BUSERR: u1,
                ///  Bus Held Interrupt Enable
                BUSHOLD: u1,
                ///  Transmit Buffer Overflow Interrupt Enable
                TXOF: u1,
                ///  Receive Buffer Underflow Interrupt Enable
                RXUF: u1,
                ///  Bus Idle Timeout Interrupt Enable
                BITO: u1,
                ///  Clock Low Interrupt Enable
                CLTO: u1,
                ///  SSTOP Interrupt Enable
                SSTOP: u1,
                padding: u15,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  SDA Pin Enable
                SDAPEN: u1,
                ///  SCL Pin Enable
                SCLPEN: u1,
                reserved8: u6,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        ///  Location 5
                        LOC5 = 0x5,
                        ///  Location 6
                        LOC6 = 0x6,
                        _,
                    },
                },
                padding: u21,
            }),
        };

        ///  GPIO
        pub const GPIO = extern struct {
            ///  Port Control Register
            PA_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Drive Mode Select
                DRIVEMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  6 mA drive current
                        STANDARD = 0x0,
                        ///  0.1 mA drive current
                        LOWEST = 0x1,
                        ///  20 mA drive current
                        HIGH = 0x2,
                        ///  1 mA drive current
                        LOW = 0x3,
                    },
                },
                padding: u30,
            }),
            ///  Port Pin Mode Low Register
            PA_MODEL: mmio.Mmio(packed struct(u32) {
                ///  Pin 0 Mode
                MODE0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 1 Mode
                MODE1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 2 Mode
                MODE2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 3 Mode
                MODE3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 4 Mode
                MODE4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 5 Mode
                MODE5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 6 Mode
                MODE6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 7 Mode
                MODE7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Pin Mode High Register
            PA_MODEH: mmio.Mmio(packed struct(u32) {
                ///  Pin 8 Mode
                MODE8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 9 Mode
                MODE9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 10 Mode
                MODE10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 11 Mode
                MODE11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 12 Mode
                MODE12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 13 Mode
                MODE13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 14 Mode
                MODE14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 15 Mode
                MODE15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Data Out Register
            PA_DOUT: mmio.Mmio(packed struct(u32) {
                ///  Data Out
                DOUT: u16,
                padding: u16,
            }),
            ///  Port Data Out Set Register
            PA_DOUTSET: mmio.Mmio(packed struct(u32) {
                ///  Data Out Set
                DOUTSET: u16,
                padding: u16,
            }),
            ///  Port Data Out Clear Register
            PA_DOUTCLR: mmio.Mmio(packed struct(u32) {
                ///  Data Out Clear
                DOUTCLR: u16,
                padding: u16,
            }),
            ///  Port Data Out Toggle Register
            PA_DOUTTGL: mmio.Mmio(packed struct(u32) {
                ///  Data Out Toggle
                DOUTTGL: u16,
                padding: u16,
            }),
            ///  Port Data In Register
            PA_DIN: mmio.Mmio(packed struct(u32) {
                ///  Data In
                DIN: u16,
                padding: u16,
            }),
            ///  Port Unlocked Pins Register
            PA_PINLOCKN: mmio.Mmio(packed struct(u32) {
                ///  Unlocked Pins
                PINLOCKN: u16,
                padding: u16,
            }),
            ///  Port Control Register
            PB_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Drive Mode Select
                DRIVEMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  6 mA drive current
                        STANDARD = 0x0,
                        ///  0.1 mA drive current
                        LOWEST = 0x1,
                        ///  20 mA drive current
                        HIGH = 0x2,
                        ///  1 mA drive current
                        LOW = 0x3,
                    },
                },
                padding: u30,
            }),
            ///  Port Pin Mode Low Register
            PB_MODEL: mmio.Mmio(packed struct(u32) {
                ///  Pin 0 Mode
                MODE0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 1 Mode
                MODE1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 2 Mode
                MODE2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 3 Mode
                MODE3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 4 Mode
                MODE4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 5 Mode
                MODE5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 6 Mode
                MODE6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 7 Mode
                MODE7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Pin Mode High Register
            PB_MODEH: mmio.Mmio(packed struct(u32) {
                ///  Pin 8 Mode
                MODE8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 9 Mode
                MODE9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 10 Mode
                MODE10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 11 Mode
                MODE11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 12 Mode
                MODE12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 13 Mode
                MODE13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 14 Mode
                MODE14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 15 Mode
                MODE15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Data Out Register
            PB_DOUT: mmio.Mmio(packed struct(u32) {
                ///  Data Out
                DOUT: u16,
                padding: u16,
            }),
            ///  Port Data Out Set Register
            PB_DOUTSET: mmio.Mmio(packed struct(u32) {
                ///  Data Out Set
                DOUTSET: u16,
                padding: u16,
            }),
            ///  Port Data Out Clear Register
            PB_DOUTCLR: mmio.Mmio(packed struct(u32) {
                ///  Data Out Clear
                DOUTCLR: u16,
                padding: u16,
            }),
            ///  Port Data Out Toggle Register
            PB_DOUTTGL: mmio.Mmio(packed struct(u32) {
                ///  Data Out Toggle
                DOUTTGL: u16,
                padding: u16,
            }),
            ///  Port Data In Register
            PB_DIN: mmio.Mmio(packed struct(u32) {
                ///  Data In
                DIN: u16,
                padding: u16,
            }),
            ///  Port Unlocked Pins Register
            PB_PINLOCKN: mmio.Mmio(packed struct(u32) {
                ///  Unlocked Pins
                PINLOCKN: u16,
                padding: u16,
            }),
            ///  Port Control Register
            PC_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Drive Mode Select
                DRIVEMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  6 mA drive current
                        STANDARD = 0x0,
                        ///  0.1 mA drive current
                        LOWEST = 0x1,
                        ///  20 mA drive current
                        HIGH = 0x2,
                        ///  1 mA drive current
                        LOW = 0x3,
                    },
                },
                padding: u30,
            }),
            ///  Port Pin Mode Low Register
            PC_MODEL: mmio.Mmio(packed struct(u32) {
                ///  Pin 0 Mode
                MODE0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 1 Mode
                MODE1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 2 Mode
                MODE2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 3 Mode
                MODE3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 4 Mode
                MODE4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 5 Mode
                MODE5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 6 Mode
                MODE6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 7 Mode
                MODE7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Pin Mode High Register
            PC_MODEH: mmio.Mmio(packed struct(u32) {
                ///  Pin 8 Mode
                MODE8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 9 Mode
                MODE9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 10 Mode
                MODE10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 11 Mode
                MODE11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 12 Mode
                MODE12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 13 Mode
                MODE13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 14 Mode
                MODE14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 15 Mode
                MODE15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Data Out Register
            PC_DOUT: mmio.Mmio(packed struct(u32) {
                ///  Data Out
                DOUT: u16,
                padding: u16,
            }),
            ///  Port Data Out Set Register
            PC_DOUTSET: mmio.Mmio(packed struct(u32) {
                ///  Data Out Set
                DOUTSET: u16,
                padding: u16,
            }),
            ///  Port Data Out Clear Register
            PC_DOUTCLR: mmio.Mmio(packed struct(u32) {
                ///  Data Out Clear
                DOUTCLR: u16,
                padding: u16,
            }),
            ///  Port Data Out Toggle Register
            PC_DOUTTGL: mmio.Mmio(packed struct(u32) {
                ///  Data Out Toggle
                DOUTTGL: u16,
                padding: u16,
            }),
            ///  Port Data In Register
            PC_DIN: mmio.Mmio(packed struct(u32) {
                ///  Data In
                DIN: u16,
                padding: u16,
            }),
            ///  Port Unlocked Pins Register
            PC_PINLOCKN: mmio.Mmio(packed struct(u32) {
                ///  Unlocked Pins
                PINLOCKN: u16,
                padding: u16,
            }),
            ///  Port Control Register
            PD_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Drive Mode Select
                DRIVEMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  6 mA drive current
                        STANDARD = 0x0,
                        ///  0.1 mA drive current
                        LOWEST = 0x1,
                        ///  20 mA drive current
                        HIGH = 0x2,
                        ///  1 mA drive current
                        LOW = 0x3,
                    },
                },
                padding: u30,
            }),
            ///  Port Pin Mode Low Register
            PD_MODEL: mmio.Mmio(packed struct(u32) {
                ///  Pin 0 Mode
                MODE0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 1 Mode
                MODE1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 2 Mode
                MODE2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 3 Mode
                MODE3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 4 Mode
                MODE4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 5 Mode
                MODE5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 6 Mode
                MODE6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 7 Mode
                MODE7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Pin Mode High Register
            PD_MODEH: mmio.Mmio(packed struct(u32) {
                ///  Pin 8 Mode
                MODE8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 9 Mode
                MODE9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 10 Mode
                MODE10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 11 Mode
                MODE11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 12 Mode
                MODE12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 13 Mode
                MODE13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 14 Mode
                MODE14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 15 Mode
                MODE15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Data Out Register
            PD_DOUT: mmio.Mmio(packed struct(u32) {
                ///  Data Out
                DOUT: u16,
                padding: u16,
            }),
            ///  Port Data Out Set Register
            PD_DOUTSET: mmio.Mmio(packed struct(u32) {
                ///  Data Out Set
                DOUTSET: u16,
                padding: u16,
            }),
            ///  Port Data Out Clear Register
            PD_DOUTCLR: mmio.Mmio(packed struct(u32) {
                ///  Data Out Clear
                DOUTCLR: u16,
                padding: u16,
            }),
            ///  Port Data Out Toggle Register
            PD_DOUTTGL: mmio.Mmio(packed struct(u32) {
                ///  Data Out Toggle
                DOUTTGL: u16,
                padding: u16,
            }),
            ///  Port Data In Register
            PD_DIN: mmio.Mmio(packed struct(u32) {
                ///  Data In
                DIN: u16,
                padding: u16,
            }),
            ///  Port Unlocked Pins Register
            PD_PINLOCKN: mmio.Mmio(packed struct(u32) {
                ///  Unlocked Pins
                PINLOCKN: u16,
                padding: u16,
            }),
            ///  Port Control Register
            PE_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Drive Mode Select
                DRIVEMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  6 mA drive current
                        STANDARD = 0x0,
                        ///  0.1 mA drive current
                        LOWEST = 0x1,
                        ///  20 mA drive current
                        HIGH = 0x2,
                        ///  1 mA drive current
                        LOW = 0x3,
                    },
                },
                padding: u30,
            }),
            ///  Port Pin Mode Low Register
            PE_MODEL: mmio.Mmio(packed struct(u32) {
                ///  Pin 0 Mode
                MODE0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 1 Mode
                MODE1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 2 Mode
                MODE2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 3 Mode
                MODE3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 4 Mode
                MODE4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 5 Mode
                MODE5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 6 Mode
                MODE6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 7 Mode
                MODE7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Pin Mode High Register
            PE_MODEH: mmio.Mmio(packed struct(u32) {
                ///  Pin 8 Mode
                MODE8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 9 Mode
                MODE9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 10 Mode
                MODE10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 11 Mode
                MODE11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 12 Mode
                MODE12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 13 Mode
                MODE13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 14 Mode
                MODE14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 15 Mode
                MODE15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Data Out Register
            PE_DOUT: mmio.Mmio(packed struct(u32) {
                ///  Data Out
                DOUT: u16,
                padding: u16,
            }),
            ///  Port Data Out Set Register
            PE_DOUTSET: mmio.Mmio(packed struct(u32) {
                ///  Data Out Set
                DOUTSET: u16,
                padding: u16,
            }),
            ///  Port Data Out Clear Register
            PE_DOUTCLR: mmio.Mmio(packed struct(u32) {
                ///  Data Out Clear
                DOUTCLR: u16,
                padding: u16,
            }),
            ///  Port Data Out Toggle Register
            PE_DOUTTGL: mmio.Mmio(packed struct(u32) {
                ///  Data Out Toggle
                DOUTTGL: u16,
                padding: u16,
            }),
            ///  Port Data In Register
            PE_DIN: mmio.Mmio(packed struct(u32) {
                ///  Data In
                DIN: u16,
                padding: u16,
            }),
            ///  Port Unlocked Pins Register
            PE_PINLOCKN: mmio.Mmio(packed struct(u32) {
                ///  Unlocked Pins
                PINLOCKN: u16,
                padding: u16,
            }),
            ///  Port Control Register
            PF_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Drive Mode Select
                DRIVEMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  6 mA drive current
                        STANDARD = 0x0,
                        ///  0.1 mA drive current
                        LOWEST = 0x1,
                        ///  20 mA drive current
                        HIGH = 0x2,
                        ///  1 mA drive current
                        LOW = 0x3,
                    },
                },
                padding: u30,
            }),
            ///  Port Pin Mode Low Register
            PF_MODEL: mmio.Mmio(packed struct(u32) {
                ///  Pin 0 Mode
                MODE0: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 1 Mode
                MODE1: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 2 Mode
                MODE2: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 3 Mode
                MODE3: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 4 Mode
                MODE4: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 5 Mode
                MODE5: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 6 Mode
                MODE6: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 7 Mode
                MODE7: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Pin Mode High Register
            PF_MODEH: mmio.Mmio(packed struct(u32) {
                ///  Pin 8 Mode
                MODE8: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 9 Mode
                MODE9: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 10 Mode
                MODE10: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 11 Mode
                MODE11: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 12 Mode
                MODE12: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 13 Mode
                MODE13: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 14 Mode
                MODE14: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
                ///  Pin 15 Mode
                MODE15: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  Input disabled. Pullup if DOUT is set.
                        DISABLED = 0x0,
                        ///  Input enabled. Filter if DOUT is set
                        INPUT = 0x1,
                        ///  Input enabled. DOUT determines pull direction
                        INPUTPULL = 0x2,
                        ///  Input enabled with filter. DOUT determines pull direction
                        INPUTPULLFILTER = 0x3,
                        ///  Push-pull output
                        PUSHPULL = 0x4,
                        ///  Push-pull output with drive-strength set by DRIVEMODE
                        PUSHPULLDRIVE = 0x5,
                        ///  Wired-or output
                        WIREDOR = 0x6,
                        ///  Wired-or output with pull-down
                        WIREDORPULLDOWN = 0x7,
                        ///  Open-drain output
                        WIREDAND = 0x8,
                        ///  Open-drain output with filter
                        WIREDANDFILTER = 0x9,
                        ///  Open-drain output with pullup
                        WIREDANDPULLUP = 0xa,
                        ///  Open-drain output with filter and pullup
                        WIREDANDPULLUPFILTER = 0xb,
                        ///  Open-drain output with drive-strength set by DRIVEMODE
                        WIREDANDDRIVE = 0xc,
                        ///  Open-drain output with filter and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEFILTER = 0xd,
                        ///  Open-drain output with pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUP = 0xe,
                        ///  Open-drain output with filter, pullup and drive-strength set by DRIVEMODE
                        WIREDANDDRIVEPULLUPFILTER = 0xf,
                    },
                },
            }),
            ///  Port Data Out Register
            PF_DOUT: mmio.Mmio(packed struct(u32) {
                ///  Data Out
                DOUT: u16,
                padding: u16,
            }),
            ///  Port Data Out Set Register
            PF_DOUTSET: mmio.Mmio(packed struct(u32) {
                ///  Data Out Set
                DOUTSET: u16,
                padding: u16,
            }),
            ///  Port Data Out Clear Register
            PF_DOUTCLR: mmio.Mmio(packed struct(u32) {
                ///  Data Out Clear
                DOUTCLR: u16,
                padding: u16,
            }),
            ///  Port Data Out Toggle Register
            PF_DOUTTGL: mmio.Mmio(packed struct(u32) {
                ///  Data Out Toggle
                DOUTTGL: u16,
                padding: u16,
            }),
            ///  Port Data In Register
            PF_DIN: mmio.Mmio(packed struct(u32) {
                ///  Data In
                DIN: u16,
                padding: u16,
            }),
            ///  Port Unlocked Pins Register
            PF_PINLOCKN: mmio.Mmio(packed struct(u32) {
                ///  Unlocked Pins
                PINLOCKN: u16,
                padding: u16,
            }),
            reserved256: [40]u8,
            ///  External Interrupt Port Select Low Register
            EXTIPSELL: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt 0 Port Select
                EXTIPSEL0: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 0 selected for external interrupt 0
                        PORTA = 0x0,
                        ///  Port B pin 0 selected for external interrupt 0
                        PORTB = 0x1,
                        ///  Port C pin 0 selected for external interrupt 0
                        PORTC = 0x2,
                        ///  Port D pin 0 selected for external interrupt 0
                        PORTD = 0x3,
                        ///  Port E pin 0 selected for external interrupt 0
                        PORTE = 0x4,
                        ///  Port F pin 0 selected for external interrupt 0
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved4: u1,
                ///  External Interrupt 1 Port Select
                EXTIPSEL1: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 1 selected for external interrupt 1
                        PORTA = 0x0,
                        ///  Port B pin 1 selected for external interrupt 1
                        PORTB = 0x1,
                        ///  Port C pin 1 selected for external interrupt 1
                        PORTC = 0x2,
                        ///  Port D pin 1 selected for external interrupt 1
                        PORTD = 0x3,
                        ///  Port E pin 1 selected for external interrupt 1
                        PORTE = 0x4,
                        ///  Port F pin 1 selected for external interrupt 1
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved8: u1,
                ///  External Interrupt 2 Port Select
                EXTIPSEL2: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 2 selected for external interrupt 2
                        PORTA = 0x0,
                        ///  Port B pin 2 selected for external interrupt 2
                        PORTB = 0x1,
                        ///  Port C pin 2 selected for external interrupt 2
                        PORTC = 0x2,
                        ///  Port D pin 2 selected for external interrupt 2
                        PORTD = 0x3,
                        ///  Port E pin 2 selected for external interrupt 2
                        PORTE = 0x4,
                        ///  Port F pin 2 selected for external interrupt 2
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved12: u1,
                ///  External Interrupt 3 Port Select
                EXTIPSEL3: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 3 selected for external interrupt 3
                        PORTA = 0x0,
                        ///  Port B pin 3 selected for external interrupt 3
                        PORTB = 0x1,
                        ///  Port C pin 3 selected for external interrupt 3
                        PORTC = 0x2,
                        ///  Port D pin 3 selected for external interrupt 3
                        PORTD = 0x3,
                        ///  Port E pin 3 selected for external interrupt 3
                        PORTE = 0x4,
                        ///  Port F pin 3 selected for external interrupt 3
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved16: u1,
                ///  External Interrupt 4 Port Select
                EXTIPSEL4: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 4 selected for external interrupt 4
                        PORTA = 0x0,
                        ///  Port B pin 4 selected for external interrupt 4
                        PORTB = 0x1,
                        ///  Port C pin 4 selected for external interrupt 4
                        PORTC = 0x2,
                        ///  Port D pin 4 selected for external interrupt 4
                        PORTD = 0x3,
                        ///  Port E pin 4 selected for external interrupt 4
                        PORTE = 0x4,
                        ///  Port F pin 4 selected for external interrupt 4
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved20: u1,
                ///  External Interrupt 5 Port Select
                EXTIPSEL5: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 5 selected for external interrupt 5
                        PORTA = 0x0,
                        ///  Port B pin 5 selected for external interrupt 5
                        PORTB = 0x1,
                        ///  Port C pin 5 selected for external interrupt 5
                        PORTC = 0x2,
                        ///  Port D pin 5 selected for external interrupt 5
                        PORTD = 0x3,
                        ///  Port E pin 5 selected for external interrupt 5
                        PORTE = 0x4,
                        ///  Port F pin 5 selected for external interrupt 5
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved24: u1,
                ///  External Interrupt 6 Port Select
                EXTIPSEL6: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 6 selected for external interrupt 6
                        PORTA = 0x0,
                        ///  Port B pin 6 selected for external interrupt 6
                        PORTB = 0x1,
                        ///  Port C pin 6 selected for external interrupt 6
                        PORTC = 0x2,
                        ///  Port D pin 6 selected for external interrupt 6
                        PORTD = 0x3,
                        ///  Port E pin 6 selected for external interrupt 6
                        PORTE = 0x4,
                        ///  Port F pin 6 selected for external interrupt 6
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved28: u1,
                ///  External Interrupt 7 Port Select
                EXTIPSEL7: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 7 selected for external interrupt 7
                        PORTA = 0x0,
                        ///  Port B pin 7 selected for external interrupt 7
                        PORTB = 0x1,
                        ///  Port C pin 7 selected for external interrupt 7
                        PORTC = 0x2,
                        ///  Port D pin 7 selected for external interrupt 7
                        PORTD = 0x3,
                        ///  Port E pin 7 selected for external interrupt 7
                        PORTE = 0x4,
                        ///  Port F pin 7 selected for external interrupt 7
                        PORTF = 0x5,
                        _,
                    },
                },
                padding: u1,
            }),
            ///  External Interrupt Port Select High Register
            EXTIPSELH: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt 8 Port Select
                EXTIPSEL8: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 8 selected for external interrupt 8
                        PORTA = 0x0,
                        ///  Port B pin 8 selected for external interrupt 8
                        PORTB = 0x1,
                        ///  Port C pin 8 selected for external interrupt 8
                        PORTC = 0x2,
                        ///  Port D pin 8 selected for external interrupt 8
                        PORTD = 0x3,
                        ///  Port E pin 8 selected for external interrupt 8
                        PORTE = 0x4,
                        ///  Port F pin 8 selected for external interrupt 8
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved4: u1,
                ///  External Interrupt 9 Port Select
                EXTIPSEL9: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 9 selected for external interrupt 9
                        PORTA = 0x0,
                        ///  Port B pin 9 selected for external interrupt 9
                        PORTB = 0x1,
                        ///  Port C pin 9 selected for external interrupt 9
                        PORTC = 0x2,
                        ///  Port D pin 9 selected for external interrupt 9
                        PORTD = 0x3,
                        ///  Port E pin 9 selected for external interrupt 9
                        PORTE = 0x4,
                        ///  Port F pin 9 selected for external interrupt 9
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved8: u1,
                ///  External Interrupt 10 Port Select
                EXTIPSEL10: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 10 selected for external interrupt 10
                        PORTA = 0x0,
                        ///  Port B pin 10 selected for external interrupt 10
                        PORTB = 0x1,
                        ///  Port C pin 10 selected for external interrupt 10
                        PORTC = 0x2,
                        ///  Port D pin 10 selected for external interrupt 10
                        PORTD = 0x3,
                        ///  Port E pin 10 selected for external interrupt 10
                        PORTE = 0x4,
                        ///  Port F pin 10 selected for external interrupt 10
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved12: u1,
                ///  External Interrupt 11 Port Select
                EXTIPSEL11: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 11 selected for external interrupt 11
                        PORTA = 0x0,
                        ///  Port B pin 11 selected for external interrupt 11
                        PORTB = 0x1,
                        ///  Port C pin 11 selected for external interrupt 11
                        PORTC = 0x2,
                        ///  Port D pin 11 selected for external interrupt 11
                        PORTD = 0x3,
                        ///  Port E pin 11 selected for external interrupt 11
                        PORTE = 0x4,
                        ///  Port F pin 11 selected for external interrupt 11
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved16: u1,
                ///  External Interrupt 12 Port Select
                EXTIPSEL12: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 12 selected for external interrupt 12
                        PORTA = 0x0,
                        ///  Port B pin 12 selected for external interrupt 12
                        PORTB = 0x1,
                        ///  Port C pin 12 selected for external interrupt 12
                        PORTC = 0x2,
                        ///  Port D pin 12 selected for external interrupt 12
                        PORTD = 0x3,
                        ///  Port E pin 12 selected for external interrupt 12
                        PORTE = 0x4,
                        ///  Port F pin 12 selected for external interrupt 12
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved20: u1,
                ///  External Interrupt 13 Port Select
                EXTIPSEL13: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 13 selected for external interrupt 13
                        PORTA = 0x0,
                        ///  Port B pin 13 selected for external interrupt 13
                        PORTB = 0x1,
                        ///  Port C pin 13 selected for external interrupt 13
                        PORTC = 0x2,
                        ///  Port D pin 13 selected for external interrupt 13
                        PORTD = 0x3,
                        ///  Port E pin 13 selected for external interrupt 13
                        PORTE = 0x4,
                        ///  Port F pin 13 selected for external interrupt 13
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved24: u1,
                ///  External Interrupt 14 Port Select
                EXTIPSEL14: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 14 selected for external interrupt 14
                        PORTA = 0x0,
                        ///  Port B pin 14 selected for external interrupt 14
                        PORTB = 0x1,
                        ///  Port C pin 14 selected for external interrupt 14
                        PORTC = 0x2,
                        ///  Port D pin 14 selected for external interrupt 14
                        PORTD = 0x3,
                        ///  Port E pin 14 selected for external interrupt 14
                        PORTE = 0x4,
                        ///  Port F pin 14 selected for external interrupt 14
                        PORTF = 0x5,
                        _,
                    },
                },
                reserved28: u1,
                ///  External Interrupt 15 Port Select
                EXTIPSEL15: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Port A pin 15 selected for external interrupt 15
                        PORTA = 0x0,
                        ///  Port B pin 15 selected for external interrupt 15
                        PORTB = 0x1,
                        ///  Port C pin 15 selected for external interrupt 15
                        PORTC = 0x2,
                        ///  Port D pin 15 selected for external interrupt 15
                        PORTD = 0x3,
                        ///  Port E pin 15 selected for external interrupt 15
                        PORTE = 0x4,
                        ///  Port F pin 15 selected for external interrupt 15
                        PORTF = 0x5,
                        _,
                    },
                },
                padding: u1,
            }),
            ///  External Interrupt Rising Edge Trigger Register
            EXTIRISE: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt n Rising Edge Trigger Enable
                EXTIRISE: u16,
                padding: u16,
            }),
            ///  External Interrupt Falling Edge Trigger Register
            EXTIFALL: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt n Falling Edge Trigger Enable
                EXTIFALL: u16,
                padding: u16,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt n Enable
                EXT: u16,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt Flag n
                EXT: u16,
                padding: u16,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt Flag n Set
                EXT: u16,
                padding: u16,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  External Interrupt Flag Clear
                EXT: u16,
                padding: u16,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  Serial Wire Clock Pin Enable
                SWCLKPEN: u1,
                ///  Serial Wire Data Pin Enable
                SWDIOPEN: u1,
                ///  Serial Wire Viewer Output Pin Enable
                SWOPEN: u1,
                reserved8: u5,
                ///  I/O Location
                SWLOCATION: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                    },
                },
                reserved12: u2,
                ///  ETM Trace Clock Pin Enable
                TCLKPEN: u1,
                ///  ETM Trace Data Pin Enable
                TD0PEN: u1,
                ///  ETM Trace Data Pin Enable
                TD1PEN: u1,
                ///  ETM Trace Data Pin Enable
                TD2PEN: u1,
                ///  ETM Trace Data Pin Enable
                TD3PEN: u1,
                reserved24: u7,
                ///  I/O Location
                ETMLOCATION: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                    },
                },
                padding: u6,
            }),
            ///  Input Sense Register
            INSENSE: mmio.Mmio(packed struct(u32) {
                ///  Interrupt Sense Enable
                INT: u1,
                ///  PRS Sense Enable
                PRS: u1,
                padding: u30,
            }),
            ///  Configuration Lock Register
            LOCK: mmio.Mmio(packed struct(u32) {
                ///  Configuration Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
            ///  GPIO Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Enable EM4 retention
                EM4RET: u1,
                padding: u31,
            }),
            ///  GPIO Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  EM4 Wake-up clear
                EM4WUCLR: u1,
                padding: u31,
            }),
            ///  EM4 Wake-up Enable Register
            EM4WUEN: mmio.Mmio(packed struct(u32) {
                ///  EM4 Wake-up enable
                EM4WUEN: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  Enable em4 wakeup on pin A0
                        A0 = 0x1,
                        ///  Enable em4 wakeup on pin A6
                        A6 = 0x2,
                        ///  Enable em4 wakeup on pin C9
                        C9 = 0x4,
                        ///  Enable em4 wakeup on pin F1
                        F1 = 0x8,
                        ///  Enable em4 wakeup on pin F2
                        F2 = 0x10,
                        ///  Enable em4 wakeup on pin E13
                        E13 = 0x20,
                        _,
                    },
                },
                padding: u26,
            }),
            ///  EM4 Wake-up Polarity Register
            EM4WUPOL: mmio.Mmio(packed struct(u32) {
                ///  EM4 Wake-up Polarity
                EM4WUPOL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  Determines polarity on pin A0
                        A0 = 0x1,
                        ///  Determines polarity on pin A6
                        A6 = 0x2,
                        ///  Determines polarity on pin C9
                        C9 = 0x4,
                        ///  Determines polarity on pin F1
                        F1 = 0x8,
                        ///  Determines polarity on pin F2
                        F2 = 0x10,
                        ///  Determines polarity on pin E13
                        E13 = 0x20,
                        _,
                    },
                },
                padding: u26,
            }),
            ///  EM4 Wake-up Cause Register
            EM4WUCAUSE: mmio.Mmio(packed struct(u32) {
                ///  EM4 wake-up cause
                EM4WUCAUSE: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  This bit indicates an em4 wake-up request occurred on pin A0
                        A0 = 0x1,
                        ///  This bit indicates an em4 wake-up request occurred on pin A6
                        A6 = 0x2,
                        ///  This bit indicates an em4 wake-up request occurred on pin C9
                        C9 = 0x4,
                        ///  This bit indicates an em4 wake-up request occurred on pin F1
                        F1 = 0x8,
                        ///  This bit indicates an em4 wake-up request occurred on pin F2
                        F2 = 0x10,
                        ///  This bit indicates an em4 wake-up request occurred on pin E13
                        E13 = 0x20,
                        _,
                    },
                },
                padding: u26,
            }),
        };

        ///  VCMP
        pub const VCMP = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Voltage Supply Comparator Enable
                EN: u1,
                reserved2: u1,
                ///  Inactive Value
                INACTVAL: u1,
                reserved4: u1,
                ///  Hysteresis Enable
                HYSTEN: u1,
                reserved8: u3,
                ///  Warm-Up Time
                WARMTIME: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  4 HFPERCLK cycles
                        @"4CYCLES" = 0x0,
                        ///  8 HFPERCLK cycles
                        @"8CYCLES" = 0x1,
                        ///  16 HFPERCLK cycles
                        @"16CYCLES" = 0x2,
                        ///  32 HFPERCLK cycles
                        @"32CYCLES" = 0x3,
                        ///  64 HFPERCLK cycles
                        @"64CYCLES" = 0x4,
                        ///  128 HFPERCLK cycles
                        @"128CYCLES" = 0x5,
                        ///  256 HFPERCLK cycles
                        @"256CYCLES" = 0x6,
                        ///  512 HFPERCLK cycles
                        @"512CYCLES" = 0x7,
                    },
                },
                reserved16: u5,
                ///  Rising Edge Interrupt Sense
                IRISE: u1,
                ///  Falling Edge Interrupt Sense
                IFALL: u1,
                reserved24: u6,
                ///  VCMP Bias Programming Value
                BIASPROG: u4,
                reserved30: u2,
                ///  Half Bias Current
                HALFBIAS: u1,
                padding: u1,
            }),
            ///  Input Selection Register
            INPUTSEL: mmio.Mmio(packed struct(u32) {
                ///  Trigger Level
                TRIGLEVEL: u6,
                reserved8: u2,
                ///  Low Power Reference
                LPREF: u1,
                padding: u23,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Voltage Supply Comparator Active
                VCMPACT: u1,
                ///  Voltage Supply Comparator Output
                VCMPOUT: u1,
                padding: u30,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Edge Trigger Interrupt Enable
                EDGE: u1,
                ///  Warm-up Interrupt Enable
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag
                EDGE: u1,
                ///  Warm-up Interrupt Flag
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag Set
                EDGE: u1,
                ///  Warm-up Interrupt Flag Set
                WARMUP: u1,
                padding: u30,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Edge Triggered Interrupt Flag Clear
                EDGE: u1,
                ///  Warm-up Interrupt Flag Clear
                WARMUP: u1,
                padding: u30,
            }),
        };

        ///  PRS
        pub const PRS = extern struct {
            ///  Software Pulse Register
            SWPULSE: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Pulse Generation
                CH0PULSE: u1,
                ///  Channel 1 Pulse Generation
                CH1PULSE: u1,
                ///  Channel 2 Pulse Generation
                CH2PULSE: u1,
                ///  Channel 3 Pulse Generation
                CH3PULSE: u1,
                ///  Channel 4 Pulse Generation
                CH4PULSE: u1,
                ///  Channel 5 Pulse Generation
                CH5PULSE: u1,
                ///  Channel 6 Pulse Generation
                CH6PULSE: u1,
                ///  Channel 7 Pulse Generation
                CH7PULSE: u1,
                ///  Channel 8 Pulse Generation
                CH8PULSE: u1,
                ///  Channel 9 Pulse Generation
                CH9PULSE: u1,
                ///  Channel 10 Pulse Generation
                CH10PULSE: u1,
                ///  Channel 11 Pulse Generation
                CH11PULSE: u1,
                padding: u20,
            }),
            ///  Software Level Register
            SWLEVEL: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Software Level
                CH0LEVEL: u1,
                ///  Channel 1 Software Level
                CH1LEVEL: u1,
                ///  Channel 2 Software Level
                CH2LEVEL: u1,
                ///  Channel 3 Software Level
                CH3LEVEL: u1,
                ///  Channel 4 Software Level
                CH4LEVEL: u1,
                ///  Channel 5 Software Level
                CH5LEVEL: u1,
                ///  Channel 6 Software Level
                CH6LEVEL: u1,
                ///  Channel 7 Software Level
                CH7LEVEL: u1,
                ///  Channel 8 Software Level
                CH8LEVEL: u1,
                ///  Channel 9 Software Level
                CH9LEVEL: u1,
                ///  Channel 10 Software Level
                CH10LEVEL: u1,
                ///  Channel 11 Software Level
                CH11LEVEL: u1,
                padding: u20,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  CH0 Pin Enable
                CH0PEN: u1,
                ///  CH1 Pin Enable
                CH1PEN: u1,
                ///  CH2 Pin Enable
                CH2PEN: u1,
                ///  CH3 Pin Enable
                CH3PEN: u1,
                reserved8: u4,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        _,
                    },
                },
                padding: u21,
            }),
            reserved16: [4]u8,
            ///  Channel Control Register
            CH0_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH1_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH2_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH3_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH4_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH5_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH6_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH7_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH8_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH9_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH10_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
            ///  Channel Control Register
            CH11_CTRL: mmio.Mmio(packed struct(u32) {
                ///  Signal Select
                SIGSEL: u3,
                reserved16: u13,
                ///  Source Select
                SOURCESEL: packed union {
                    raw: u6,
                    value: enum(u6) {
                        ///  No source selected
                        NONE = 0x0,
                        ///  Voltage Comparator
                        VCMP = 0x1,
                        ///  Analog Comparator 0
                        ACMP0 = 0x2,
                        ///  Analog Comparator 1
                        ACMP1 = 0x3,
                        ///  Digital to Analog Converter 0
                        DAC0 = 0x6,
                        ///  Analog to Digital Converter 0
                        ADC0 = 0x8,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 0
                        USART0 = 0x10,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 1
                        USART1 = 0x11,
                        ///  Universal Synchronous/Asynchronous Receiver/Transmitter 2
                        USART2 = 0x12,
                        ///  Timer 0
                        TIMER0 = 0x1c,
                        ///  Timer 1
                        TIMER1 = 0x1d,
                        ///  Timer 2
                        TIMER2 = 0x1e,
                        ///  Timer 3
                        TIMER3 = 0x1f,
                        ///  Universal Serial Bus Interface
                        USB = 0x24,
                        ///  Real-Time Counter
                        RTC = 0x28,
                        ///  Universal Asynchronous Receiver/Transmitter 0
                        UART0 = 0x29,
                        ///  Universal Asynchronous Receiver/Transmitter 1
                        UART1 = 0x2a,
                        ///  General purpose Input/Output
                        GPIOL = 0x30,
                        ///  General purpose Input/Output
                        GPIOH = 0x31,
                        ///  Low Energy Timer 0
                        LETIMER0 = 0x34,
                        ///  Backup RTC
                        BURTC = 0x37,
                        ///  Low Energy Sensor Interface
                        LESENSEL = 0x39,
                        ///  Low Energy Sensor Interface
                        LESENSEH = 0x3a,
                        ///  Low Energy Sensor Interface
                        LESENSED = 0x3b,
                        _,
                    },
                },
                reserved24: u2,
                ///  Edge Detect Select
                EDSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Signal is left as it is
                        OFF = 0x0,
                        ///  A one HFPERCLK cycle pulse is generated for every positive edge of the incoming signal
                        POSEDGE = 0x1,
                        ///  A one HFPERCLK clock cycle pulse is generated for every negative edge of the incoming signal
                        NEGEDGE = 0x2,
                        ///  A one HFPERCLK clock cycle pulse is generated for every edge of the incoming signal
                        BOTHEDGES = 0x3,
                    },
                },
                reserved28: u2,
                ///  Asynchronous reflex
                ASYNC: u1,
                padding: u3,
            }),
        };

        ///  LEUART0
        pub const LEUART0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Automatic Transmitter Tristate
                AUTOTRI: u1,
                ///  Data-Bit Mode
                DATABITS: u1,
                ///  Parity-Bit Mode
                PARITY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Parity bits are not used
                        NONE = 0x0,
                        ///  Even parity are used. Parity bits are automatically generated and checked by hardware.
                        EVEN = 0x2,
                        ///  Odd parity is used. Parity bits are automatically generated and checked by hardware.
                        ODD = 0x3,
                        _,
                    },
                },
                ///  Stop-Bit Mode
                STOPBITS: u1,
                ///  Invert Input And Output
                INV: u1,
                ///  Clear RX DMA On Error
                ERRSDMA: u1,
                ///  Loopback Enable
                LOOPBK: u1,
                ///  Start-Frame UnBlock RX
                SFUBRX: u1,
                ///  Multi-Processor Mode
                MPM: u1,
                ///  Multi-Processor Address-Bit
                MPAB: u1,
                ///  Bit 8 Default Value
                BIT8DV: u1,
                ///  RX DMA Wakeup
                RXDMAWU: u1,
                ///  TX DMA Wakeup
                TXDMAWU: u1,
                ///  TX Delay Transmission
                TXDELAY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Frames are transmitted immediately
                        NONE = 0x0,
                        ///  Transmission of new frames are delayed by a single baud period
                        SINGLE = 0x1,
                        ///  Transmission of new frames are delayed by two baud periods
                        DOUBLE = 0x2,
                        ///  Transmission of new frames are delayed by three baud periods
                        TRIPLE = 0x3,
                    },
                },
                padding: u16,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RXEN: u1,
                ///  Receiver Disable
                RXDIS: u1,
                ///  Transmitter Enable
                TXEN: u1,
                ///  Transmitter Disable
                TXDIS: u1,
                ///  Receiver Block Enable
                RXBLOCKEN: u1,
                ///  Receiver Block Disable
                RXBLOCKDIS: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear RX
                CLEARRX: u1,
                padding: u24,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable Status
                RXENS: u1,
                ///  Transmitter Enable Status
                TXENS: u1,
                ///  Block Incoming Data
                RXBLOCK: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                padding: u26,
            }),
            ///  Clock Control Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Fractional Clock Divider
                DIV: u12,
                padding: u17,
            }),
            ///  Start Frame Register
            STARTFRAME: mmio.Mmio(packed struct(u32) {
                ///  Start Frame
                STARTFRAME: u9,
                padding: u23,
            }),
            ///  Signal Frame Register
            SIGFRAME: mmio.Mmio(packed struct(u32) {
                ///  Signal Frame
                SIGFRAME: u9,
                padding: u23,
            }),
            ///  Receive Buffer Data Extended Register
            RXDATAX: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u9,
                reserved14: u5,
                ///  Receive Data Parity Error
                PERR: u1,
                ///  Receive Data Framing Error
                FERR: u1,
                padding: u16,
            }),
            ///  Receive Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  Receive Buffer Data Extended Peek Register
            RXDATAXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u9,
                reserved14: u5,
                ///  Receive Data Parity Error Peek
                PERRP: u1,
                ///  Receive Data Framing Error Peek
                FERRP: u1,
                padding: u16,
            }),
            ///  Transmit Buffer Data Extended Register
            TXDATAX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u9,
                reserved13: u4,
                ///  Transmit Data As Break
                TXBREAK: u1,
                ///  Disable TX After Transmission
                TXDISAT: u1,
                ///  Enable RX After Transmission
                RXENAT: u1,
                padding: u16,
            }),
            ///  Transmit Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Flag
                TXC: u1,
                ///  TX Buffer Level Interrupt Flag
                TXBL: u1,
                ///  RX Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  RX Overflow Interrupt Flag
                RXOF: u1,
                ///  RX Underflow Interrupt Flag
                RXUF: u1,
                ///  TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Parity Error Interrupt Flag
                PERR: u1,
                ///  Framing Error Interrupt Flag
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Start Frame Interrupt Flag
                STARTF: u1,
                ///  Signal Frame Interrupt Flag
                SIGF: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Set RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Set RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Set TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Set Parity Error Interrupt Flag
                PERR: u1,
                ///  Set Framing Error Interrupt Flag
                FERR: u1,
                ///  Set Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Set Start Frame Interrupt Flag
                STARTF: u1,
                ///  Set Signal Frame Interrupt Flag
                SIGF: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Clear RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Clear RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear Parity Error Interrupt Flag
                PERR: u1,
                ///  Clear Framing Error Interrupt Flag
                FERR: u1,
                ///  Clear Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Clear Start-Frame Interrupt Flag
                STARTF: u1,
                ///  Clear Signal-Frame Interrupt Flag
                SIGF: u1,
                padding: u21,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Enable
                TXC: u1,
                ///  TX Buffer Level Interrupt Enable
                TXBL: u1,
                ///  RX Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  RX Overflow Interrupt Enable
                RXOF: u1,
                ///  RX Underflow Interrupt Enable
                RXUF: u1,
                ///  TX Overflow Interrupt Enable
                TXOF: u1,
                ///  Parity Error Interrupt Enable
                PERR: u1,
                ///  Framing Error Interrupt Enable
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Enable
                MPAF: u1,
                ///  Start Frame Interrupt Enable
                STARTF: u1,
                ///  Signal Frame Interrupt Enable
                SIGF: u1,
                padding: u21,
            }),
            ///  Pulse Control Register
            PULSECTRL: mmio.Mmio(packed struct(u32) {
                ///  Pulse Width
                PULSEW: u4,
                ///  Pulse Generator/Extender Enable
                PULSEEN: u1,
                ///  Pulse Filter
                PULSEFILT: u1,
                padding: u26,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  CMD Register Busy
                CMD: u1,
                ///  CLKDIV Register Busy
                CLKDIV: u1,
                ///  STARTFRAME Register Busy
                STARTFRAME: u1,
                ///  SIGFRAME Register Busy
                SIGFRAME: u1,
                ///  TXDATAX Register Busy
                TXDATAX: u1,
                ///  TXDATA Register Busy
                TXDATA: u1,
                ///  PULSECTRL Register Busy
                PULSECTRL: u1,
                padding: u24,
            }),
            reserved84: [12]u8,
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  RX Pin Enable
                RXPEN: u1,
                ///  TX Pin Enable
                TXPEN: u1,
                reserved8: u6,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        _,
                    },
                },
                padding: u21,
            }),
            reserved172: [84]u8,
            ///  LEUART Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  RX PRS Channel Select
                RXPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  PRS RX Enable
                RXPRS: u1,
                padding: u27,
            }),
        };

        ///  LEUART1
        pub const LEUART1 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Automatic Transmitter Tristate
                AUTOTRI: u1,
                ///  Data-Bit Mode
                DATABITS: u1,
                ///  Parity-Bit Mode
                PARITY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Parity bits are not used
                        NONE = 0x0,
                        ///  Even parity are used. Parity bits are automatically generated and checked by hardware.
                        EVEN = 0x2,
                        ///  Odd parity is used. Parity bits are automatically generated and checked by hardware.
                        ODD = 0x3,
                        _,
                    },
                },
                ///  Stop-Bit Mode
                STOPBITS: u1,
                ///  Invert Input And Output
                INV: u1,
                ///  Clear RX DMA On Error
                ERRSDMA: u1,
                ///  Loopback Enable
                LOOPBK: u1,
                ///  Start-Frame UnBlock RX
                SFUBRX: u1,
                ///  Multi-Processor Mode
                MPM: u1,
                ///  Multi-Processor Address-Bit
                MPAB: u1,
                ///  Bit 8 Default Value
                BIT8DV: u1,
                ///  RX DMA Wakeup
                RXDMAWU: u1,
                ///  TX DMA Wakeup
                TXDMAWU: u1,
                ///  TX Delay Transmission
                TXDELAY: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Frames are transmitted immediately
                        NONE = 0x0,
                        ///  Transmission of new frames are delayed by a single baud period
                        SINGLE = 0x1,
                        ///  Transmission of new frames are delayed by two baud periods
                        DOUBLE = 0x2,
                        ///  Transmission of new frames are delayed by three baud periods
                        TRIPLE = 0x3,
                    },
                },
                padding: u16,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable
                RXEN: u1,
                ///  Receiver Disable
                RXDIS: u1,
                ///  Transmitter Enable
                TXEN: u1,
                ///  Transmitter Disable
                TXDIS: u1,
                ///  Receiver Block Enable
                RXBLOCKEN: u1,
                ///  Receiver Block Disable
                RXBLOCKDIS: u1,
                ///  Clear TX
                CLEARTX: u1,
                ///  Clear RX
                CLEARRX: u1,
                padding: u24,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Receiver Enable Status
                RXENS: u1,
                ///  Transmitter Enable Status
                TXENS: u1,
                ///  Block Incoming Data
                RXBLOCK: u1,
                ///  TX Complete
                TXC: u1,
                ///  TX Buffer Level
                TXBL: u1,
                ///  RX Data Valid
                RXDATAV: u1,
                padding: u26,
            }),
            ///  Clock Control Register
            CLKDIV: mmio.Mmio(packed struct(u32) {
                reserved3: u3,
                ///  Fractional Clock Divider
                DIV: u12,
                padding: u17,
            }),
            ///  Start Frame Register
            STARTFRAME: mmio.Mmio(packed struct(u32) {
                ///  Start Frame
                STARTFRAME: u9,
                padding: u23,
            }),
            ///  Signal Frame Register
            SIGFRAME: mmio.Mmio(packed struct(u32) {
                ///  Signal Frame
                SIGFRAME: u9,
                padding: u23,
            }),
            ///  Receive Buffer Data Extended Register
            RXDATAX: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u9,
                reserved14: u5,
                ///  Receive Data Parity Error
                PERR: u1,
                ///  Receive Data Framing Error
                FERR: u1,
                padding: u16,
            }),
            ///  Receive Buffer Data Register
            RXDATA: mmio.Mmio(packed struct(u32) {
                ///  RX Data
                RXDATA: u8,
                padding: u24,
            }),
            ///  Receive Buffer Data Extended Peek Register
            RXDATAXP: mmio.Mmio(packed struct(u32) {
                ///  RX Data Peek
                RXDATAP: u9,
                reserved14: u5,
                ///  Receive Data Parity Error Peek
                PERRP: u1,
                ///  Receive Data Framing Error Peek
                FERRP: u1,
                padding: u16,
            }),
            ///  Transmit Buffer Data Extended Register
            TXDATAX: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u9,
                reserved13: u4,
                ///  Transmit Data As Break
                TXBREAK: u1,
                ///  Disable TX After Transmission
                TXDISAT: u1,
                ///  Enable RX After Transmission
                RXENAT: u1,
                padding: u16,
            }),
            ///  Transmit Buffer Data Register
            TXDATA: mmio.Mmio(packed struct(u32) {
                ///  TX Data
                TXDATA: u8,
                padding: u24,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Flag
                TXC: u1,
                ///  TX Buffer Level Interrupt Flag
                TXBL: u1,
                ///  RX Data Valid Interrupt Flag
                RXDATAV: u1,
                ///  RX Overflow Interrupt Flag
                RXOF: u1,
                ///  RX Underflow Interrupt Flag
                RXUF: u1,
                ///  TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Parity Error Interrupt Flag
                PERR: u1,
                ///  Framing Error Interrupt Flag
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Start Frame Interrupt Flag
                STARTF: u1,
                ///  Signal Frame Interrupt Flag
                SIGF: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Set RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Set RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Set TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Set Parity Error Interrupt Flag
                PERR: u1,
                ///  Set Framing Error Interrupt Flag
                FERR: u1,
                ///  Set Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Set Start Frame Interrupt Flag
                STARTF: u1,
                ///  Set Signal Frame Interrupt Flag
                SIGF: u1,
                padding: u21,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear TX Complete Interrupt Flag
                TXC: u1,
                reserved3: u2,
                ///  Clear RX Overflow Interrupt Flag
                RXOF: u1,
                ///  Clear RX Underflow Interrupt Flag
                RXUF: u1,
                ///  Clear TX Overflow Interrupt Flag
                TXOF: u1,
                ///  Clear Parity Error Interrupt Flag
                PERR: u1,
                ///  Clear Framing Error Interrupt Flag
                FERR: u1,
                ///  Clear Multi-Processor Address Frame Interrupt Flag
                MPAF: u1,
                ///  Clear Start-Frame Interrupt Flag
                STARTF: u1,
                ///  Clear Signal-Frame Interrupt Flag
                SIGF: u1,
                padding: u21,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  TX Complete Interrupt Enable
                TXC: u1,
                ///  TX Buffer Level Interrupt Enable
                TXBL: u1,
                ///  RX Data Valid Interrupt Enable
                RXDATAV: u1,
                ///  RX Overflow Interrupt Enable
                RXOF: u1,
                ///  RX Underflow Interrupt Enable
                RXUF: u1,
                ///  TX Overflow Interrupt Enable
                TXOF: u1,
                ///  Parity Error Interrupt Enable
                PERR: u1,
                ///  Framing Error Interrupt Enable
                FERR: u1,
                ///  Multi-Processor Address Frame Interrupt Enable
                MPAF: u1,
                ///  Start Frame Interrupt Enable
                STARTF: u1,
                ///  Signal Frame Interrupt Enable
                SIGF: u1,
                padding: u21,
            }),
            ///  Pulse Control Register
            PULSECTRL: mmio.Mmio(packed struct(u32) {
                ///  Pulse Width
                PULSEW: u4,
                ///  Pulse Generator/Extender Enable
                PULSEEN: u1,
                ///  Pulse Filter
                PULSEFILT: u1,
                padding: u26,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  CMD Register Busy
                CMD: u1,
                ///  CLKDIV Register Busy
                CLKDIV: u1,
                ///  STARTFRAME Register Busy
                STARTFRAME: u1,
                ///  SIGFRAME Register Busy
                SIGFRAME: u1,
                ///  TXDATAX Register Busy
                TXDATAX: u1,
                ///  TXDATA Register Busy
                TXDATA: u1,
                ///  PULSECTRL Register Busy
                PULSECTRL: u1,
                padding: u24,
            }),
            reserved84: [12]u8,
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                ///  RX Pin Enable
                RXPEN: u1,
                ///  TX Pin Enable
                TXPEN: u1,
                reserved8: u6,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        ///  Location 4
                        LOC4 = 0x4,
                        _,
                    },
                },
                padding: u21,
            }),
            reserved172: [84]u8,
            ///  LEUART Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  RX PRS Channel Select
                RXPRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  PRS RX Enable
                RXPRS: u1,
                padding: u27,
            }),
        };

        ///  PCNT0
        pub const PCNT0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Mode Select
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The module is disabled.
                        DISABLE = 0x0,
                        ///  Single input LFACLK oversampling mode (available in EM0-EM2).
                        OVSSINGLE = 0x1,
                        ///  Externally clocked single input counter mode (available in EM0-EM3).
                        EXTCLKSINGLE = 0x2,
                        ///  Externally clocked quadrature decoder mode (available in EM0-EM3).
                        EXTCLKQUAD = 0x3,
                    },
                },
                ///  Non-Quadrature Mode Counter Direction Control
                CNTDIR: u1,
                ///  Edge Select
                EDGE: u1,
                ///  Enable Digital Pulse Width Filter
                FILT: u1,
                ///  Enable PCNT Clock Domain Reset
                RSTEN: u1,
                reserved8: u2,
                ///  Enable Hysteresis
                HYST: u1,
                ///  Count direction determined by S1
                S1CDIR: u1,
                ///  Controls when the counter counts
                CNTEV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Counts up on up-count and down on down-count events.
                        BOTH = 0x0,
                        ///  Only counts up on up-count events.
                        UP = 0x1,
                        ///  Only counts down on down-count events.
                        DOWN = 0x2,
                        ///  Never counts.
                        NONE = 0x3,
                    },
                },
                reserved14: u2,
                ///  Controls when the auxiliary counter counts
                AUXCNTEV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Never counts.
                        NONE = 0x0,
                        ///  Counts up on up-count events.
                        UP = 0x1,
                        ///  Counts up on down-count events.
                        DOWN = 0x2,
                        ///  Counts up on both up-count and down-count events.
                        BOTH = 0x3,
                    },
                },
                padding: u16,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Load CNT Immediately
                LCNTIM: u1,
                ///  Load TOPB Immediately
                LTOPBIM: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Current Counter Direction
                DIR: u1,
                padding: u31,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  Top Value Register
            TOP: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value
                TOP: u16,
                padding: u16,
            }),
            ///  Top Value Buffer Register
            TOPB: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Buffer
                TOPB: u16,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Read Flag
                UF: u1,
                ///  Overflow Interrupt Read Flag
                OF: u1,
                ///  Direction Change Detect Interrupt Flag
                DIRCNG: u1,
                ///  Overflow Interrupt Read Flag
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Underflow interrupt set
                UF: u1,
                ///  Overflow Interrupt Set
                OF: u1,
                ///  Direction Change Detect Interrupt Set
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Set
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Clear
                UF: u1,
                ///  Overflow Interrupt Clear
                OF: u1,
                ///  Direction Change Detect Interrupt Clear
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Clear
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Enable
                UF: u1,
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Direction Change Detect Interrupt Enable
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Enable
                AUXOF: u1,
                padding: u28,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  CMD Register Busy
                CMD: u1,
                ///  TOPB Register Busy
                TOPB: u1,
                padding: u29,
            }),
            reserved56: [4]u8,
            ///  Auxiliary Counter Value Register
            AUXCNT: mmio.Mmio(packed struct(u32) {
                ///  Auxiliary Counter Value
                AUXCNT: u16,
                padding: u16,
            }),
            ///  PCNT Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  S0IN PRS Channel Select
                S0PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected.
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected.
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected.
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected.
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected.
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected.
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected.
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected.
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected.
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected.
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected.
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  S0IN PRS Enable
                S0PRSEN: u1,
                reserved6: u1,
                ///  S1IN PRS Channel Select
                S1PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected.
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected.
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected.
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected.
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected.
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected.
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected.
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected.
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected.
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected.
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected.
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  S1IN PRS Enable
                S1PRSEN: u1,
                padding: u21,
            }),
        };

        ///  PCNT1
        pub const PCNT1 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Mode Select
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The module is disabled.
                        DISABLE = 0x0,
                        ///  Single input LFACLK oversampling mode (available in EM0-EM2).
                        OVSSINGLE = 0x1,
                        ///  Externally clocked single input counter mode (available in EM0-EM3).
                        EXTCLKSINGLE = 0x2,
                        ///  Externally clocked quadrature decoder mode (available in EM0-EM3).
                        EXTCLKQUAD = 0x3,
                    },
                },
                ///  Non-Quadrature Mode Counter Direction Control
                CNTDIR: u1,
                ///  Edge Select
                EDGE: u1,
                ///  Enable Digital Pulse Width Filter
                FILT: u1,
                ///  Enable PCNT Clock Domain Reset
                RSTEN: u1,
                reserved8: u2,
                ///  Enable Hysteresis
                HYST: u1,
                ///  Count direction determined by S1
                S1CDIR: u1,
                ///  Controls when the counter counts
                CNTEV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Counts up on up-count and down on down-count events.
                        BOTH = 0x0,
                        ///  Only counts up on up-count events.
                        UP = 0x1,
                        ///  Only counts down on down-count events.
                        DOWN = 0x2,
                        ///  Never counts.
                        NONE = 0x3,
                    },
                },
                reserved14: u2,
                ///  Controls when the auxiliary counter counts
                AUXCNTEV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Never counts.
                        NONE = 0x0,
                        ///  Counts up on up-count events.
                        UP = 0x1,
                        ///  Counts up on down-count events.
                        DOWN = 0x2,
                        ///  Counts up on both up-count and down-count events.
                        BOTH = 0x3,
                    },
                },
                padding: u16,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Load CNT Immediately
                LCNTIM: u1,
                ///  Load TOPB Immediately
                LTOPBIM: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Current Counter Direction
                DIR: u1,
                padding: u31,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  Top Value Register
            TOP: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value
                TOP: u16,
                padding: u16,
            }),
            ///  Top Value Buffer Register
            TOPB: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Buffer
                TOPB: u16,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Read Flag
                UF: u1,
                ///  Overflow Interrupt Read Flag
                OF: u1,
                ///  Direction Change Detect Interrupt Flag
                DIRCNG: u1,
                ///  Overflow Interrupt Read Flag
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Underflow interrupt set
                UF: u1,
                ///  Overflow Interrupt Set
                OF: u1,
                ///  Direction Change Detect Interrupt Set
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Set
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Clear
                UF: u1,
                ///  Overflow Interrupt Clear
                OF: u1,
                ///  Direction Change Detect Interrupt Clear
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Clear
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Enable
                UF: u1,
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Direction Change Detect Interrupt Enable
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Enable
                AUXOF: u1,
                padding: u28,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  CMD Register Busy
                CMD: u1,
                ///  TOPB Register Busy
                TOPB: u1,
                padding: u29,
            }),
            reserved56: [4]u8,
            ///  Auxiliary Counter Value Register
            AUXCNT: mmio.Mmio(packed struct(u32) {
                ///  Auxiliary Counter Value
                AUXCNT: u16,
                padding: u16,
            }),
            ///  PCNT Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  S0IN PRS Channel Select
                S0PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected.
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected.
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected.
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected.
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected.
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected.
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected.
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected.
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected.
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected.
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected.
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  S0IN PRS Enable
                S0PRSEN: u1,
                reserved6: u1,
                ///  S1IN PRS Channel Select
                S1PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected.
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected.
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected.
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected.
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected.
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected.
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected.
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected.
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected.
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected.
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected.
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  S1IN PRS Enable
                S1PRSEN: u1,
                padding: u21,
            }),
        };

        ///  PCNT2
        pub const PCNT2 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Mode Select
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The module is disabled.
                        DISABLE = 0x0,
                        ///  Single input LFACLK oversampling mode (available in EM0-EM2).
                        OVSSINGLE = 0x1,
                        ///  Externally clocked single input counter mode (available in EM0-EM3).
                        EXTCLKSINGLE = 0x2,
                        ///  Externally clocked quadrature decoder mode (available in EM0-EM3).
                        EXTCLKQUAD = 0x3,
                    },
                },
                ///  Non-Quadrature Mode Counter Direction Control
                CNTDIR: u1,
                ///  Edge Select
                EDGE: u1,
                ///  Enable Digital Pulse Width Filter
                FILT: u1,
                ///  Enable PCNT Clock Domain Reset
                RSTEN: u1,
                reserved8: u2,
                ///  Enable Hysteresis
                HYST: u1,
                ///  Count direction determined by S1
                S1CDIR: u1,
                ///  Controls when the counter counts
                CNTEV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Counts up on up-count and down on down-count events.
                        BOTH = 0x0,
                        ///  Only counts up on up-count events.
                        UP = 0x1,
                        ///  Only counts down on down-count events.
                        DOWN = 0x2,
                        ///  Never counts.
                        NONE = 0x3,
                    },
                },
                reserved14: u2,
                ///  Controls when the auxiliary counter counts
                AUXCNTEV: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Never counts.
                        NONE = 0x0,
                        ///  Counts up on up-count events.
                        UP = 0x1,
                        ///  Counts up on down-count events.
                        DOWN = 0x2,
                        ///  Counts up on both up-count and down-count events.
                        BOTH = 0x3,
                    },
                },
                padding: u16,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Load CNT Immediately
                LCNTIM: u1,
                ///  Load TOPB Immediately
                LTOPBIM: u1,
                padding: u30,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Current Counter Direction
                DIR: u1,
                padding: u31,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u16,
                padding: u16,
            }),
            ///  Top Value Register
            TOP: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Value
                TOP: u16,
                padding: u16,
            }),
            ///  Top Value Buffer Register
            TOPB: mmio.Mmio(packed struct(u32) {
                ///  Counter Top Buffer
                TOPB: u16,
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Read Flag
                UF: u1,
                ///  Overflow Interrupt Read Flag
                OF: u1,
                ///  Direction Change Detect Interrupt Flag
                DIRCNG: u1,
                ///  Overflow Interrupt Read Flag
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Underflow interrupt set
                UF: u1,
                ///  Overflow Interrupt Set
                OF: u1,
                ///  Direction Change Detect Interrupt Set
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Set
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Clear
                UF: u1,
                ///  Overflow Interrupt Clear
                OF: u1,
                ///  Direction Change Detect Interrupt Clear
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Clear
                AUXOF: u1,
                padding: u28,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Underflow Interrupt Enable
                UF: u1,
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Direction Change Detect Interrupt Enable
                DIRCNG: u1,
                ///  Auxiliary Overflow Interrupt Enable
                AUXOF: u1,
                padding: u28,
            }),
            ///  I/O Routing Register
            ROUTE: mmio.Mmio(packed struct(u32) {
                reserved8: u8,
                ///  I/O Location
                LOCATION: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Location 0
                        LOC0 = 0x0,
                        ///  Location 1
                        LOC1 = 0x1,
                        ///  Location 2
                        LOC2 = 0x2,
                        ///  Location 3
                        LOC3 = 0x3,
                        _,
                    },
                },
                padding: u21,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  CMD Register Busy
                CMD: u1,
                ///  TOPB Register Busy
                TOPB: u1,
                padding: u29,
            }),
            reserved56: [4]u8,
            ///  Auxiliary Counter Value Register
            AUXCNT: mmio.Mmio(packed struct(u32) {
                ///  Auxiliary Counter Value
                AUXCNT: u16,
                padding: u16,
            }),
            ///  PCNT Input Register
            INPUT: mmio.Mmio(packed struct(u32) {
                ///  S0IN PRS Channel Select
                S0PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected.
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected.
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected.
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected.
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected.
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected.
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected.
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected.
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected.
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected.
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected.
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  S0IN PRS Enable
                S0PRSEN: u1,
                reserved6: u1,
                ///  S1IN PRS Channel Select
                S1PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS Channel 0 selected.
                        PRSCH0 = 0x0,
                        ///  PRS Channel 1 selected.
                        PRSCH1 = 0x1,
                        ///  PRS Channel 2 selected.
                        PRSCH2 = 0x2,
                        ///  PRS Channel 3 selected.
                        PRSCH3 = 0x3,
                        ///  PRS Channel 4 selected.
                        PRSCH4 = 0x4,
                        ///  PRS Channel 5 selected.
                        PRSCH5 = 0x5,
                        ///  PRS Channel 6 selected.
                        PRSCH6 = 0x6,
                        ///  PRS Channel 7 selected.
                        PRSCH7 = 0x7,
                        ///  PRS Channel 8 selected.
                        PRSCH8 = 0x8,
                        ///  PRS Channel 9 selected.
                        PRSCH9 = 0x9,
                        ///  PRS Channel 10 selected.
                        PRSCH10 = 0xa,
                        ///  PRS Channel 11 selected.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                ///  S1IN PRS Enable
                S1PRSEN: u1,
                padding: u21,
            }),
        };

        ///  ADC0
        pub const ADC0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Warm-up Mode
                WARMUPMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ADC is shut down after each conversion
                        NORMAL = 0x0,
                        ///  Bandgap references do not need warm up, but have reduced accuracy.
                        FASTBG = 0x1,
                        ///  Reference selected for scan mode is kept warm.
                        KEEPSCANREFWARM = 0x2,
                        ///  ADC is kept warmed up and scan reference is kept warm
                        KEEPADCWARM = 0x3,
                    },
                },
                reserved3: u1,
                ///  Conversion Tailgating
                TAILGATE: u1,
                ///  Low Pass Filter Mode
                LPFMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No filter or decoupling capacitor
                        BYPASS = 0x0,
                        ///  On chip decoupling capacitor selected
                        DECAP = 0x1,
                        ///  On chip RC filter selected
                        RCFILT = 0x2,
                        _,
                    },
                },
                reserved8: u2,
                ///  Prescaler Setting
                PRESC: packed union {
                    raw: u7,
                    value: enum(u7) {
                        NODIVISION = 0x0,
                        _,
                    },
                },
                reserved16: u1,
                ///  Time Base
                TIMEBASE: u5,
                reserved24: u3,
                ///  Oversample Rate Select
                OVSRSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  2 samples for each conversion result
                        X2 = 0x0,
                        ///  4 samples for each conversion result
                        X4 = 0x1,
                        ///  8 samples for each conversion result
                        X8 = 0x2,
                        ///  16 samples for each conversion result
                        X16 = 0x3,
                        ///  32 samples for each conversion result
                        X32 = 0x4,
                        ///  64 samples for each conversion result
                        X64 = 0x5,
                        ///  128 samples for each conversion result
                        X128 = 0x6,
                        ///  256 samples for each conversion result
                        X256 = 0x7,
                        ///  512 samples for each conversion result
                        X512 = 0x8,
                        ///  1024 samples for each conversion result
                        X1024 = 0x9,
                        ///  2048 samples for each conversion result
                        X2048 = 0xa,
                        ///  4096 samples for each conversion result
                        X4096 = 0xb,
                        _,
                    },
                },
                padding: u4,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Start
                SINGLESTART: u1,
                ///  Single Conversion Stop
                SINGLESTOP: u1,
                ///  Scan Sequence Start
                SCANSTART: u1,
                ///  Scan Sequence Stop
                SCANSTOP: u1,
                padding: u28,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Active
                SINGLEACT: u1,
                ///  Scan Conversion Active
                SCANACT: u1,
                reserved8: u6,
                ///  Single Reference Warmed Up
                SINGLEREFWARM: u1,
                ///  Scan Reference Warmed Up
                SCANREFWARM: u1,
                reserved12: u2,
                ///  ADC Warmed Up
                WARM: u1,
                reserved16: u3,
                ///  Single Sample Data Valid
                SINGLEDV: u1,
                ///  Scan Data Valid
                SCANDV: u1,
                reserved24: u6,
                ///  Scan Data Source
                SCANDATASRC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Single ended mode: SCANDATA result originates from ADCn_CH0. Differential mode: SCANDATA result originates from ADCn_CH0-ADCn_CH1
                        CH0 = 0x0,
                        ///  Single ended mode: SCANDATA result originates from ADCn_CH1. Differential mode: SCANDATA result originates from ADCn_CH2_ADCn_CH3
                        CH1 = 0x1,
                        ///  Single ended mode: SCANDATA result originates from ADCn_CH2. Differential mode: SCANDATA result originates from ADCn_CH4-ADCn_CH5
                        CH2 = 0x2,
                        ///  Single ended mode: SCANDATA result originates from ADCn_CH3. Differential mode: SCANDATA result originates from ADCn_CH6-ADCn_CH7
                        CH3 = 0x3,
                        ///  SCANDATA result originates from ADCn_CH4
                        CH4 = 0x4,
                        ///  SCANDATA result originates from ADCn_CH5
                        CH5 = 0x5,
                        ///  SCANDATA result originates from ADCn_CH6
                        CH6 = 0x6,
                        ///  SCANDATA result originates from ADCn_CH7
                        CH7 = 0x7,
                    },
                },
                padding: u5,
            }),
            ///  Single Sample Control Register
            SINGLECTRL: mmio.Mmio(packed struct(u32) {
                ///  Single Sample Repetitive Mode
                REP: u1,
                ///  Single Sample Differential Mode
                DIFF: u1,
                ///  Single Sample Result Adjustment
                ADJ: u1,
                reserved4: u1,
                ///  Single Sample Resolution Select
                RES: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  12-bit resolution
                        @"12BIT" = 0x0,
                        ///  8-bit resolution
                        @"8BIT" = 0x1,
                        ///  6-bit resolution
                        @"6BIT" = 0x2,
                        ///  Oversampling enabled. Oversampling rate is set in OVSRSEL
                        OVS = 0x3,
                    },
                },
                reserved8: u2,
                ///  Single Sample Input Selection
                INPUTSEL: u4,
                reserved16: u4,
                ///  Single Sample Reference Selection
                REF: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Internal 1.25 V reference
                        @"1V25" = 0x0,
                        ///  Internal 2.5 V reference
                        @"2V5" = 0x1,
                        ///  Buffered VDD
                        VDD = 0x2,
                        ///  Internal differential 5 V reference
                        @"5VDIFF" = 0x3,
                        ///  Single ended external reference from ADCn_CH6
                        EXTSINGLE = 0x4,
                        ///  Differential external reference, 2x(ADCn_CH6 - ADCn_CH7)
                        @"2XEXTDIFF" = 0x5,
                        ///  Unbuffered 2xVDD
                        @"2XVDD" = 0x6,
                        _,
                    },
                },
                reserved20: u1,
                ///  Single Sample Acquisition Time
                AT: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  1 ADC_CLK cycle acquisition time for single sample
                        @"1CYCLE" = 0x0,
                        ///  2 ADC_CLK cycles acquisition time for single sample
                        @"2CYCLES" = 0x1,
                        ///  4 ADC_CLK cycles acquisition time for single sample
                        @"4CYCLES" = 0x2,
                        ///  8 ADC_CLK cycles acquisition time for single sample
                        @"8CYCLES" = 0x3,
                        ///  16 ADC_CLK cycles acquisition time for single sample
                        @"16CYCLES" = 0x4,
                        ///  32 ADC_CLK cycles acquisition time for single sample
                        @"32CYCLES" = 0x5,
                        ///  64 ADC_CLK cycles acquisition time for single sample
                        @"64CYCLES" = 0x6,
                        ///  128 ADC_CLK cycles acquisition time for single sample
                        @"128CYCLES" = 0x7,
                        ///  256 ADC_CLK cycles acquisition time for single sample
                        @"256CYCLES" = 0x8,
                        _,
                    },
                },
                ///  Single Sample PRS Trigger Enable
                PRSEN: u1,
                reserved28: u3,
                ///  Single Sample PRS Trigger Select
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS ch 0 triggers single sample
                        PRSCH0 = 0x0,
                        ///  PRS ch 1 triggers single sample
                        PRSCH1 = 0x1,
                        ///  PRS ch 2 triggers single sample
                        PRSCH2 = 0x2,
                        ///  PRS ch 3 triggers single sample
                        PRSCH3 = 0x3,
                        ///  PRS ch 4 triggers single sample
                        PRSCH4 = 0x4,
                        ///  PRS ch 5 triggers single sample
                        PRSCH5 = 0x5,
                        ///  PRS ch 6 triggers single sample
                        PRSCH6 = 0x6,
                        ///  PRS ch 7 triggers single sample
                        PRSCH7 = 0x7,
                        ///  PRS ch 8 triggers single sample
                        PRSCH8 = 0x8,
                        ///  PRS ch 9 triggers single sample
                        PRSCH9 = 0x9,
                        ///  PRS ch 10 triggers single sample
                        PRSCH10 = 0xa,
                        ///  PRS ch 11 triggers single sample
                        PRSCH11 = 0xb,
                        _,
                    },
                },
            }),
            ///  Scan Control Register
            SCANCTRL: mmio.Mmio(packed struct(u32) {
                ///  Scan Sequence Repetitive Mode
                REP: u1,
                ///  Scan Sequence Differential Mode
                DIFF: u1,
                ///  Scan Sequence Result Adjustment
                ADJ: u1,
                reserved4: u1,
                ///  Scan Sequence Resolution Select
                RES: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  12-bit resolution
                        @"12BIT" = 0x0,
                        ///  8-bit resolution
                        @"8BIT" = 0x1,
                        ///  6-bit resolution
                        @"6BIT" = 0x2,
                        ///  Oversampling enabled. Oversampling rate is set in OVSRSEL
                        OVS = 0x3,
                    },
                },
                reserved8: u2,
                ///  Scan Sequence Input Mask
                INPUTMASK: u8,
                ///  Scan Sequence Reference Selection
                REF: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Internal 1.25 V reference
                        @"1V25" = 0x0,
                        ///  Internal 2.5 V reference
                        @"2V5" = 0x1,
                        ///  VDD
                        VDD = 0x2,
                        ///  Internal differential 5 V reference
                        @"5VDIFF" = 0x3,
                        ///  Single ended external reference from ADCn_CH6
                        EXTSINGLE = 0x4,
                        ///  Differential external reference, 2x(ADCn_CH6 - ADCn_CH7)
                        @"2XEXTDIFF" = 0x5,
                        ///  Unbuffered 2xVDD
                        @"2XVDD" = 0x6,
                        _,
                    },
                },
                reserved20: u1,
                ///  Scan Sample Acquisition Time
                AT: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  1 ADC_CLK cycle acquisition time for scan samples
                        @"1CYCLE" = 0x0,
                        ///  2 ADC_CLK cycles acquisition time for scan samples
                        @"2CYCLES" = 0x1,
                        ///  4 ADC_CLK cycles acquisition time for scan samples
                        @"4CYCLES" = 0x2,
                        ///  8 ADC_CLK cycles acquisition time for scan samples
                        @"8CYCLES" = 0x3,
                        ///  16 ADC_CLK cycles acquisition time for scan samples
                        @"16CYCLES" = 0x4,
                        ///  32 ADC_CLK cycles acquisition time for scan samples
                        @"32CYCLES" = 0x5,
                        ///  64 ADC_CLK cycles acquisition time for scan samples
                        @"64CYCLES" = 0x6,
                        ///  128 ADC_CLK cycles acquisition time for scan samples
                        @"128CYCLES" = 0x7,
                        ///  256 ADC_CLK cycles acquisition time for scan samples
                        @"256CYCLES" = 0x8,
                        _,
                    },
                },
                ///  Scan Sequence PRS Trigger Enable
                PRSEN: u1,
                reserved28: u3,
                ///  Scan Sequence PRS Trigger Select
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS ch 0 triggers scan sequence
                        PRSCH0 = 0x0,
                        ///  PRS ch 1 triggers scan sequence
                        PRSCH1 = 0x1,
                        ///  PRS ch 2 triggers scan sequence
                        PRSCH2 = 0x2,
                        ///  PRS ch 3 triggers scan sequence
                        PRSCH3 = 0x3,
                        ///  PRS ch 4 triggers scan sequence
                        PRSCH4 = 0x4,
                        ///  PRS ch 5 triggers scan sequence
                        PRSCH5 = 0x5,
                        ///  PRS ch 6 triggers scan sequence
                        PRSCH6 = 0x6,
                        ///  PRS ch 7 triggers scan sequence
                        PRSCH7 = 0x7,
                        ///  PRS ch 8 triggers scan sequence
                        PRSCH8 = 0x8,
                        ///  PRS ch 9 triggers scan sequence
                        PRSCH9 = 0x9,
                        ///  PRS ch 10 triggers scan sequence
                        PRSCH10 = 0xa,
                        ///  PRS ch 11 triggers scan sequence
                        PRSCH11 = 0xb,
                        _,
                    },
                },
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Complete Interrupt Enable
                SINGLE: u1,
                ///  Scan Conversion Complete Interrupt Enable
                SCAN: u1,
                reserved8: u6,
                ///  Single Result Overflow Interrupt Enable
                SINGLEOF: u1,
                ///  Scan Result Overflow Interrupt Enable
                SCANOF: u1,
                padding: u22,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Complete Interrupt Flag
                SINGLE: u1,
                ///  Scan Conversion Complete Interrupt Flag
                SCAN: u1,
                reserved8: u6,
                ///  Single Result Overflow Interrupt Flag
                SINGLEOF: u1,
                ///  Scan Result Overflow Interrupt Flag
                SCANOF: u1,
                padding: u22,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Complete Interrupt Flag Set
                SINGLE: u1,
                ///  Scan Conversion Complete Interrupt Flag Set
                SCAN: u1,
                reserved8: u6,
                ///  Single Result Overflow Interrupt Flag Set
                SINGLEOF: u1,
                ///  Scan Result Overflow Interrupt Flag Set
                SCANOF: u1,
                padding: u22,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Complete Interrupt Flag Clear
                SINGLE: u1,
                ///  Scan Conversion Complete Interrupt Flag Clear
                SCAN: u1,
                reserved8: u6,
                ///  Single Result Overflow Interrupt Flag Clear
                SINGLEOF: u1,
                ///  Scan Result Overflow Interrupt Flag Clear
                SCANOF: u1,
                padding: u22,
            }),
            ///  Single Conversion Result Data
            SINGLEDATA: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Result Data
                DATA: u32,
            }),
            ///  Scan Conversion Result Data
            SCANDATA: mmio.Mmio(packed struct(u32) {
                ///  Scan Conversion Result Data
                DATA: u32,
            }),
            ///  Single Conversion Result Data Peek Register
            SINGLEDATAP: mmio.Mmio(packed struct(u32) {
                ///  Single Conversion Result Data Peek
                DATAP: u32,
            }),
            ///  Scan Sequence Result Data Peek Register
            SCANDATAP: mmio.Mmio(packed struct(u32) {
                ///  Scan Conversion Result Data Peek
                DATAP: u32,
            }),
            ///  Calibration Register
            CAL: mmio.Mmio(packed struct(u32) {
                ///  Single Mode Offset Calibration Value
                SINGLEOFFSET: u7,
                reserved8: u1,
                ///  Single Mode Gain Calibration Value
                SINGLEGAIN: u7,
                reserved16: u1,
                ///  Scan Mode Offset Calibration Value
                SCANOFFSET: u7,
                reserved24: u1,
                ///  Scan Mode Gain Calibration Value
                SCANGAIN: u7,
                padding: u1,
            }),
            reserved60: [4]u8,
            ///  Bias Programming Register
            BIASPROG: mmio.Mmio(packed struct(u32) {
                ///  Bias Programming Value
                BIASPROG: u4,
                reserved6: u2,
                ///  Half Bias Current
                HALFBIAS: u1,
                reserved8: u1,
                ///  Comparator Bias Value
                COMPBIAS: u4,
                padding: u20,
            }),
        };

        ///  DAC0
        pub const DAC0 = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Differential Mode
                DIFF: u1,
                ///  Sine Mode
                SINEMODE: u1,
                ///  Conversion Mode
                CONVMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DAC is set in continuous mode
                        CONTINUOUS = 0x0,
                        ///  DAC is set in sample/hold mode
                        SAMPLEHOLD = 0x1,
                        ///  DAC is set in sample/shut off mode
                        SAMPLEOFF = 0x2,
                        _,
                    },
                },
                ///  Output Mode
                OUTMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  DAC output to pin and ADC disabled
                        DISABLE = 0x0,
                        ///  DAC output to pin enabled. DAC output to ADC and ACMP disabled
                        PIN = 0x1,
                        ///  DAC output to pin disabled. DAC output to ADC and ACMP enabled
                        ADC = 0x2,
                        ///  DAC output to pin, ADC, and ACMP enabled
                        PINADC = 0x3,
                    },
                },
                ///  PRS Controlled Output Enable
                OUTENPRS: u1,
                ///  Channel 0 Start Reset Prescaler
                CH0PRESCRST: u1,
                ///  Reference Selection
                REFSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Internal 1.25 V bandgap reference
                        @"1V25" = 0x0,
                        ///  Internal 2.5 V bandgap reference
                        @"2V5" = 0x1,
                        ///  VDD reference
                        VDD = 0x2,
                        _,
                    },
                },
                reserved16: u6,
                ///  Prescaler Setting
                PRESC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        NODIVISION = 0x0,
                        _,
                    },
                },
                reserved20: u1,
                ///  Refresh Interval Select
                REFRSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  All channels with enabled refresh are refreshed every 8 prescaled cycles
                        @"8CYCLES" = 0x0,
                        ///  All channels with enabled refresh are refreshed every 16 prescaled cycles
                        @"16CYCLES" = 0x1,
                        ///  All channels with enabled refresh are refreshed every 32 prescaled cycles
                        @"32CYCLES" = 0x2,
                        ///  All channels with enabled refresh are refreshed every 64 prescaled cycles
                        @"64CYCLES" = 0x3,
                    },
                },
                padding: u10,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Data Valid
                CH0DV: u1,
                ///  Channel 1 Data Valid
                CH1DV: u1,
                padding: u30,
            }),
            ///  Channel 0 Control Register
            CH0CTRL: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Enable
                EN: u1,
                ///  Channel 0 Automatic Refresh Enable
                REFREN: u1,
                ///  Channel 0 PRS Trigger Enable
                PRSEN: u1,
                reserved4: u1,
                ///  Channel 0 PRS Trigger Select
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS ch 0 triggers channel 0 conversion.
                        PRSCH0 = 0x0,
                        ///  PRS ch 1 triggers channel 0 conversion.
                        PRSCH1 = 0x1,
                        ///  PRS ch 2 triggers channel 0 conversion.
                        PRSCH2 = 0x2,
                        ///  PRS ch 3 triggers channel 0 conversion.
                        PRSCH3 = 0x3,
                        ///  PRS ch 4 triggers channel 0 conversion.
                        PRSCH4 = 0x4,
                        ///  PRS ch 5 triggers channel 0 conversion.
                        PRSCH5 = 0x5,
                        ///  PRS ch 6 triggers channel 0 conversion.
                        PRSCH6 = 0x6,
                        ///  PRS ch 7 triggers channel 0 conversion.
                        PRSCH7 = 0x7,
                        ///  PRS ch 8 triggers channel 0 conversion.
                        PRSCH8 = 0x8,
                        ///  PRS ch 9 triggers channel 0 conversion.
                        PRSCH9 = 0x9,
                        ///  PRS ch 10 triggers channel 0 conversion.
                        PRSCH10 = 0xa,
                        ///  PRS ch 11 triggers channel 0 conversion.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  Channel 1 Control Register
            CH1CTRL: mmio.Mmio(packed struct(u32) {
                ///  Channel 1 Enable
                EN: u1,
                ///  Channel 1 Automatic Refresh Enable
                REFREN: u1,
                ///  Channel 1 PRS Trigger Enable
                PRSEN: u1,
                reserved4: u1,
                ///  Channel 1 PRS Trigger Select
                PRSSEL: packed union {
                    raw: u4,
                    value: enum(u4) {
                        ///  PRS ch 0 triggers channel 1 conversion.
                        PRSCH0 = 0x0,
                        ///  PRS ch 1 triggers channel 1 conversion.
                        PRSCH1 = 0x1,
                        ///  PRS ch 2 triggers channel 1 conversion.
                        PRSCH2 = 0x2,
                        ///  PRS ch 3 triggers channel 1 conversion.
                        PRSCH3 = 0x3,
                        ///  PRS ch 4 triggers channel 1 conversion.
                        PRSCH4 = 0x4,
                        ///  PRS ch 5 triggers channel 1 conversion.
                        PRSCH5 = 0x5,
                        ///  PRS ch 6 triggers channel 1 conversion.
                        PRSCH6 = 0x6,
                        ///  PRS ch 7 triggers channel 1 conversion.
                        PRSCH7 = 0x7,
                        ///  PRS ch 8 triggers channel 1 conversion.
                        PRSCH8 = 0x8,
                        ///  PRS ch 9 triggers channel 1 conversion.
                        PRSCH9 = 0x9,
                        ///  PRS ch 10 triggers channel 1 conversion.
                        PRSCH10 = 0xa,
                        ///  PRS ch 11 triggers channel 1 conversion.
                        PRSCH11 = 0xb,
                        _,
                    },
                },
                padding: u24,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Conversion Complete Interrupt Enable
                CH0: u1,
                ///  Channel 1 Conversion Complete Interrupt Enable
                CH1: u1,
                reserved4: u2,
                ///  Channel 0 Conversion Data Underflow Interrupt Enable
                CH0UF: u1,
                ///  Channel 1 Conversion Data Underflow Interrupt Enable
                CH1UF: u1,
                padding: u26,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Conversion Complete Interrupt Flag
                CH0: u1,
                ///  Channel 1 Conversion Complete Interrupt Flag
                CH1: u1,
                reserved4: u2,
                ///  Channel 0 Data Underflow Interrupt Flag
                CH0UF: u1,
                ///  Channel 1 Data Underflow Interrupt Flag
                CH1UF: u1,
                padding: u26,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Conversion Complete Interrupt Flag Set
                CH0: u1,
                ///  Channel 1 Conversion Complete Interrupt Flag Set
                CH1: u1,
                reserved4: u2,
                ///  Channel 0 Data Underflow Interrupt Flag Set
                CH0UF: u1,
                ///  Channel 1 Data Underflow Interrupt Flag Set
                CH1UF: u1,
                padding: u26,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Conversion Complete Interrupt Flag Clear
                CH0: u1,
                ///  Channel 1 Conversion Complete Interrupt Flag Clear
                CH1: u1,
                reserved4: u2,
                ///  Channel 0 Data Underflow Interrupt Flag Clear
                CH0UF: u1,
                ///  Channel 1 Data Underflow Interrupt Flag Clear
                CH1UF: u1,
                padding: u26,
            }),
            ///  Channel 0 Data Register
            CH0DATA: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Data
                DATA: u12,
                padding: u20,
            }),
            ///  Channel 1 Data Register
            CH1DATA: mmio.Mmio(packed struct(u32) {
                ///  Channel 1 Data
                DATA: u12,
                padding: u20,
            }),
            ///  Combined Data Register
            COMBDATA: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Data
                CH0DATA: u12,
                reserved16: u4,
                ///  Channel 1 Data
                CH1DATA: u12,
                padding: u4,
            }),
            ///  Calibration Register
            CAL: mmio.Mmio(packed struct(u32) {
                ///  Channel 0 Offset Calibration Value
                CH0OFFSET: u6,
                reserved8: u2,
                ///  Channel 1 Offset Calibration Value
                CH1OFFSET: u6,
                reserved16: u2,
                ///  Gain Calibration Value
                GAIN: u7,
                padding: u9,
            }),
            ///  Bias Programming Register
            BIASPROG: mmio.Mmio(packed struct(u32) {
                ///  Bias Programming Value
                BIASPROG: u4,
                reserved6: u2,
                ///  Half Bias Current
                HALFBIAS: u1,
                reserved8: u1,
                ///  Bias Programming Value for OPA2
                OPA2BIASPROG: u4,
                reserved14: u2,
                ///  Half Bias Current
                OPA2HALFBIAS: u1,
                padding: u17,
            }),
            reserved84: [32]u8,
            ///  Operational Amplifier Control Register
            OPACTRL: mmio.Mmio(packed struct(u32) {
                ///  OPA0 Enable
                OPA0EN: u1,
                ///  OPA1 Enable
                OPA1EN: u1,
                ///  OPA2 Enable
                OPA2EN: u1,
                reserved6: u3,
                ///  High Common Mode Disable.
                OPA0HCMDIS: u1,
                ///  High Common Mode Disable.
                OPA1HCMDIS: u1,
                ///  High Common Mode Disable.
                OPA2HCMDIS: u1,
                reserved12: u3,
                ///  Disables Low Pass Filter.
                OPA0LPFDIS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disables the LPF between positive pad and positive input.
                        PLPFDIS = 0x1,
                        ///  Disables the LPF between negative pad and negative input.
                        NLPFDIS = 0x2,
                        _,
                    },
                },
                ///  Disables Low Pass Filter.
                OPA1LPFDIS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disables the LPF between positive pad and positive input.
                        PLPFDIS = 0x1,
                        ///  Disables the LPF between negative pad and negative input.
                        NLPFDIS = 0x2,
                        _,
                    },
                },
                ///  Disables Low Pass Filter.
                OPA2LPFDIS: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Disables the LPF between positive pad and positive input.
                        PLPFDIS = 0x1,
                        ///  Disables the LPF between negative pad and negative input.
                        NLPFDIS = 0x2,
                        _,
                    },
                },
                reserved22: u4,
                ///  Short the non-inverting and inverting input.
                OPA0SHORT: u1,
                ///  Short the non-inverting and inverting input.
                OPA1SHORT: u1,
                ///  Short the non-inverting and inverting input.
                OPA2SHORT: u1,
                padding: u7,
            }),
            ///  Operational Amplifier Offset Register
            OPAOFFSET: mmio.Mmio(packed struct(u32) {
                ///  OPA2 Offset Configuration Value
                OPA2OFFSET: u6,
                padding: u26,
            }),
            ///  Operational Amplifier Mux Configuration Register
            OPA0MUX: mmio.Mmio(packed struct(u32) {
                ///  OPA0 non-inverting Input Mux
                POSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Input disabled
                        DISABLE = 0x0,
                        ///  DAC as input
                        DAC = 0x1,
                        ///  POS PAD as input
                        POSPAD = 0x2,
                        ///  OPA0 as input
                        OPA0INP = 0x3,
                        ///  OPA0 Resistor ladder as input
                        OPATAP = 0x4,
                        _,
                    },
                },
                reserved4: u1,
                ///  OPA0 inverting Input Mux
                NEGSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input disabled
                        DISABLE = 0x0,
                        ///  Unity Gain feedback path
                        UG = 0x1,
                        ///  OPA0 Resistor ladder as input
                        OPATAP = 0x2,
                        ///  Input from NEG PAD
                        NEGPAD = 0x3,
                    },
                },
                reserved8: u2,
                ///  OPA0 Resistor Ladder Input Mux
                RESINMUX: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Set for Unity Gain
                        DISABLE = 0x0,
                        ///  Set for OPA0 input
                        OPA0INP = 0x1,
                        ///  NEG pad connected
                        NEGPAD = 0x2,
                        ///  POS pad connected
                        POSPAD = 0x3,
                        ///  VSS connected
                        VSS = 0x4,
                        _,
                    },
                },
                reserved12: u1,
                ///  OPA0 Positive Pad Input Enable
                PPEN: u1,
                ///  OPA0 Negative Pad Input Enable
                NPEN: u1,
                ///  OPA0 Output Enable Value
                OUTPEN: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  Alternate Output 0
                        OUT0 = 0x1,
                        ///  Alternate Output 1
                        OUT1 = 0x2,
                        ///  Alternate Output 2
                        OUT2 = 0x4,
                        ///  Alternate Output 3
                        OUT3 = 0x8,
                        ///  Alternate Output 4
                        OUT4 = 0x10,
                        _,
                    },
                },
                reserved22: u3,
                ///  Output Select
                OUTMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  OPA0 output is disabled
                        DISABLE = 0x0,
                        ///  Main OPA0 output to pin enabled
                        MAIN = 0x1,
                        ///  OPA0 alternative output enabled.
                        ALT = 0x2,
                        ///  Main OPA0 output drives both main and alternative outputs.
                        ALL = 0x3,
                    },
                },
                reserved26: u2,
                ///  OPA0 Next Enable
                NEXTOUT: u1,
                reserved28: u1,
                ///  OPA0 Resistor Ladder Select
                RESSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Gain of 1/3
                        RES0 = 0x0,
                        ///  Gain of 1
                        RES1 = 0x1,
                        ///  Gain of 1 2/3
                        RES2 = 0x2,
                        ///  Gain of 2
                        RES3 = 0x3,
                        ///  Gain of 3
                        RES4 = 0x4,
                        ///  Gain of 4 1/3
                        RES5 = 0x5,
                        ///  Gain of 7
                        RES6 = 0x6,
                        ///  Gain of 15
                        RES7 = 0x7,
                    },
                },
                padding: u1,
            }),
            ///  Operational Amplifier Mux Configuration Register
            OPA1MUX: mmio.Mmio(packed struct(u32) {
                ///  OPA1 non-inverting Input Mux
                POSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Input disabled
                        DISABLE = 0x0,
                        ///  DAC as input
                        DAC = 0x1,
                        ///  POS PAD as input
                        POSPAD = 0x2,
                        ///  OPA0 as input
                        OPA0INP = 0x3,
                        ///  OPA 1 Resistor ladder as input
                        OPATAP = 0x4,
                        _,
                    },
                },
                reserved4: u1,
                ///  OPA1 inverting Input Mux
                NEGSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input disabled
                        DISABLE = 0x0,
                        ///  Unity Gain feedback path
                        UG = 0x1,
                        ///  OPA1 Resistor ladder as input
                        OPATAP = 0x2,
                        ///  Input from NEG PAD
                        NEGPAD = 0x3,
                    },
                },
                reserved8: u2,
                ///  OPA1 Resistor Ladder Input Mux
                RESINMUX: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Set for Unity Gain
                        DISABLE = 0x0,
                        ///  Set for OPA0 input
                        OPA0INP = 0x1,
                        ///  NEG PAD connected
                        NEGPAD = 0x2,
                        ///  POS PAD connected
                        POSPAD = 0x3,
                        ///  VSS connected
                        VSS = 0x4,
                        _,
                    },
                },
                reserved12: u1,
                ///  OPA1 Positive Pad Input Enable
                PPEN: u1,
                ///  OPA1 Negative Pad Input Enable
                NPEN: u1,
                ///  OPA1 Output Enable Value
                OUTPEN: packed union {
                    raw: u5,
                    value: enum(u5) {
                        ///  Alternate Output 0
                        OUT0 = 0x1,
                        ///  Alternate Output 1
                        OUT1 = 0x2,
                        ///  Alternate Output 2
                        OUT2 = 0x4,
                        ///  Alternate Output 3
                        OUT3 = 0x8,
                        ///  Alternate Output 4
                        OUT4 = 0x10,
                        _,
                    },
                },
                reserved22: u3,
                ///  Output Select
                OUTMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  OPA0 output is disabled
                        DISABLE = 0x0,
                        ///  Main OPA1 output to pin enabled
                        MAIN = 0x1,
                        ///  OPA1 alternative output enabled.
                        ALT = 0x2,
                        ///  Main OPA1 output drives both main and alternative outputs.
                        ALL = 0x3,
                    },
                },
                reserved26: u2,
                ///  OPA1 Next Enable
                NEXTOUT: u1,
                reserved28: u1,
                ///  OPA1 Resistor Ladder Select
                RESSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Gain of 1/3
                        RES0 = 0x0,
                        ///  Gain of 1
                        RES1 = 0x1,
                        ///  Gain of 1 2/3
                        RES2 = 0x2,
                        ///  Gain of 2
                        RES3 = 0x3,
                        ///  Gain of 3
                        RES4 = 0x4,
                        ///  Gain of 4 1/3
                        RES5 = 0x5,
                        ///  Gain of 7
                        RES6 = 0x6,
                        ///  Gain of 15
                        RES7 = 0x7,
                    },
                },
                padding: u1,
            }),
            ///  Operational Amplifier Mux Configuration Register
            OPA2MUX: mmio.Mmio(packed struct(u32) {
                ///  OPA2 non-inverting Input Mux
                POSSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Input disabled
                        DISABLE = 0x0,
                        ///  POS PAD as input
                        POSPAD = 0x2,
                        ///  OPA1 as input
                        OPA1INP = 0x3,
                        ///  OPA0 Resistor ladder as input
                        OPATAP = 0x4,
                        _,
                    },
                },
                reserved4: u1,
                ///  OPA2 inverting Input Mux
                NEGSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Input disabled
                        DISABLE = 0x0,
                        ///  Unity Gain feedback path
                        UG = 0x1,
                        ///  OPA2 Resistor ladder as input
                        OPATAP = 0x2,
                        ///  Input from NEG PAD
                        NEGPAD = 0x3,
                    },
                },
                reserved8: u2,
                ///  OPA2 Resistor Ladder Input Mux
                RESINMUX: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Set for Unity Gain
                        DISABLE = 0x0,
                        ///  Set for OPA1 input
                        OPA1INP = 0x1,
                        ///  NEG PAD connected
                        NEGPAD = 0x2,
                        ///  POS PAD connected
                        POSPAD = 0x3,
                        ///  VSS connected
                        VSS = 0x4,
                        _,
                    },
                },
                reserved12: u1,
                ///  OPA2 Positive Pad Input Enable
                PPEN: u1,
                ///  OPA2 Negative Pad Input Enable
                NPEN: u1,
                ///  OPA2 Output Location
                OUTPEN: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Main Output 0
                        OUT0 = 0x1,
                        ///  Main Output 1
                        OUT1 = 0x2,
                        _,
                    },
                },
                reserved22: u6,
                ///  Output Select
                OUTMODE: u1,
                reserved26: u3,
                ///  OPA2 Next Enable
                NEXTOUT: u1,
                reserved28: u1,
                ///  OPA2 Resistor Ladder Select
                RESSEL: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Gain of 1/3
                        RES0 = 0x0,
                        ///  Gain of 1
                        RES1 = 0x1,
                        ///  Gain of 1 2/3
                        RES2 = 0x2,
                        ///  Gain of 2
                        RES3 = 0x3,
                        ///  Gain of 3
                        RES4 = 0x4,
                        ///  Gain of 4 1/3
                        RES5 = 0x5,
                        ///  Gain of 7
                        RES6 = 0x6,
                        ///  Gain of 15
                        RES7 = 0x7,
                    },
                },
                padding: u1,
            }),
        };

        ///  BURTC
        pub const BURTC = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  BURTC Enable
                MODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  The BURTC is disabled.
                        DISABLE = 0x0,
                        ///  The BURTC is in normal operating mode, operating in EM0-EM2. Oscillators must be enabled in CMU for use.
                        EM2EN = 0x1,
                        ///  The BURTC is enabled in EM0-EM3. Will prevent CMU from disabling used oscillators all the way down to EM3.
                        EM3EN = 0x2,
                        ///  The BURTC is enabled in EM0-EM4. Will prevent CMU from disabling used oscillators all the way down to EM4.
                        EM4EN = 0x3,
                    },
                },
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                ///  Enable BURTC reset
                RSTEN: u1,
                ///  Compare clear enable
                COMP0TOP: u1,
                ///  Low power mode compare configuration
                LPCOMP: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Do not ignore any bits for compare match evaluation.
                        IGN0LSB = 0x0,
                        ///  The LSB of the counter is ignored for compare match evaluation.
                        IGN1LSB = 0x1,
                        ///  The two LSBs of the counter are ignored for compare match evaluation.
                        IGN2LSB = 0x2,
                        ///  The three LSBs of the counter are ignored for compare match evaluation.
                        IGN3LSB = 0x3,
                        ///  The four LSBs of the counter are ignored for compare match evaluation.
                        IGN4LSB = 0x4,
                        ///  The five LSBs of the counter are ignored for compare match evaluation.
                        IGN5LSB = 0x5,
                        ///  The six LSBs of the counter are ignored for compare match evaluation.
                        IGN6LSB = 0x6,
                        ///  The seven LSBs of the counter are ignored for compare match evaluation.
                        IGN7LSB = 0x7,
                    },
                },
                ///  Select BURTC prescaler factor
                PRESC: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  No prescaling.
                        DIV1 = 0x0,
                        ///  Prescaling factor of 2
                        DIV2 = 0x1,
                        ///  Prescaling factor of 4
                        DIV4 = 0x2,
                        ///  Prescaling factor of 8
                        DIV8 = 0x3,
                        ///  Prescaling factor of 16
                        DIV16 = 0x4,
                        ///  Prescaling factor of 32
                        DIV32 = 0x5,
                        ///  Prescaling factor of 64
                        DIV64 = 0x6,
                        ///  Prescaling factor of 128
                        DIV128 = 0x7,
                    },
                },
                reserved12: u1,
                ///  Select BURTC clock source
                CLKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  No clock source selected for BURTC.
                        NONE = 0x0,
                        ///  LFRCO selected as BURTC clock source.
                        LFRCO = 0x1,
                        ///  LFXO selected as BURTC clock source.
                        LFXO = 0x2,
                        ///  ULFRCO selected as BURTC clock source.
                        ULFRCO = 0x3,
                    },
                },
                ///  Backup mode timestamp enable
                BUMODETSEN: u1,
                padding: u17,
            }),
            ///  Low power mode configuration
            LPMODE: mmio.Mmio(packed struct(u32) {
                ///  Low power mode configuration.
                LPMODE: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Low power mode is disabled.
                        DISABLE = 0x0,
                        ///  Low power mode always enabled.
                        ENABLE = 0x1,
                        ///  Low power mode enabled in backup mode.
                        BUEN = 0x2,
                        _,
                    },
                },
                padding: u30,
            }),
            ///  Counter Value Register
            CNT: mmio.Mmio(packed struct(u32) {
                ///  Counter Value
                CNT: u32,
            }),
            ///  Counter Compare Value
            COMP0: mmio.Mmio(packed struct(u32) {
                ///  Compare match value
                COMP0: u32,
            }),
            ///  Backup mode timestamp
            TIMESTAMP: mmio.Mmio(packed struct(u32) {
                ///  Backup mode timestamp.
                TIMESTAMP: u32,
            }),
            ///  LFXO
            LFXOFDET: mmio.Mmio(packed struct(u32) {
                ///  LFXO failure detection configuration.
                OSC: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  LFXO failure detection disabled.
                        DISABLE = 0x0,
                        ///  LFRCO used for LFXO failure detection.
                        LFRCO = 0x1,
                        ///  ULFRCO used for LFXO failure detection.
                        ULFRCO = 0x2,
                        _,
                    },
                },
                reserved4: u2,
                ///  LFXO failure counter top value.
                TOP: u5,
                padding: u23,
            }),
            ///  Status Register
            STATUS: mmio.Mmio(packed struct(u32) {
                ///  Low power mode active
                LPMODEACT: u1,
                ///  Timestamp for backup mode entry stored.
                BUMODETS: u1,
                ///  RAM write error.
                RAMWERR: u1,
                padding: u29,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Clear BURTC_STATUS register.
                CLRSTATUS: u1,
                padding: u31,
            }),
            ///  Retention RAM power-down Register
            POWERDOWN: mmio.Mmio(packed struct(u32) {
                ///  Retention RAM power-down
                RAM: u1,
                padding: u31,
            }),
            ///  Configuration Lock Register
            LOCK: mmio.Mmio(packed struct(u32) {
                ///  Configuration Lock Key
                LOCKKEY: packed union {
                    raw: u16,
                    value: enum(u16) {
                        UNLOCKED = 0x0,
                        LOCKED = 0x1,
                        _,
                    },
                },
                padding: u16,
            }),
            ///  Interrupt Flag Register
            IF: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Flag
                OF: u1,
                ///  Compare match Interrupt Flag
                COMP0: u1,
                ///  LFXO failure Interrupt Flag
                LFXOFAIL: u1,
                padding: u29,
            }),
            ///  Interrupt Flag Set Register
            IFS: mmio.Mmio(packed struct(u32) {
                ///  Set Overflow Interrupt Flag
                OF: u1,
                ///  Set compare match Interrupt Flag
                COMP0: u1,
                ///  Set LFXO fail Interrupt Flag
                LFXOFAIL: u1,
                padding: u29,
            }),
            ///  Interrupt Flag Clear Register
            IFC: mmio.Mmio(packed struct(u32) {
                ///  Clear Overflow Interrupt Flag
                OF: u1,
                ///  Clear compare match Interrupt Flag
                COMP0: u1,
                ///  Clear LFXO failure Interrupt Flag
                LFXOFAIL: u1,
                padding: u29,
            }),
            ///  Interrupt Enable Register
            IEN: mmio.Mmio(packed struct(u32) {
                ///  Overflow Interrupt Enable
                OF: u1,
                ///  Compare match Interrupt Enable
                COMP0: u1,
                ///  LFXO failure Interrupt Enable
                LFXOFAIL: u1,
                padding: u29,
            }),
            ///  Freeze Register
            FREEZE: mmio.Mmio(packed struct(u32) {
                ///  Register Update Freeze
                REGFREEZE: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  LPMODE Register Busy
                LPMODE: u1,
                ///  COMP0 Register Busy
                COMP0: u1,
                padding: u30,
            }),
            reserved256: [192]u8,
            ///  Retention Register
            RET0_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET1_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET2_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET3_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET4_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET5_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET6_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET7_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET8_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET9_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET10_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET11_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET12_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET13_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET14_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET15_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET16_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET17_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET18_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET19_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET20_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET21_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET22_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET23_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET24_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET25_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET26_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET27_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET28_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET29_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET30_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET31_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET32_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET33_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET34_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET35_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET36_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET37_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET38_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET39_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET40_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET41_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET42_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET43_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET44_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET45_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET46_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET47_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET48_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET49_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET50_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET51_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET52_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET53_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET54_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET55_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET56_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET57_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET58_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET59_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET60_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET61_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET62_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET63_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET64_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET65_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET66_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET67_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET68_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET69_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET70_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET71_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET72_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET73_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET74_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET75_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET76_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET77_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET78_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET79_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET80_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET81_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET82_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET83_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET84_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET85_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET86_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET87_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET88_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET89_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET90_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET91_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET92_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET93_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET94_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET95_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET96_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET97_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET98_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET99_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET100_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET101_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET102_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET103_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET104_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET105_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET106_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET107_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET108_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET109_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET110_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET111_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET112_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET113_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET114_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET115_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET116_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET117_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET118_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET119_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET120_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET121_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET122_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET123_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET124_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET125_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET126_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
            ///  Retention Register
            RET127_REG: mmio.Mmio(packed struct(u32) {
                ///  General Purpose Retention Register
                REG: u32,
            }),
        };

        ///  WDOG
        pub const WDOG = extern struct {
            ///  Control Register
            CTRL: mmio.Mmio(packed struct(u32) {
                ///  Watchdog Timer Enable
                EN: u1,
                ///  Debug Mode Run Enable
                DEBUGRUN: u1,
                ///  Energy Mode 2 Run Enable
                EM2RUN: u1,
                ///  Energy Mode 3 Run Enable
                EM3RUN: u1,
                ///  Configuration lock
                LOCK: u1,
                ///  Energy Mode 4 Block
                EM4BLOCK: u1,
                ///  Software Oscillator Disable Block
                SWOSCBLOCK: u1,
                reserved8: u1,
                ///  Watchdog Timeout Period Select
                PERSEL: u4,
                ///  Watchdog Clock Select
                CLKSEL: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  ULFRCO
                        ULFRCO = 0x0,
                        ///  LFRCO
                        LFRCO = 0x1,
                        ///  LFXO
                        LFXO = 0x2,
                        _,
                    },
                },
                padding: u18,
            }),
            ///  Command Register
            CMD: mmio.Mmio(packed struct(u32) {
                ///  Watchdog Timer Clear
                CLEAR: u1,
                padding: u31,
            }),
            ///  Synchronization Busy Register
            SYNCBUSY: mmio.Mmio(packed struct(u32) {
                ///  CTRL Register Busy
                CTRL: u1,
                ///  CMD Register Busy
                CMD: u1,
                padding: u30,
            }),
        };

        ///  ETM
        pub const ETM = extern struct {
            ///  Main Control Register
            ETMCR: mmio.Mmio(packed struct(u32) {
                ///  ETM Control in low power mode
                POWERDWN: u1,
                reserved4: u3,
                ///  ETM Port Size
                PORTSIZE: u3,
                ///  Stall Processor
                STALL: u1,
                ///  Branch Output
                BRANCHOUTPUT: u1,
                ///  Debug Request Control
                DBGREQCTRL: u1,
                ///  ETM Programming
                ETMPROG: u1,
                ///  ETM Port Selection
                ETMPORTSEL: u1,
                reserved13: u1,
                ///  Port Mode[2]
                PORTMODE2: u1,
                reserved16: u2,
                ///  Port Mode Control
                PORTMODE: u2,
                reserved21: u3,
                ///  Port Size[3]
                EPORTSIZE: u2,
                reserved28: u5,
                ///  Time Stamp Enable
                TSTAMPEN: u1,
                padding: u3,
            }),
            ///  Configuration Code Register
            ETMCCR: mmio.Mmio(packed struct(u32) {
                ///  Number of Address Comparator Pairs
                ADRCMPPAIR: u4,
                ///  Number of Data Value Comparators
                DATACMPNUM: u4,
                ///  Number of Memeory Map Decoders
                MMDECCNT: u5,
                ///  Number of Counters
                COUNTNUM: u3,
                ///  Sequencer Present
                SEQPRES: u1,
                ///  Number of External Inputs
                EXTINPNUM: packed union {
                    raw: u3,
                    value: enum(u3) {
                        ///  Zero inputs presents
                        ZERO = 0x0,
                        ///  One inputs presents
                        ONE = 0x1,
                        ///  Two inputs presents
                        TWO = 0x2,
                        _,
                    },
                },
                ///  Number of External Output
                EXTOUTNUM: u3,
                ///  FIFIO FULL present
                FIFOFULLPRES: u1,
                ///  Number of context ID Comparators
                IDCOMPNUM: u2,
                ///  Trace Start/Stop Block Present
                TRACESS: u1,
                ///  Coprocessor and Memeory Access
                MMACCESS: u1,
                reserved31: u3,
                ///  ETM ID Register Present
                ETMID: u1,
            }),
            ///  ETM Trigger Event Register
            ETMTRIGGER: mmio.Mmio(packed struct(u32) {
                ///  ETM Resource A
                RESA: u7,
                ///  ETM Resource B
                RESB: u7,
                ///  ETM Function
                ETMFCN: u3,
                padding: u15,
            }),
            reserved16: [4]u8,
            ///  ETM Status Register
            ETMSR: mmio.Mmio(packed struct(u32) {
                ///  ETM Overflow
                ETHOF: u1,
                ///  ETM Programming Bit Status
                ETMPROGBIT: u1,
                ///  Trace Start/Stop Status
                TRACESTAT: u1,
                ///  Trigger Bit
                TRIGBIT: u1,
                padding: u28,
            }),
            ///  ETM System Configuration Register
            ETMSCR: mmio.Mmio(packed struct(u32) {
                ///  Maximum Port Size
                MAXPORTSIZE: u3,
                reserved8: u5,
                ///  FIFO FULL Supported
                FIFOFULL: u1,
                ///  Max Port Size[3]
                MAXPORTSIZE3: u1,
                ///  Port Size Supported
                PORTSIZE: u1,
                ///  Port Mode Supported
                PORTMODE: u1,
                ///  Number of Supported Processros
                PROCNUM: u3,
                reserved17: u2,
                ///  No Fetch Comparison
                NOFETCHCOMP: u1,
                padding: u14,
            }),
            reserved32: [8]u8,
            ///  ETM TraceEnable Event Register
            ETMTEEVR: mmio.Mmio(packed struct(u32) {
                ///  ETM Resource A Trace Enable
                RESA: u7,
                ///  ETM Resource B Trace Enable
                RESB: u7,
                ///  ETM Function Trace Enable
                ETMFCNEN: u3,
                padding: u15,
            }),
            ///  ETM Trace control Register
            ETMTECR1: mmio.Mmio(packed struct(u32) {
                ///  Address Comparator
                ADRCMP: u8,
                ///  Memmap
                MEMMAP: u16,
                ///  Trace Include/Exclude Flag
                INCEXCTL: u1,
                ///  Trace Control Enable
                TCE: u1,
                padding: u6,
            }),
            reserved44: [4]u8,
            ///  ETM Fifo Full Level Register
            ETMFFLR: mmio.Mmio(packed struct(u32) {
                ///  Bytes left in FIFO
                BYTENUM: u8,
                padding: u24,
            }),
            reserved320: [272]u8,
            ///  Counter Reload Value
            ETMCNTRLDVR1: mmio.Mmio(packed struct(u32) {
                ///  Free running counter reload value
                COUNT: u16,
                padding: u16,
            }),
            reserved480: [156]u8,
            ///  Synchronisation Frequency Register
            ETMSYNCFR: mmio.Mmio(packed struct(u32) {
                ///  Synchronisation Frequency Value
                FREQ: u12,
                padding: u20,
            }),
            ///  ID Register
            ETMIDR: mmio.Mmio(packed struct(u32) {
                ///  Implementation Revision
                IMPVER: u4,
                ///  Minor ETM Architecture Version
                ETMMINVER: u4,
                ///  Major ETM Architecture Version
                ETMMAJVER: u4,
                ///  Implementer Code
                PROCFAM: u4,
                ///  Load PC First
                LPCF: u1,
                reserved18: u1,
                ///  32-bit Thumb Instruction Tracing
                THUMBT: u1,
                ///  Security Extension Support
                SECEXT: u1,
                ///  Branch Packet Encoding
                BPE: u1,
                reserved24: u3,
                ///  Implementer Code
                IMPCODE: u8,
            }),
            ///  Configuration Code Extension Register
            ETMCCER: mmio.Mmio(packed struct(u32) {
                ///  Extended External Input Selectors
                EXTINPSEL: u2,
                reserved3: u1,
                ///  Extended External Input Bus
                EXTINPBUS: u8,
                ///  Readable Registers
                READREGS: u1,
                ///  Data Address comparisons
                DADDRCMP: u1,
                ///  Instrumentation Resources
                INSTRES: u3,
                ///  EmbeddedICE watchpoint inputs
                EICEWPNT: u4,
                ///  Trace Sart/Stop Block Uses EmbeddedICE watchpoint inputs
                TEICEWPNT: u1,
                ///  EmbeddedICE Behavior control Implemented
                EICEIMP: u1,
                ///  Timestamping Implemented
                TIMP: u1,
                reserved27: u4,
                ///  Reduced Function Counter
                RFCNT: u1,
                ///  Timestamp Encoding
                TENC: u1,
                ///  Timestamp Size
                TSIZE: u1,
                padding: u2,
            }),
            reserved496: [4]u8,
            ///  TraceEnable Start/Stop EmbeddedICE Control Register
            ETMTESSEICR: mmio.Mmio(packed struct(u32) {
                ///  Stop Resource Selection
                STARTRSEL: u4,
                reserved16: u12,
                ///  Stop Resource Selection
                STOPRSEL: u4,
                padding: u12,
            }),
            reserved504: [4]u8,
            ///  Timestamp Event Register
            ETMTSEVR: mmio.Mmio(packed struct(u32) {
                ///  ETM Resource A Event
                RESAEVT: u7,
                ///  ETM Resource B Event
                RESBEVT: u7,
                ///  ETM Function Event
                ETMFCNEVT: u3,
                padding: u15,
            }),
            reserved512: [4]u8,
            ///  CoreSight Trace ID Register
            ETMTRACEIDR: mmio.Mmio(packed struct(u32) {
                ///  Trace ID
                TRACEID: u7,
                padding: u25,
            }),
            reserved520: [4]u8,
            ///  ETM ID Register 2
            ETMIDR2: mmio.Mmio(packed struct(u32) {
                ///  RFE Transfer Order
                RFE: u1,
                ///  SWP Transfer Order
                SWP: u1,
                padding: u30,
            }),
            reserved788: [264]u8,
            ///  Device Power-down Status Register
            ETMPDSR: mmio.Mmio(packed struct(u32) {
                ///  ETM Powered Up
                ETMUP: u1,
                padding: u31,
            }),
            reserved3808: [3016]u8,
            ///  Integration Test Miscellaneous Inputs Register
            ETMISCIN: mmio.Mmio(packed struct(u32) {
                ///  EXTIN Value
                EXTIN: u2,
                reserved4: u2,
                ///  Core Halt
                COREHALT: u1,
                padding: u27,
            }),
            reserved3816: [4]u8,
            ///  Integration Test Trigger Out Register
            ITTRIGOUT: mmio.Mmio(packed struct(u32) {
                ///  Trigger output value
                TRIGGEROUT: u1,
                padding: u31,
            }),
            reserved3824: [4]u8,
            ///  ETM Integration Test ATB Control 2 Register
            ETMITATBCTR2: mmio.Mmio(packed struct(u32) {
                ///  ATREADY Input Value
                ATREADY: u1,
                padding: u31,
            }),
            reserved3832: [4]u8,
            ///  ETM Integration Test ATB Control 0 Register
            ETMITATBCTR0: mmio.Mmio(packed struct(u32) {
                ///  ATVALID Output Value
                ATVALID: u1,
                padding: u31,
            }),
            reserved3840: [4]u8,
            ///  ETM Integration Control Register
            ETMITCTRL: mmio.Mmio(packed struct(u32) {
                ///  Integration Mode Enable
                ITEN: u1,
                padding: u31,
            }),
            reserved4000: [156]u8,
            ///  ETM Claim Tag Set Register
            ETMCLAIMSET: mmio.Mmio(packed struct(u32) {
                ///  Tag Bits
                SETTAG: u8,
                padding: u24,
            }),
            ///  ETM Claim Tag Clear Register
            ETMCLAIMCLR: mmio.Mmio(packed struct(u32) {
                ///  Tag Bits
                CLRTAG: u1,
                padding: u31,
            }),
            reserved4016: [8]u8,
            ///  ETM Lock Access Register
            ETMLAR: mmio.Mmio(packed struct(u32) {
                ///  Key Value
                KEY: u1,
                padding: u31,
            }),
            ///  Lock Status Register
            ETMLSR: mmio.Mmio(packed struct(u32) {
                ///  ETM Locking Implemented
                LOCKIMP: u1,
                ///  ETM locked
                LOCKED: u1,
                padding: u30,
            }),
            ///  ETM Authentication Status Register
            ETMAUTHSTATUS: mmio.Mmio(packed struct(u32) {
                ///  Non-secure invasive Debug Status
                NONSECINVDBG: u2,
                ///  Non-secure non-invasive Debug Status
                NONSECNONINVDBG: packed union {
                    raw: u2,
                    value: enum(u2) {
                        ///  Non-secure non-invasive debug disable
                        DISABLE = 0x2,
                        ///  Non-secure non-invasive debug enable
                        ENABLE = 0x3,
                        _,
                    },
                },
                ///  Secure invasive Debug Status
                SECINVDBG: u2,
                ///  Secure non-invasive Debug Status
                SECNONINVDBG: u2,
                padding: u24,
            }),
            reserved4044: [16]u8,
            ///  CoreSight Device Type Register
            ETMDEVTYPE: mmio.Mmio(packed struct(u32) {
                ///  Trace Source
                TRACESRC: u4,
                ///  Processor Trace
                PROCTRACE: u4,
                padding: u24,
            }),
            ///  Peripheral ID4 Register
            ETMPIDR4: mmio.Mmio(packed struct(u32) {
                ///  JEP106 Continuation Code
                CONTCODE: u4,
                ///  4KB Count
                COUNT: u4,
                padding: u24,
            }),
            ///  Peripheral ID5 Register
            ETMPIDR5: u32,
            ///  Peripheral ID6 Register
            ETMPIDR6: u32,
            ///  Peripheral ID7 Register
            ETMPIDR7: u32,
            ///  Peripheral ID0 Register
            ETMPIDR0: mmio.Mmio(packed struct(u32) {
                ///  Part Number
                PARTNUM: u8,
                padding: u24,
            }),
            ///  Peripheral ID1 Register
            ETMPIDR1: mmio.Mmio(packed struct(u32) {
                ///  Part Number
                PARTNUM: u4,
                ///  JEP106 Identity Code
                IDCODE: u4,
                padding: u24,
            }),
            ///  Peripheral ID2 Register
            ETMPIDR2: mmio.Mmio(packed struct(u32) {
                ///  JEP106 Identity Code
                IDCODE: u3,
                ///  Always 1
                ALWAYS1: u1,
                ///  Revision
                REV: u4,
                padding: u24,
            }),
            ///  Peripheral ID3 Register
            ETMPIDR3: mmio.Mmio(packed struct(u32) {
                ///  Customer Modified
                CUSTMOD: u4,
                ///  RevAnd
                REVAND: u4,
                padding: u24,
            }),
            ///  Component ID0 Register
            ETMCIDR0: mmio.Mmio(packed struct(u32) {
                ///  CoreSight Preamble
                PREAMB: u8,
                padding: u24,
            }),
            ///  Component ID1 Register
            ETMCIDR1: mmio.Mmio(packed struct(u32) {
                ///  CoreSight Preamble
                PREAMB: u8,
                padding: u24,
            }),
            ///  Component ID2 Register
            ETMCIDR2: mmio.Mmio(packed struct(u32) {
                ///  CoreSight Preamble
                PREAMB: u8,
                padding: u24,
            }),
            ///  Component ID3 Register
            ETMCIDR3: mmio.Mmio(packed struct(u32) {
                ///  CoreSight Preamble
                PREAMB: u8,
                padding: u24,
            }),
        };
    };
};
